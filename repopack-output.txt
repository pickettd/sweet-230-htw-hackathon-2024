This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-09-07T15:31:27.877Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
assets/
  emails/
    authentication-forgot-password.template.html
    authentication-welcome.template.html
    authorization-verification-code.template.html
    base.html
    default.template.html
    style.css
models/
  account.zmodel
  answer.zmodel
  billingData.zmodel
  organization.zmodel
  organizationRole.zmodel
  question.zmodel
  ragVector.zmodel
  role.zmodel
  schema.zmodel
  session.zmodel
  user.zmodel
prisma/
  seed/
    mockData.ts
    mockUser.ts
  schema.prisma
scripts/
  env.js
  format.models.js
src/
  .marblism/
    api/
      client/
        react.ts
        utils.ts
      routers/
        Account.router.ts
        Answer.router.ts
        BillingData.router.ts
        index.ts
        Organization.router.ts
        OrganizationRole.router.ts
        Question.router.ts
        RagVector.router.ts
        Role.router.ts
        Session.router.ts
        User.router.ts
      helper.ts
    workspace/
      hooks.tsx
      index.tsx
  app/
    (authenticated)/
      home/
        page.tsx
      organizations/
        [organizationId]/
          ai-rag-upload/
            page.tsx
          billing/
            page.tsx
          chat/
            page.tsx
          dashboard/
            page.tsx
          members/
            hooks/
              useDelete.tsx
              useInvitation.tsx
              useUpdate.tsx
            page.tsx
          pricing/
            page.tsx
          settings/
            page.tsx
          users/
            page.tsx
          layout.tsx
          page.tsx
      profile/
        page.tsx
      layout.tsx
    (landing)/
      layout.tsx
      page.tsx
    (non-authenticated)/
      login/
        page.tsx
      register/
        page.tsx
      reset-password/
        [token]/
          page.tsx
        page.tsx
      layout.tsx
    api/
      auth/
        [...nextauth]/
          route.ts
      billing/
        webhook/
          stripe/
            route.ts
      trpc/
        [trpc]/
          route.ts
      upload/
        private/
          route.ts
        public/
          route.ts
    layout.tsx
    not-found.tsx
  core/
    analytics/
      internal/
        AnalyticsProvider.tsx
        PostHogPageView.tsx
      index.ts
    authentication/
      index.ts
    configuration/
      index.ts
    context/
      internal/
        useOrganizationContext.tsx
        useUserContext.tsx
      index.tsx
    database/
      internal/
        protected.ts
        unprotected.ts
      index.ts
    helpers/
      date/
        index.ts
      file/
        index.ts
      utility/
        index.ts
    hooks/
      upload/
        index.tsx
    trpc/
      internal/
        trpc.client.tsx
        trpc.server.ts
      index.tsx
      server.ts
  designSystem/
    core/
      html/
        index.tsx
        theme.ts
      main/
        index.tsx
      splashScreen/
        index.tsx
      index.tsx
    helpers/
      utility.ts
    landing/
      images/
        rightArrow.svg
      LandingNavBar/
        landing.desktop.navbar.tsx
        landing.mobile.navbar.tsx
        landing.navbar.items.tsx
        landing.navbar.tsx
      LandingAvatar.tsx
      LandingButton.tsx
      LandingContainer.tsx
      LandingCTA.tsx
      LandingFAQ.tsx
      LandingFeatures.tsx
      LandingFooter.tsx
      LandingHero.tsx
      LandingHowItWorks.tsx
      LandingPainPoints.tsx
      LandingPricing.tsx
      LandingRating.tsx
      LandingSocialProof.tsx
      LandingSocialRating.tsx
      LandingTestimonials.tsx
    layouts/
      NavigationLayout/
        components/
          Leftbar/
            index.tsx
          Logo/
            index.tsx
          OrganizationSelect/
            index.tsx
          Topbar/
            index.tsx
        types/
          NavigationItem.tsx
        index.tsx
      index.tsx
      Page.layout.tsx
    providers/
      snackbar/
        index.tsx
      index.tsx
    style/
      landing.scss
      main.scss
    theme/
      theme.tsx
    ui/
      AppHeader/
        index.tsx
    index.tsx
    provider.tsx
  server/
    libraries/
      email/
        internal/
          providers/
            mailjet/
              mailjet.provider.ts
            nodemailer/
              nodemailer.provider.ts
            provider.ts
          templates/
            components.ts
            email.template.service.ts
          email.type.ts
        email.service.ts
        index.ts
      openai/
        internal/
          openai.ts
        index.ts
      payment/
        internal/
          providers/
            stripe/
              stripe.provider.ts
            provider.ts
        index.ts
        payment.service.ts
        payment.type.ts
      rag/
        index.ts
      upload/
        internal/
          providers/
            aws/
              upload.provider.aws.ts
            local/
              upload.provider.local.ts
        index.ts
        upload.provider.ts
        upload.service.ts
        upload.type.ts
    routers/
      ai.router.ts
      authentication.router.ts
      billing.router.ts
      configuration.router.ts
      rag.router.ts
      upload.router.ts
    index.tsx
.env.template
.eslintrc.json
.gitignore
.marblism.json
.prettierrc
docker-compose.yml
next.config.js
package.json
postcss.config.js
README.md
tailwind.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: assets/emails/authentication-forgot-password.template.html
================
<Card.Header>
  <h2>Password Reset</h2>
  <hr />
</Card.Header>

<Card.Body>
  <p>We received a request to reset your password.</p>
  <p>Click the button below to reset it</p>
  <p>
    <a href="{{ url_password_reset }}" target="_blank">Reset Password</a>
  </p>
  <p>If you did not request a password reset, ignore this email.</p>
</Card.Body>

<Card.Footer>
  <p>Sent by Mel the HR</p>
</Card.Footer>

================
File: assets/emails/authentication-welcome.template.html
================
<Card.Header>
  <h2>Welcome to Mel the HR</h2>
  <hr />
</Card.Header>

<Card.Body>
  <p>Your account is now active.</p>
</Card.Body>

<Card.Footer>
  <p>Sent by Mel the HR</p>
</Card.Footer>

================
File: assets/emails/authorization-verification-code.template.html
================
<Card.Header>
  <h2>Single-use verification code</h2>
  <hr />
</Card.Header>

<Card.Body>
  <p>
    You are receiving this e-mail because a request has been made for a unique
    code
  </p>
  <p>Enter the following code for verification</p>
  <p>
    <span class="badge">{{ code }}</span>
  </p>
  <p>Code expires in {{ expiration }}</p>
</Card.Body>

<Card.Footer>
  <p>Sent by Mel the HR</p>
</Card.Footer>

================
File: assets/emails/base.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Marblism</title>
    <style>
      {{ style }}
    </style>
  </head>
  <body>
    <div class="card">{{ content }}</div>
  </body>
</html>

================
File: assets/emails/default.template.html
================
{{ content }}

================
File: assets/emails/style.css
================
body {
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  line-height: 1.6;
  color: rgba(41, 41, 41, 1);
}

.card {
  max-width: 600px;
  margin: 20px auto;
  border: 1px solid #ddd;
  border-radius: 4px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  overflow: hidden;
  font-size: 16px;
}

h1,
h2,
h3 {
  font-weight: 700;
  text-transform: uppercase;
  color: black;
}

p {
  width: 100%;
}

.card-header,
.card-body,
.card-footer {
  padding-top: 28px;
  padding-left: 40px;
  padding-right: 40px;
}

.card-body,
.card-footer {
  padding-bottom: 28px;
}

.card-body {
  color: rgba(41, 41, 41, 1);
}

.card-footer {
  color: white;
  font-size: 13px;
  background: black;
}

hr {
  width: 100%;
  border-top: 1px solid black;
}

.badge,
a {
  color: #4f4f4f;
  background: white;
  font-size: 16px;
  font-weight: 700;
  padding: 12px 16px 12px 16px;
  border: 1px solid grey;
  border-radius: 4px;
  text-decoration: none;
}

a {
  cursor: pointer;
}

a:hover {
  color: black;
  border-color: black;
}

td {
  width: 100%;
}

================
File: models/account.zmodel
================
import "./user.zmodel"

model Account {
    id                       String  @id @default(uuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])

    @@allow("all", auth().id == user.id)
}

================
File: models/answer.zmodel
================
import "./question.zmodel"  

model Answer {

    id                String        @id @default(uuid())  
    content      String          
    dateAnswered  String          
    questionId  String?          
    question    Question?    @relation(fields: [questionId], references: [id], name:"question")  

dateCreated DateTime @default(now())
      dateUpdated DateTime @updatedAt  @default(now())
      @@allow("all", true)
}

================
File: models/billingData.zmodel
================
import "./organization.zmodel"  

model BillingData {

    id                String        @id @default(uuid())  
    numberOfUsers  Float            
    billingDate  String          
    organizationId  String?          
    organization  Organization?  @relation(fields: [organizationId], references: [id], name:"organization")  

dateCreated DateTime @default(now())
      dateUpdated DateTime @updatedAt  @default(now())
      @@allow("all", true)
}

================
File: models/organization.zmodel
================
import "./organizationRole.zmodel";

import './organizationRole.zmodel'

import './question.zmodel'

import './billingData.zmodel'

model Organization {
    id               String             @id @default(uuid())
    name             String
    pictureUrl       String?            @default('https://i.imgur.com/BgkFiid.jpeg')
    
    stripeCustomerId String?
    
    dateCreated      DateTime           @default(now())
    dateUpdated      DateTime           @updatedAt @default(now())
    roles            OrganizationRole[]

questions  Question[]  @relation("organization")  
        billings    BillingData[]  @relation("organization")  

@@allow('all', auth().roles?[name == 'admin'])
    @@allow('all', roles?[user == auth() && name == 'owner'])
    @@allow('read', roles?[user == auth()])
}

================
File: models/organizationRole.zmodel
================
import './organization'
import './user'

model OrganizationRole {
    id             String       @id @default(uuid())
    name           String
    dateCreated    DateTime     @default(now())
    dateUpdated    DateTime     @updatedAt @default(now())

    userId         String
    user           User         @relation(fields: [userId], references: [id])
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

    @@allow('all', auth().roles?[name == 'admin'])
    @@allow('all', organization.roles?[user == auth() && name == 'owner'])
    @@allow('create', organization.roles?[user == auth()] && name != 'owner')
    @@allow('read', organization.roles?[user == auth()])
    @@allow('delete', auth() == user)
}

================
File: models/question.zmodel
================
import "./user.zmodel"  
 import "./organization.zmodel"  
 import "./answer.zmodel"  

model Question {

    id                String        @id @default(uuid())  
    content      String          
    dateAsked  String          
    userId        String?          
    user            User?            @relation(fields: [userId], references: [id], name:"user")  
    organizationId  String?          
    organization  Organization?  @relation(fields: [organizationId], references: [id], name:"organization")  

answers      Answer[]    @relation("question")  
      dateCreated DateTime @default(now())
      dateUpdated DateTime @updatedAt  @default(now())
      @@allow("all", true)
}

================
File: models/ragVector.zmodel
================
model RagVector {
    id        String   @id @default(uuid())
    key       String
    url       String
    tags      String[] @default([])
    vectors   Bytes?   @omit
    documents Bytes?   @omit

@@allow("all", true)
}

================
File: models/role.zmodel
================
import "./user.zmodel";

model Role {
    id     String @id @default(uuid())
    name   String
    userId String
    user   User   @relation(fields: [userId], references: [id])

    @@allow('read', auth().id == this.userId)
    @@allow('delete', auth().id == this.userId)
    @@allow('create', name != 'admin')
    @@allow('update', future().name != 'admin')
}

================
File: models/schema.zmodel
================
import "./account.zmodel";
import "./user.zmodel";
import "./role.zmodel";
import "./session.zmodel";

import "./ragVector.zmodel"

import "./question.zmodel"; 

import "./answer.zmodel"; 

import "./billingData.zmodel"; 

generator client {
    provider = "prisma-client-js"
}

plugin prisma {
    provider = '@core/prisma'
    output = "./../prisma/schema.prisma"
}

datasource db {
    provider = "postgresql"
    url      = env("SERVER_DATABASE_URL")
}

plugin trpc {
    provider = '@zenstackhq/trpc'
    output = "./../src/.marblism/api"
    generateClientHelpers = ['react']
    generateModelActions = ['create', 'update', 'delete', 'findMany', 'findFirst', 'findUnique', 'createMany', 'updateMany', 'deleteMany']
}

================
File: models/session.zmodel
================
import "./user.zmodel";

model Session {
    id           String   @id @default(uuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@allow("all", auth().id == user.id)
}

================
File: models/user.zmodel
================
import "./account.zmodel";
import "./session.zmodel";
import "./role.zmodel";

import './organizationRole.zmodel'

import './question.zmodel'

import "./organizationRole.zmodel";

enum UserStatus {
    INVITED
    VERIFIED
}

model User {
    id                String             @id @default(uuid())
    name              String?
    email             String?            @unique
    pictureUrl        String?            @default('https://i.imgur.com/ZdJSK3Y.jpeg')
    tokenInvitation   String?
    
    stripeCustomerId  String?
    
    status            UserStatus         @default(VERIFIED)
    password          String?            @password @omit
    dateCreated       DateTime           @default(now())
    dateUpdated       DateTime           @updatedAt @default(now())
    accounts          Account[]
    sessions          Session[]
    roles             Role[]
    
    organizationRoles OrganizationRole[]

questions  Question[]  @relation("user")  

@@auth()
    @@allow("all", auth().id == this.id)
    @@allow('all', auth().roles?[name == 'admin'])
    @@allow("create", true)
    @@allow("read", true)
}

================
File: prisma/seed/mockData.ts
================
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const splitSql = (sql: string) => {
  return sql.split(';').filter(content => content.trim() !== '')
}

async function main() {
  const sql = `

INSERT INTO "User" ("id", "email", "name", "pictureUrl", "tokenInvitation", "status", "password") VALUES ('9d1f5dee-b636-4e70-84d5-0981e3b0f2b3', '1Marcellus91@gmail.com', 'John Doe', 'https://i.imgur.com/YfJQV5z.png?id=3', 'inv11223', 'VERIFIED', '$2b$10$ppubsZypHzkqW9dkhMB97ul2.wSsvaCoDE2CzqIHygddRMKXvpYUC');
INSERT INTO "User" ("id", "email", "name", "pictureUrl", "tokenInvitation", "status", "password") VALUES ('766e4ddd-67df-4f36-9d9e-ad9318f1f4a7', '8Kody31@hotmail.com', 'John Doe', 'https://i.imgur.com/YfJQV5z.png?id=10', 'inv11223', 'VERIFIED', '$2b$10$ppubsZypHzkqW9dkhMB97ul2.wSsvaCoDE2CzqIHygddRMKXvpYUC');
INSERT INTO "User" ("id", "email", "name", "pictureUrl", "tokenInvitation", "status", "password") VALUES ('643eed41-246e-4654-949c-d6f21728a317', '22Ernest.Hilll63@hotmail.com', 'David Wilson', 'https://i.imgur.com/YfJQV5z.png?id=24', 'inv54321', 'VERIFIED', '$2b$10$ppubsZypHzkqW9dkhMB97ul2.wSsvaCoDE2CzqIHygddRMKXvpYUC');
INSERT INTO "User" ("id", "email", "name", "pictureUrl", "tokenInvitation", "status", "password") VALUES ('5e349442-b0f9-4d79-8974-5aca153cec10', '29Winona.Beier@yahoo.com', 'John Doe', 'https://i.imgur.com/YfJQV5z.png?id=31', 'inv54321', 'VERIFIED', '$2b$10$ppubsZypHzkqW9dkhMB97ul2.wSsvaCoDE2CzqIHygddRMKXvpYUC');
INSERT INTO "User" ("id", "email", "name", "pictureUrl", "tokenInvitation", "status", "password") VALUES ('5e7c2ce6-227a-4708-bba0-7cb87726df09', '36Jaunita.Beer@gmail.com', 'Michael Brown', 'https://i.imgur.com/YfJQV5z.png?id=38', 'inv67890', 'VERIFIED', '$2b$10$ppubsZypHzkqW9dkhMB97ul2.wSsvaCoDE2CzqIHygddRMKXvpYUC');
INSERT INTO "User" ("id", "email", "name", "pictureUrl", "tokenInvitation", "status", "password") VALUES ('7a68eb60-ff76-4087-b640-f9f24eb86b9a', '43Amely83@hotmail.com', 'David Wilson', 'https://i.imgur.com/YfJQV5z.png?id=45', 'inv54321', 'VERIFIED', '$2b$10$ppubsZypHzkqW9dkhMB97ul2.wSsvaCoDE2CzqIHygddRMKXvpYUC');
INSERT INTO "User" ("id", "email", "name", "pictureUrl", "tokenInvitation", "status", "password") VALUES ('5468146e-3fd4-4e5a-acd4-6d9a33ac1fe7', '50Jadon.Wilkinson@gmail.com', 'Michael Brown', 'https://i.imgur.com/YfJQV5z.png?id=52', 'inv67890', 'VERIFIED', '$2b$10$ppubsZypHzkqW9dkhMB97ul2.wSsvaCoDE2CzqIHygddRMKXvpYUC');
INSERT INTO "User" ("id", "email", "name", "pictureUrl", "tokenInvitation", "status", "password") VALUES ('423e5bcb-8051-4f52-93e3-5daab616155a', '57Evie.Leannon8@yahoo.com', 'Michael Brown', 'https://i.imgur.com/YfJQV5z.png?id=59', 'inv67890', 'VERIFIED', '$2b$10$ppubsZypHzkqW9dkhMB97ul2.wSsvaCoDE2CzqIHygddRMKXvpYUC');
INSERT INTO "User" ("id", "email", "name", "pictureUrl", "tokenInvitation", "status", "password") VALUES ('34987111-4560-4ec5-be0e-d7cafdc7efa1', '64Florida2@hotmail.com', 'David Wilson', 'https://i.imgur.com/YfJQV5z.png?id=66', 'inv67890', 'VERIFIED', '$2b$10$ppubsZypHzkqW9dkhMB97ul2.wSsvaCoDE2CzqIHygddRMKXvpYUC');

INSERT INTO "RagVector" ("id", "key", "tags") VALUES ('c1363119-cfcd-4ca8-a1d2-c3303c0b5274', 'z9y8x7w6v5u4t3s2r1q0', '{"degenero":"adeptio","advoco":"bellicus","ciminatio":"comburo","subvenio":"curo","suus":"creo"}'::jsonb);
INSERT INTO "RagVector" ("id", "key", "tags") VALUES ('833a0f24-2cac-4905-a937-f07dd646b119', 'a1b2c3d4e5f6g7h8i9j0', '{"vorax":"cupiditate","thymum":"validus","surgo":"solium","amor":"vespillo"}'::jsonb);
INSERT INTO "RagVector" ("id", "key", "tags") VALUES ('63153491-f86b-403b-bfe2-4420347f0a36', 'w1x2y3z4a5b6c7d8e9f0', '{"atque":"volva","universe":"socius","charisma":"vitiosus","claustrum":"super"}'::jsonb);
INSERT INTO "RagVector" ("id", "key", "tags") VALUES ('feede1b6-ebdf-43a5-849a-a3a553303526', 'z9y8x7w6v5u4t3s2r1q0', '{"adopto":"substantia","cornu":"truculenter","thermae":"sulum"}'::jsonb);
INSERT INTO "RagVector" ("id", "key", "tags") VALUES ('6e174162-e0bb-4201-af90-3eb6d109c2d8', 'm1n2o3p4q5r6s7t8u9v0', '{"carcer":"amiculum","ubi":"amiculum","allatus":"auctus","amplitudo":"dolor","minus":"cibus"}'::jsonb);
INSERT INTO "RagVector" ("id", "key", "tags") VALUES ('4cbb313a-6c5c-48c4-9e02-c3d7d758f33e', 'a1b2c3d4e5f6g7h8i9j0', '{"accusantium":"vespillo","termes":"sub","thymum":"abduco","enim":"suasoria","communis":"baiulus"}'::jsonb);
INSERT INTO "RagVector" ("id", "key", "tags") VALUES ('a427e9f6-590a-4c56-a8c2-8cc3fbb6822b', 'z9y8x7w6v5u4t3s2r1q0', '{"voco":"approbo","vigor":"deputo","trans":"tracto","ver":"explicabo"}'::jsonb);
INSERT INTO "RagVector" ("id", "key", "tags") VALUES ('9c97b699-6a48-4419-8c3f-129cb86413f8', 'g1h2i3j4k5l6m7n8o9p0', '{"vociferor":"doloribus","colligo":"cogito","tergo":"caelestis","conitor":"virtus"}'::jsonb);
INSERT INTO "RagVector" ("id", "key", "tags") VALUES ('d68d0ea2-9b91-4176-af0b-a682d928e2f3', 'z9y8x7w6v5u4t3s2r1q0', '{"quia":"ubi","credo":"quidem","pecco":"ex"}'::jsonb);
INSERT INTO "RagVector" ("id", "key", "tags") VALUES ('4cf4b9fa-1222-428b-87a7-2a1d4f17fa1a', 'z9y8x7w6v5u4t3s2r1q0', '{"atrox":"magni","xiphias":"solio","amissio":"acervus"}'::jsonb);

INSERT INTO "Organization" ("id", "name", "pictureUrl") VALUES ('e76fd05f-3b6f-41c3-918b-ffd96e699422', 'Tech Innovators Inc.', 'https://i.imgur.com/YfJQV5z.png?id=102');
INSERT INTO "Organization" ("id", "name", "pictureUrl") VALUES ('b3e941dc-dc1c-4566-91a9-454a4ee37c9d', 'NextGen Enterprises', 'https://i.imgur.com/YfJQV5z.png?id=105');
INSERT INTO "Organization" ("id", "name", "pictureUrl") VALUES ('29fd8e28-669c-45c5-9435-79783d861301', 'Global Solutions LLC', 'https://i.imgur.com/YfJQV5z.png?id=108');
INSERT INTO "Organization" ("id", "name", "pictureUrl") VALUES ('d9573320-5340-43e3-8193-40c720725d11', 'Global Solutions LLC', 'https://i.imgur.com/YfJQV5z.png?id=111');
INSERT INTO "Organization" ("id", "name", "pictureUrl") VALUES ('36ab21c2-6517-4e4b-ab3b-89a79700b041', 'Global Solutions LLC', 'https://i.imgur.com/YfJQV5z.png?id=114');
INSERT INTO "Organization" ("id", "name", "pictureUrl") VALUES ('f59676ac-f96b-4c0f-bcd1-ca921d8e8e32', 'Future Vision Corp', 'https://i.imgur.com/YfJQV5z.png?id=117');
INSERT INTO "Organization" ("id", "name", "pictureUrl") VALUES ('1878e18b-9003-4b5e-ab90-c10cfd806bb8', 'Future Vision Corp', 'https://i.imgur.com/YfJQV5z.png?id=120');
INSERT INTO "Organization" ("id", "name", "pictureUrl") VALUES ('edfa9132-2aa2-473c-bc0d-bd6ea76a07c2', 'NextGen Enterprises', 'https://i.imgur.com/YfJQV5z.png?id=123');
INSERT INTO "Organization" ("id", "name", "pictureUrl") VALUES ('ede6e21d-1289-4c2c-bf0d-581b3cdc14e2', 'Tech Innovators Inc.', 'https://i.imgur.com/YfJQV5z.png?id=126');
INSERT INTO "Organization" ("id", "name", "pictureUrl") VALUES ('e49bc8d5-ebdb-4883-9750-934c91ac63fb', 'Pioneer Tech Group', 'https://i.imgur.com/YfJQV5z.png?id=129');

INSERT INTO "OrganizationRole" ("id", "name", "userId", "organizationId") VALUES ('e77148eb-865d-44cf-82fa-54880d82bb2c', 'Manager', '5e7c2ce6-227a-4708-bba0-7cb87726df09', 'ede6e21d-1289-4c2c-bf0d-581b3cdc14e2');
INSERT INTO "OrganizationRole" ("id", "name", "userId", "organizationId") VALUES ('4872f0ac-ceb9-4efa-ad46-bf4163b9452e', 'Team Lead', '766e4ddd-67df-4f36-9d9e-ad9318f1f4a7', '29fd8e28-669c-45c5-9435-79783d861301');
INSERT INTO "OrganizationRole" ("id", "name", "userId", "organizationId") VALUES ('c83b852e-af35-4a49-a4d2-4de7846aa1ac', 'Manager', '423e5bcb-8051-4f52-93e3-5daab616155a', 'ede6e21d-1289-4c2c-bf0d-581b3cdc14e2');
INSERT INTO "OrganizationRole" ("id", "name", "userId", "organizationId") VALUES ('f5b6ded1-939a-4821-8904-9143023498a6', 'HR Specialist', '21a857f1-ba5f-4435-bcf6-f910ec07c0dc', 'e49bc8d5-ebdb-4883-9750-934c91ac63fb');
INSERT INTO "OrganizationRole" ("id", "name", "userId", "organizationId") VALUES ('3be9e77c-70b3-4080-b404-90d581cdd1a8', 'User', '34987111-4560-4ec5-be0e-d7cafdc7efa1', 'f59676ac-f96b-4c0f-bcd1-ca921d8e8e32');
INSERT INTO "OrganizationRole" ("id", "name", "userId", "organizationId") VALUES ('2093594b-a540-4465-ab1b-002198eea6ee', 'Admin', '21a857f1-ba5f-4435-bcf6-f910ec07c0dc', 'e49bc8d5-ebdb-4883-9750-934c91ac63fb');
INSERT INTO "OrganizationRole" ("id", "name", "userId", "organizationId") VALUES ('fbe44838-6ebd-4b84-8ba3-897f1d0de599', 'Team Lead', '7a68eb60-ff76-4087-b640-f9f24eb86b9a', 'f59676ac-f96b-4c0f-bcd1-ca921d8e8e32');
INSERT INTO "OrganizationRole" ("id", "name", "userId", "organizationId") VALUES ('eb5a5be0-2c4a-4cf5-b4d5-0fe512dca560', 'HR Specialist', '5e349442-b0f9-4d79-8974-5aca153cec10', '1878e18b-9003-4b5e-ab90-c10cfd806bb8');
INSERT INTO "OrganizationRole" ("id", "name", "userId", "organizationId") VALUES ('65b3a252-5ad5-4193-b384-b11497aab7da', 'Manager', '34987111-4560-4ec5-be0e-d7cafdc7efa1', 'ede6e21d-1289-4c2c-bf0d-581b3cdc14e2');
INSERT INTO "OrganizationRole" ("id", "name", "userId", "organizationId") VALUES ('4a125543-9c8f-44ae-b872-ac68ac55c06d', 'HR Specialist', '34987111-4560-4ec5-be0e-d7cafdc7efa1', 'b3e941dc-dc1c-4566-91a9-454a4ee37c9d');

INSERT INTO "Question" ("id", "content", "dateAsked", "userId", "organizationId") VALUES ('3e9384be-c9d4-4e16-a165-df55a36c1cd4', 'What is the process for reporting workplace harassment', '2023-12-14T16:39:33.688Z', '5e7c2ce6-227a-4708-bba0-7cb87726df09', 'e49bc8d5-ebdb-4883-9750-934c91ac63fb');
INSERT INTO "Question" ("id", "content", "dateAsked", "userId", "organizationId") VALUES ('fd341e8b-f77a-42ea-9ed2-7ec8833e53b2', 'Can I carry over unused vacation days to the next year', '2025-05-15T06:16:49.904Z', '21a857f1-ba5f-4435-bcf6-f910ec07c0dc', 'edfa9132-2aa2-473c-bc0d-bd6ea76a07c2');
INSERT INTO "Question" ("id", "content", "dateAsked", "userId", "organizationId") VALUES ('6c5e5798-f032-46a1-ad6f-d4369c676df8', 'What are the health insurance options available', '2025-01-02T23:37:41.824Z', '21a857f1-ba5f-4435-bcf6-f910ec07c0dc', 'edfa9132-2aa2-473c-bc0d-bd6ea76a07c2');
INSERT INTO "Question" ("id", "content", "dateAsked", "userId", "organizationId") VALUES ('2afbf1eb-2d95-4b9b-a8c2-6db401e45991', 'Can I carry over unused vacation days to the next year', '2025-05-26T08:35:28.389Z', '766e4ddd-67df-4f36-9d9e-ad9318f1f4a7', 'e49bc8d5-ebdb-4883-9750-934c91ac63fb');
INSERT INTO "Question" ("id", "content", "dateAsked", "userId", "organizationId") VALUES ('af28757c-3fd5-4005-9017-7483134442ac', 'Can I carry over unused vacation days to the next year', '2024-04-12T12:40:43.662Z', '423e5bcb-8051-4f52-93e3-5daab616155a', 'f59676ac-f96b-4c0f-bcd1-ca921d8e8e32');
INSERT INTO "Question" ("id", "content", "dateAsked", "userId", "organizationId") VALUES ('964b7de5-71fe-4314-8071-2ad9ebadb862', 'Can I carry over unused vacation days to the next year', '2025-04-19T02:35:09.084Z', '34987111-4560-4ec5-be0e-d7cafdc7efa1', '36ab21c2-6517-4e4b-ab3b-89a79700b041');
INSERT INTO "Question" ("id", "content", "dateAsked", "userId", "organizationId") VALUES ('4d85f8c1-af46-4587-ba0e-5f36c54fb5ba', 'What is the process for reporting workplace harassment', '2023-10-12T10:50:04.831Z', '34987111-4560-4ec5-be0e-d7cafdc7efa1', '1878e18b-9003-4b5e-ab90-c10cfd806bb8');
INSERT INTO "Question" ("id", "content", "dateAsked", "userId", "organizationId") VALUES ('83f9f908-970c-4a24-9e41-d92cf2145405', 'How do I apply for parental leave', '2025-08-08T15:41:41.784Z', '21a857f1-ba5f-4435-bcf6-f910ec07c0dc', 'e76fd05f-3b6f-41c3-918b-ffd96e699422');
INSERT INTO "Question" ("id", "content", "dateAsked", "userId", "organizationId") VALUES ('324d3162-8a6f-403d-bd71-8c8c240024af', 'Can I carry over unused vacation days to the next year', '2023-10-03T10:04:12.206Z', '5468146e-3fd4-4e5a-acd4-6d9a33ac1fe7', '36ab21c2-6517-4e4b-ab3b-89a79700b041');
INSERT INTO "Question" ("id", "content", "dateAsked", "userId", "organizationId") VALUES ('b274c0a9-191a-4869-a0b6-a96364e52e2f', 'What is the companys policy on remote work', '2023-10-28T15:15:02.113Z', '766e4ddd-67df-4f36-9d9e-ad9318f1f4a7', '29fd8e28-669c-45c5-9435-79783d861301');

INSERT INTO "Answer" ("id", "content", "dateAnswered", "questionId") VALUES ('7cdb93a8-2e62-488e-a566-e4e55b5696d3', 'The company observes all federal holidays.', '2023-10-02T06:32:29.524Z', '3e9384be-c9d4-4e16-a165-df55a36c1cd4');
INSERT INTO "Answer" ("id", "content", "dateAnswered", "questionId") VALUES ('91a93b8f-2e4d-4892-bfc9-3effe4c9d1e3', 'Employees are eligible for a 401k plan after 6 months.', '2024-02-26T11:43:20.519Z', '324d3162-8a6f-403d-bd71-8c8c240024af');
INSERT INTO "Answer" ("id", "content", "dateAnswered", "questionId") VALUES ('76d94d14-bc87-4f3f-bc68-86c6967a42db', 'Employees are eligible for a 401k plan after 6 months.', '2025-05-22T18:36:02.987Z', '964b7de5-71fe-4314-8071-2ad9ebadb862');
INSERT INTO "Answer" ("id", "content", "dateAnswered", "questionId") VALUES ('fbff9f1f-e279-408c-bcbb-ff4a4667a1f5', 'Employees are eligible for a 401k plan after 6 months.', '2025-01-27T20:20:45.476Z', '6c5e5798-f032-46a1-ad6f-d4369c676df8');
INSERT INTO "Answer" ("id", "content", "dateAnswered", "questionId") VALUES ('ddb98a9f-0862-4d48-82ba-b0a1db4f1a98', 'Our company offers 15 days of paid time off annually.', '2023-09-30T02:00:19.195Z', '6c5e5798-f032-46a1-ad6f-d4369c676df8');
INSERT INTO "Answer" ("id", "content", "dateAnswered", "questionId") VALUES ('cd4e0552-92bf-49e8-934b-2f6023979df9', 'The health insurance plan covers medical dental and vision.', '2024-02-24T18:25:03.864Z', '324d3162-8a6f-403d-bd71-8c8c240024af');
INSERT INTO "Answer" ("id", "content", "dateAnswered", "questionId") VALUES ('85861b02-00c2-41de-852d-4bbaf9b4d63b', 'You can apply for leave through the HR portal.', '2025-03-27T10:32:45.055Z', '83f9f908-970c-4a24-9e41-d92cf2145405');
INSERT INTO "Answer" ("id", "content", "dateAnswered", "questionId") VALUES ('7b8dc9a0-750c-4d83-a069-7f88b93c0207', 'You can apply for leave through the HR portal.', '2025-04-05T20:05:28.241Z', '4d85f8c1-af46-4587-ba0e-5f36c54fb5ba');
INSERT INTO "Answer" ("id", "content", "dateAnswered", "questionId") VALUES ('0216b9da-f1e1-46d7-89a2-0cde33ac4505', 'Employees are eligible for a 401k plan after 6 months.', '2023-11-02T10:48:23.420Z', '2afbf1eb-2d95-4b9b-a8c2-6db401e45991');
INSERT INTO "Answer" ("id", "content", "dateAnswered", "questionId") VALUES ('3bcbd94e-e1df-4e5e-a18d-4334581f450d', 'Our company offers 15 days of paid time off annually.', '2023-12-27T07:52:58.945Z', '4d85f8c1-af46-4587-ba0e-5f36c54fb5ba');

INSERT INTO "BillingData" ("id", "numberOfUsers", "billingDate", "organizationId") VALUES ('4d79dde1-06a6-434d-a975-5344332af810', 114, '2025-08-12T00:51:01.664Z', 'b3e941dc-dc1c-4566-91a9-454a4ee37c9d');
INSERT INTO "BillingData" ("id", "numberOfUsers", "billingDate", "organizationId") VALUES ('3b7837fe-ee31-4f96-b26a-3a48426bde53', 123, '2025-04-22T21:26:08.267Z', 'f59676ac-f96b-4c0f-bcd1-ca921d8e8e32');
INSERT INTO "BillingData" ("id", "numberOfUsers", "billingDate", "organizationId") VALUES ('979d13fc-2d6b-456e-b8cc-56cc743f86cd', 129, '2025-03-10T07:38:57.263Z', 'b3e941dc-dc1c-4566-91a9-454a4ee37c9d');
INSERT INTO "BillingData" ("id", "numberOfUsers", "billingDate", "organizationId") VALUES ('f6ff81d5-a8da-4d3a-a850-53364a128bf4', 495, '2025-01-08T21:46:59.551Z', '29fd8e28-669c-45c5-9435-79783d861301');
INSERT INTO "BillingData" ("id", "numberOfUsers", "billingDate", "organizationId") VALUES ('6cf09645-dab3-4836-9bbc-21671e7e4c76', 940, '2025-08-16T00:55:54.817Z', 'd9573320-5340-43e3-8193-40c720725d11');
INSERT INTO "BillingData" ("id", "numberOfUsers", "billingDate", "organizationId") VALUES ('ef6fe024-507a-46fb-8247-0037d1281928', 2, '2025-07-20T19:34:43.772Z', '29fd8e28-669c-45c5-9435-79783d861301');
INSERT INTO "BillingData" ("id", "numberOfUsers", "billingDate", "organizationId") VALUES ('27f1aaaf-02eb-4da2-b210-2e7a3bf140e2', 697, '2023-11-10T05:34:42.302Z', '29fd8e28-669c-45c5-9435-79783d861301');
INSERT INTO "BillingData" ("id", "numberOfUsers", "billingDate", "organizationId") VALUES ('fc56d479-623b-4a77-93d2-c1ce5ee3dc82', 758, '2025-08-19T06:20:04.130Z', 'd9573320-5340-43e3-8193-40c720725d11');
INSERT INTO "BillingData" ("id", "numberOfUsers", "billingDate", "organizationId") VALUES ('6802ce99-08f9-4e72-ba27-554e84bc5aa1', 369, '2024-04-09T09:53:05.630Z', 'edfa9132-2aa2-473c-bc0d-bd6ea76a07c2');
INSERT INTO "BillingData" ("id", "numberOfUsers", "billingDate", "organizationId") VALUES ('a1aec18d-190c-4724-b372-2ae722229f1b', 758, '2024-11-21T22:26:17.382Z', '36ab21c2-6517-4e4b-ab3b-89a79700b041');

  `

  const sqls = splitSql(sql)

  for (const sql of sqls) {
    try {
      await prisma.$executeRawUnsafe(`${sql}`)
    } catch (error) {
      console.log(`Could not insert SQL: ${error.message}`)
    }
  }
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async error => {
    console.error(error)
    await prisma.$disconnect()
    process.exit(1)
  })

================
File: prisma/seed/mockUser.ts
================
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const splitSql = (sql: string) => {
  return sql.split(';').filter(content => content.trim() !== '')
}

async function main() {
  const sql = `
INSERT INTO "User" (
  "id",
  "email", 
  "name", 
  "pictureUrl", 

"password"
) VALUES (
  '21a857f1-ba5f-4435-bcf6-f910ec07c0dc',
  'test@test.com',
  'John Doe',
  'https://i.imgur.com/sdjqd62.jpeg',

'$2b$10$ppubsZypHzkqW9dkhMB97ul2.wSsvaCoDE2CzqIHygddRMKXvpYUC'
);

INSERT INTO "Role" (
  "id",
  "userId",
  "name"
) VALUES (
  '31a857f1-ba5f-4435-bcf6-f910ec07c0dc',
  '21a857f1-ba5f-4435-bcf6-f910ec07c0dc',
  'admin'
);
  `

  const sqls = splitSql(sql)

  for (const sql of sqls) {
    try {
      await prisma.$executeRawUnsafe(`${sql}`)
    } catch (error) {
      console.log(`Could not insert SQL: ${error.message}`)
    }
  }
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async error => {
    console.error(error)
    await prisma.$disconnect()
    process.exit(1)
  })

================
File: prisma/schema.prisma
================
//////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY THIS FILE                                                                  //
// This file is automatically generated by ZenStack CLI and should not be manually updated. //
//////////////////////////////////////////////////////////////////////////////////////////////

datasource db {
  provider = "postgresql"
  url      = env("SERVER_DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum UserStatus {
  INVITED
  VERIFIED
}

/// @@allow('all', auth().id == user.id)
model Account {
  id                       String  @id() @default(uuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String?
  access_token             String?
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String?
  session_state            String?
  user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  refresh_token_expires_in Int?

  @@unique([provider, providerAccountId])
}

/// @@auth
/// @@allow('all', auth().id == this.id)
/// @@allow('all', auth().roles?[name == 'admin'])
/// @@allow('create', true)
/// @@allow('read', true)
model User {
  id                String             @id() @default(uuid())
  name              String?
  email             String?            @unique()
  pictureUrl        String?            @default("https://i.imgur.com/ZdJSK3Y.jpeg")
  tokenInvitation   String?
  stripeCustomerId  String?
  status            UserStatus         @default(VERIFIED)
  /// @password
  /// @omit
  password          String?
  dateCreated       DateTime           @default(now())
  dateUpdated       DateTime           @default(now()) @updatedAt()
  accounts          Account[]
  sessions          Session[]
  roles             Role[]
  organizationRoles OrganizationRole[]
  questions         Question[]         @relation("user")
}

/// @@allow('all', auth().id == user.id)
model Session {
  id           String   @id() @default(uuid())
  sessionToken String   @unique()
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

/// @@allow('read', auth().id == this.userId)
/// @@allow('delete', auth().id == this.userId)
/// @@allow('create', name != 'admin')
/// @@allow('update', future().name != 'admin')
model Role {
  id     String @id() @default(uuid())
  name   String
  userId String
  user   User   @relation(fields: [userId], references: [id])
}

/// @@allow('all', auth().roles?[name == 'admin'])
/// @@allow('all', organization.roles?[user == auth() && name == 'owner'])
/// @@allow('create', organization.roles?[user == auth()] && name != 'owner')
/// @@allow('read', organization.roles?[user == auth()])
/// @@allow('delete', auth() == user)
model OrganizationRole {
  id             String       @id() @default(uuid())
  name           String
  dateCreated    DateTime     @default(now())
  dateUpdated    DateTime     @default(now()) @updatedAt()
  userId         String
  user           User         @relation(fields: [userId], references: [id])
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
}

/// @@allow('all', auth().roles?[name == 'admin'])
/// @@allow('all', roles?[user == auth() && name == 'owner'])
/// @@allow('read', roles?[user == auth()])
model Organization {
  id               String             @id() @default(uuid())
  name             String
  pictureUrl       String?            @default("https://i.imgur.com/BgkFiid.jpeg")
  stripeCustomerId String?
  dateCreated      DateTime           @default(now())
  dateUpdated      DateTime           @default(now()) @updatedAt()
  roles            OrganizationRole[]
  questions        Question[]         @relation("organization")
  billings         BillingData[]      @relation("organization")
}

/// @@allow('all', true)
model Question {
  id             String        @id() @default(uuid())
  content        String
  dateAsked      String
  userId         String?
  user           User?         @relation(fields: [userId], references: [id], name: "user")
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], name: "organization")
  answers        Answer[]      @relation("question")
  dateCreated    DateTime      @default(now())
  dateUpdated    DateTime      @default(now()) @updatedAt()
}

/// @@allow('all', true)
model Answer {
  id           String    @id() @default(uuid())
  content      String
  dateAnswered String
  questionId   String?
  question     Question? @relation(fields: [questionId], references: [id], name: "question")
  dateCreated  DateTime  @default(now())
  dateUpdated  DateTime  @default(now()) @updatedAt()
}

/// @@allow('all', true)
model BillingData {
  id             String        @id() @default(uuid())
  numberOfUsers  Float
  billingDate    String
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], name: "organization")
  dateCreated    DateTime      @default(now())
  dateUpdated    DateTime      @default(now()) @updatedAt()
}

/// @@allow('all', true)
model RagVector {
  id        String   @id() @default(uuid())
  key       String
  url       String
  tags      String[] @default([])
  /// @omit
  vectors   Bytes?
  /// @omit
  documents Bytes?
}

================
File: scripts/env.js
================
import * as fs from 'fs'

const templatePath = '.env.template'
const envPath = '.env'

try {
  if (!fs.existsSync(envPath)) {
    fs.copyFileSync(templatePath, envPath)
    console.log('.env file created from .env.template.')
  } else {
    console.log('.env file already exists.')
  }
} catch (error) {
  console.error(`Could not ensure .env: ${error.message}`)
}

================
File: scripts/format.models.js
================
import { exec } from 'child_process'
import fs from 'fs'
import path from 'path'

const __dirname = path.resolve()

const pathFolder = path.resolve(__dirname, 'models')

console.log(`Start models formatting in ${pathFolder}...`)

const formatModel = filePath => {
  return new Promise((resolve, reject) => {
    exec(
      `pnpm zenstack format --schema ${filePath}`,
      (error, stdout, stderr) => {
        if (error) {
          console.error(`Error formatting ${filePath}:`, stderr)
          reject(error)
        } else {
          console.log(`Formatted ${filePath}`)
          resolve(stdout)
        }
      },
    )
  })
}

const files = fs
  .readdirSync(pathFolder)
  .filter(file => file.endsWith('.zmodel'))
const formatPromises = files.map(file =>
  formatModel(path.join(pathFolder, file)),
)

Promise.all(formatPromises)
  .then(() => {
    console.log('All models formatted successfully.')
  })
  .catch(error => {
    console.error('Error formatting some models:', error)
  })

================
File: src/.marblism/api/client/react.ts
================
/* eslint-disable */

import type { AnyRouter } from '@trpc/server';
import type { CreateTRPCReactOptions } from '@trpc/react-query/shared';
import { type CreateTRPCReact, createTRPCReact as _createTRPCReact } from '@trpc/react-query';
import type { DeepOverrideAtPath } from './utils';
import type { ClientType } from '../routers';

export function createTRPCReact<
    TRouter extends AnyRouter,
    TPath extends string | undefined = undefined,
    TSSRContext = unknown,
    TFlags = null
>(opts?: CreateTRPCReactOptions<TRouter>) {
    const r: CreateTRPCReact<TRouter, TSSRContext, TFlags> = _createTRPCReact<TRouter, TSSRContext, TFlags>(opts);
    return r as DeepOverrideAtPath<CreateTRPCReact<TRouter, TSSRContext, TFlags>, ClientType<TRouter>, TPath>;
}

================
File: src/.marblism/api/client/utils.ts
================
/* eslint-disable */

// inspired by: https://stackoverflow.com/questions/70632026/generic-to-recursively-modify-a-given-type-interface-in-typescript

type Primitive = string | Function | number | boolean | Symbol | undefined | null;

/**
 * Recursively merges `T` and `R`. If there's a shared key, use `R`'s field type to overwrite `T`.
 */
export type DeepOverride<T, R> = T extends Primitive
    ? R
    : R extends Primitive
    ? R
    : {
        [K in keyof T]: K extends keyof R ? DeepOverride<T[K], R[K]> : T[K];
    } & {
        [K in Exclude<keyof R, keyof T>]: R[K];
    };

/**
 * Traverse to `Path` (denoted by dot separated string literal type) in `T`, and starting from there,
 * recursively merge with `R`.
 */
export type DeepOverrideAtPath<T, R, Path extends string | undefined = undefined> = Path extends undefined
    ? DeepOverride<T, R>
    : Path extends `${infer P1}.${infer P2}`
    ? P1 extends keyof T
    ? Omit<T, P1> & Record<P1, DeepOverride<T[P1], DeepOverrideAtPath<T[P1], R, P2>>>
    : never
    : Path extends keyof T
    ? Omit<T, Path> & Record<Path, DeepOverride<T[Path], R>>
    : never;

================
File: src/.marblism/api/routers/Account.router.ts
================
/* eslint-disable */
import { type RouterFactory, type ProcBuilder, type BaseConfig, db } from ".";
import * as _Schema from '@zenstackhq/runtime/zod/input';
const $Schema: typeof _Schema = (_Schema as any).default ?? _Schema;
import { checkRead, checkMutate } from '../helper';
import type { Prisma } from '@prisma/client';
import type { UseTRPCMutationOptions, UseTRPCMutationResult, UseTRPCQueryOptions, UseTRPCQueryResult, UseTRPCInfiniteQueryOptions, UseTRPCInfiniteQueryResult } from '@trpc/react-query/shared';
import type { TRPCClientErrorLike } from '@trpc/client';
import type { AnyRouter } from '@trpc/server';

export default function createRouter<Config extends BaseConfig>(router: RouterFactory<Config>, procedure: ProcBuilder<Config>) {
    return router({

        createMany: procedure.input($Schema.AccountInputSchema.createMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).account.createMany(input as any))),

        create: procedure.input($Schema.AccountInputSchema.create).mutation(async ({ ctx, input }) => checkMutate(db(ctx).account.create(input as any))),

        deleteMany: procedure.input($Schema.AccountInputSchema.deleteMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).account.deleteMany(input as any))),

        delete: procedure.input($Schema.AccountInputSchema.delete).mutation(async ({ ctx, input }) => checkMutate(db(ctx).account.delete(input as any))),

        findFirst: procedure.input($Schema.AccountInputSchema.findFirst).query(({ ctx, input }) => checkRead(db(ctx).account.findFirst(input as any))),

        findMany: procedure.input($Schema.AccountInputSchema.findMany).query(({ ctx, input }) => checkRead(db(ctx).account.findMany(input as any))),

        findUnique: procedure.input($Schema.AccountInputSchema.findUnique).query(({ ctx, input }) => checkRead(db(ctx).account.findUnique(input as any))),

        updateMany: procedure.input($Schema.AccountInputSchema.updateMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).account.updateMany(input as any))),

        update: procedure.input($Schema.AccountInputSchema.update).mutation(async ({ ctx, input }) => checkMutate(db(ctx).account.update(input as any))),

    }
    );
}

export interface ClientType<AppRouter extends AnyRouter, Context = AppRouter['_def']['_config']['$types']['ctx']> {
    createMany: {

        useMutation: <T extends Prisma.AccountCreateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.AccountCreateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.AccountCreateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.AccountCreateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    create: {

        useMutation: <T extends Prisma.AccountCreateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.AccountCreateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.AccountGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.AccountGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.AccountCreateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.AccountCreateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.AccountGetPayload<T>, Context>) => Promise<Prisma.AccountGetPayload<T>>
            };

    };
    deleteMany: {

        useMutation: <T extends Prisma.AccountDeleteManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.AccountDeleteManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.AccountDeleteManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.AccountDeleteManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    delete: {

        useMutation: <T extends Prisma.AccountDeleteArgs>(opts?: UseTRPCMutationOptions<
            Prisma.AccountDeleteArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.AccountGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.AccountGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.AccountDeleteArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.AccountDeleteArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.AccountGetPayload<T>, Context>) => Promise<Prisma.AccountGetPayload<T>>
            };

    };
    findFirst: {

        useQuery: <T extends Prisma.AccountFindFirstArgs, TData = Prisma.AccountGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.AccountFindFirstArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.AccountGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.AccountFindFirstArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.AccountFindFirstArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.AccountGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.AccountGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findMany: {

        useQuery: <T extends Prisma.AccountFindManyArgs, TData = Array<Prisma.AccountGetPayload<T>>>(
            input: Prisma.SelectSubset<T, Prisma.AccountFindManyArgs>,
            opts?: UseTRPCQueryOptions<string, T, Array<Prisma.AccountGetPayload<T>>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.AccountFindManyArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.AccountFindManyArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Array<Prisma.AccountGetPayload<T>>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Array<Prisma.AccountGetPayload<T>>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findUnique: {

        useQuery: <T extends Prisma.AccountFindUniqueArgs, TData = Prisma.AccountGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.AccountFindUniqueArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.AccountGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.AccountFindUniqueArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.AccountFindUniqueArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.AccountGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.AccountGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    updateMany: {

        useMutation: <T extends Prisma.AccountUpdateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.AccountUpdateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.AccountUpdateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.AccountUpdateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    update: {

        useMutation: <T extends Prisma.AccountUpdateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.AccountUpdateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.AccountGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.AccountGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.AccountUpdateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.AccountUpdateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.AccountGetPayload<T>, Context>) => Promise<Prisma.AccountGetPayload<T>>
            };

    };
}

================
File: src/.marblism/api/routers/Answer.router.ts
================
/* eslint-disable */
import { type RouterFactory, type ProcBuilder, type BaseConfig, db } from ".";
import * as _Schema from '@zenstackhq/runtime/zod/input';
const $Schema: typeof _Schema = (_Schema as any).default ?? _Schema;
import { checkRead, checkMutate } from '../helper';
import type { Prisma } from '@prisma/client';
import type { UseTRPCMutationOptions, UseTRPCMutationResult, UseTRPCQueryOptions, UseTRPCQueryResult, UseTRPCInfiniteQueryOptions, UseTRPCInfiniteQueryResult } from '@trpc/react-query/shared';
import type { TRPCClientErrorLike } from '@trpc/client';
import type { AnyRouter } from '@trpc/server';

export default function createRouter<Config extends BaseConfig>(router: RouterFactory<Config>, procedure: ProcBuilder<Config>) {
    return router({

        createMany: procedure.input($Schema.AnswerInputSchema.createMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).answer.createMany(input as any))),

        create: procedure.input($Schema.AnswerInputSchema.create).mutation(async ({ ctx, input }) => checkMutate(db(ctx).answer.create(input as any))),

        deleteMany: procedure.input($Schema.AnswerInputSchema.deleteMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).answer.deleteMany(input as any))),

        delete: procedure.input($Schema.AnswerInputSchema.delete).mutation(async ({ ctx, input }) => checkMutate(db(ctx).answer.delete(input as any))),

        findFirst: procedure.input($Schema.AnswerInputSchema.findFirst).query(({ ctx, input }) => checkRead(db(ctx).answer.findFirst(input as any))),

        findMany: procedure.input($Schema.AnswerInputSchema.findMany).query(({ ctx, input }) => checkRead(db(ctx).answer.findMany(input as any))),

        findUnique: procedure.input($Schema.AnswerInputSchema.findUnique).query(({ ctx, input }) => checkRead(db(ctx).answer.findUnique(input as any))),

        updateMany: procedure.input($Schema.AnswerInputSchema.updateMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).answer.updateMany(input as any))),

        update: procedure.input($Schema.AnswerInputSchema.update).mutation(async ({ ctx, input }) => checkMutate(db(ctx).answer.update(input as any))),

    }
    );
}

export interface ClientType<AppRouter extends AnyRouter, Context = AppRouter['_def']['_config']['$types']['ctx']> {
    createMany: {

        useMutation: <T extends Prisma.AnswerCreateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.AnswerCreateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.AnswerCreateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.AnswerCreateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    create: {

        useMutation: <T extends Prisma.AnswerCreateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.AnswerCreateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.AnswerGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.AnswerGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.AnswerCreateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.AnswerCreateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.AnswerGetPayload<T>, Context>) => Promise<Prisma.AnswerGetPayload<T>>
            };

    };
    deleteMany: {

        useMutation: <T extends Prisma.AnswerDeleteManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.AnswerDeleteManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.AnswerDeleteManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.AnswerDeleteManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    delete: {

        useMutation: <T extends Prisma.AnswerDeleteArgs>(opts?: UseTRPCMutationOptions<
            Prisma.AnswerDeleteArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.AnswerGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.AnswerGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.AnswerDeleteArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.AnswerDeleteArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.AnswerGetPayload<T>, Context>) => Promise<Prisma.AnswerGetPayload<T>>
            };

    };
    findFirst: {

        useQuery: <T extends Prisma.AnswerFindFirstArgs, TData = Prisma.AnswerGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.AnswerFindFirstArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.AnswerGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.AnswerFindFirstArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.AnswerFindFirstArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.AnswerGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.AnswerGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findMany: {

        useQuery: <T extends Prisma.AnswerFindManyArgs, TData = Array<Prisma.AnswerGetPayload<T>>>(
            input: Prisma.SelectSubset<T, Prisma.AnswerFindManyArgs>,
            opts?: UseTRPCQueryOptions<string, T, Array<Prisma.AnswerGetPayload<T>>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.AnswerFindManyArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.AnswerFindManyArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Array<Prisma.AnswerGetPayload<T>>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Array<Prisma.AnswerGetPayload<T>>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findUnique: {

        useQuery: <T extends Prisma.AnswerFindUniqueArgs, TData = Prisma.AnswerGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.AnswerFindUniqueArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.AnswerGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.AnswerFindUniqueArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.AnswerFindUniqueArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.AnswerGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.AnswerGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    updateMany: {

        useMutation: <T extends Prisma.AnswerUpdateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.AnswerUpdateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.AnswerUpdateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.AnswerUpdateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    update: {

        useMutation: <T extends Prisma.AnswerUpdateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.AnswerUpdateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.AnswerGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.AnswerGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.AnswerUpdateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.AnswerUpdateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.AnswerGetPayload<T>, Context>) => Promise<Prisma.AnswerGetPayload<T>>
            };

    };
}

================
File: src/.marblism/api/routers/BillingData.router.ts
================
/* eslint-disable */
import { type RouterFactory, type ProcBuilder, type BaseConfig, db } from ".";
import * as _Schema from '@zenstackhq/runtime/zod/input';
const $Schema: typeof _Schema = (_Schema as any).default ?? _Schema;
import { checkRead, checkMutate } from '../helper';
import type { Prisma } from '@prisma/client';
import type { UseTRPCMutationOptions, UseTRPCMutationResult, UseTRPCQueryOptions, UseTRPCQueryResult, UseTRPCInfiniteQueryOptions, UseTRPCInfiniteQueryResult } from '@trpc/react-query/shared';
import type { TRPCClientErrorLike } from '@trpc/client';
import type { AnyRouter } from '@trpc/server';

export default function createRouter<Config extends BaseConfig>(router: RouterFactory<Config>, procedure: ProcBuilder<Config>) {
    return router({

        createMany: procedure.input($Schema.BillingDataInputSchema.createMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).billingData.createMany(input as any))),

        create: procedure.input($Schema.BillingDataInputSchema.create).mutation(async ({ ctx, input }) => checkMutate(db(ctx).billingData.create(input as any))),

        deleteMany: procedure.input($Schema.BillingDataInputSchema.deleteMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).billingData.deleteMany(input as any))),

        delete: procedure.input($Schema.BillingDataInputSchema.delete).mutation(async ({ ctx, input }) => checkMutate(db(ctx).billingData.delete(input as any))),

        findFirst: procedure.input($Schema.BillingDataInputSchema.findFirst).query(({ ctx, input }) => checkRead(db(ctx).billingData.findFirst(input as any))),

        findMany: procedure.input($Schema.BillingDataInputSchema.findMany).query(({ ctx, input }) => checkRead(db(ctx).billingData.findMany(input as any))),

        findUnique: procedure.input($Schema.BillingDataInputSchema.findUnique).query(({ ctx, input }) => checkRead(db(ctx).billingData.findUnique(input as any))),

        updateMany: procedure.input($Schema.BillingDataInputSchema.updateMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).billingData.updateMany(input as any))),

        update: procedure.input($Schema.BillingDataInputSchema.update).mutation(async ({ ctx, input }) => checkMutate(db(ctx).billingData.update(input as any))),

    }
    );
}

export interface ClientType<AppRouter extends AnyRouter, Context = AppRouter['_def']['_config']['$types']['ctx']> {
    createMany: {

        useMutation: <T extends Prisma.BillingDataCreateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.BillingDataCreateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.BillingDataCreateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.BillingDataCreateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    create: {

        useMutation: <T extends Prisma.BillingDataCreateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.BillingDataCreateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BillingDataGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BillingDataGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.BillingDataCreateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.BillingDataCreateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BillingDataGetPayload<T>, Context>) => Promise<Prisma.BillingDataGetPayload<T>>
            };

    };
    deleteMany: {

        useMutation: <T extends Prisma.BillingDataDeleteManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.BillingDataDeleteManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.BillingDataDeleteManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.BillingDataDeleteManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    delete: {

        useMutation: <T extends Prisma.BillingDataDeleteArgs>(opts?: UseTRPCMutationOptions<
            Prisma.BillingDataDeleteArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BillingDataGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BillingDataGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.BillingDataDeleteArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.BillingDataDeleteArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BillingDataGetPayload<T>, Context>) => Promise<Prisma.BillingDataGetPayload<T>>
            };

    };
    findFirst: {

        useQuery: <T extends Prisma.BillingDataFindFirstArgs, TData = Prisma.BillingDataGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.BillingDataFindFirstArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.BillingDataGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.BillingDataFindFirstArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.BillingDataFindFirstArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.BillingDataGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.BillingDataGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findMany: {

        useQuery: <T extends Prisma.BillingDataFindManyArgs, TData = Array<Prisma.BillingDataGetPayload<T>>>(
            input: Prisma.SelectSubset<T, Prisma.BillingDataFindManyArgs>,
            opts?: UseTRPCQueryOptions<string, T, Array<Prisma.BillingDataGetPayload<T>>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.BillingDataFindManyArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.BillingDataFindManyArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Array<Prisma.BillingDataGetPayload<T>>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Array<Prisma.BillingDataGetPayload<T>>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findUnique: {

        useQuery: <T extends Prisma.BillingDataFindUniqueArgs, TData = Prisma.BillingDataGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.BillingDataFindUniqueArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.BillingDataGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.BillingDataFindUniqueArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.BillingDataFindUniqueArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.BillingDataGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.BillingDataGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    updateMany: {

        useMutation: <T extends Prisma.BillingDataUpdateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.BillingDataUpdateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.BillingDataUpdateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.BillingDataUpdateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    update: {

        useMutation: <T extends Prisma.BillingDataUpdateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.BillingDataUpdateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BillingDataGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BillingDataGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.BillingDataUpdateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.BillingDataUpdateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BillingDataGetPayload<T>, Context>) => Promise<Prisma.BillingDataGetPayload<T>>
            };

    };
}

================
File: src/.marblism/api/routers/index.ts
================
/* eslint-disable */
import type { unsetMarker, AnyRouter, AnyRootConfig, CreateRouterInner, Procedure, ProcedureBuilder, ProcedureParams, ProcedureRouterRecord, ProcedureType } from "@trpc/server";
import type { PrismaClient } from "@prisma/client";
import createAccountRouter from "./Account.router";
import createUserRouter from "./User.router";
import createSessionRouter from "./Session.router";
import createRoleRouter from "./Role.router";
import createOrganizationRoleRouter from "./OrganizationRole.router";
import createOrganizationRouter from "./Organization.router";
import createQuestionRouter from "./Question.router";
import createAnswerRouter from "./Answer.router";
import createBillingDataRouter from "./BillingData.router";
import createRagVectorRouter from "./RagVector.router";
import { ClientType as AccountClientType } from "./Account.router";
import { ClientType as UserClientType } from "./User.router";
import { ClientType as SessionClientType } from "./Session.router";
import { ClientType as RoleClientType } from "./Role.router";
import { ClientType as OrganizationRoleClientType } from "./OrganizationRole.router";
import { ClientType as OrganizationClientType } from "./Organization.router";
import { ClientType as QuestionClientType } from "./Question.router";
import { ClientType as AnswerClientType } from "./Answer.router";
import { ClientType as BillingDataClientType } from "./BillingData.router";
import { ClientType as RagVectorClientType } from "./RagVector.router";

export type BaseConfig = AnyRootConfig;

export type RouterFactory<Config extends BaseConfig> = <
    ProcRouterRecord extends ProcedureRouterRecord
>(
    procedures: ProcRouterRecord
) => CreateRouterInner<Config, ProcRouterRecord>;

export type UnsetMarker = typeof unsetMarker;

export type ProcBuilder<Config extends BaseConfig> = ProcedureBuilder<
    ProcedureParams<Config, any, any, any, UnsetMarker, UnsetMarker, any>
>;

export function db(ctx: any) {
    if (!ctx.prisma) {
        throw new Error('Missing "prisma" field in trpc context');
    }
    return ctx.prisma as PrismaClient;
}

export function createRouter<Config extends BaseConfig>(router: RouterFactory<Config>, procedure: ProcBuilder<Config>) {
    return router({
        account: createAccountRouter(router, procedure),
        user: createUserRouter(router, procedure),
        session: createSessionRouter(router, procedure),
        role: createRoleRouter(router, procedure),
        organizationRole: createOrganizationRoleRouter(router, procedure),
        organization: createOrganizationRouter(router, procedure),
        question: createQuestionRouter(router, procedure),
        answer: createAnswerRouter(router, procedure),
        billingData: createBillingDataRouter(router, procedure),
        ragVector: createRagVectorRouter(router, procedure),
    }
    );
}

export interface ClientType<AppRouter extends AnyRouter> {
    account: AccountClientType<AppRouter>;
    user: UserClientType<AppRouter>;
    session: SessionClientType<AppRouter>;
    role: RoleClientType<AppRouter>;
    organizationRole: OrganizationRoleClientType<AppRouter>;
    organization: OrganizationClientType<AppRouter>;
    question: QuestionClientType<AppRouter>;
    answer: AnswerClientType<AppRouter>;
    billingData: BillingDataClientType<AppRouter>;
    ragVector: RagVectorClientType<AppRouter>;
}

================
File: src/.marblism/api/routers/Organization.router.ts
================
/* eslint-disable */
import { type RouterFactory, type ProcBuilder, type BaseConfig, db } from ".";
import * as _Schema from '@zenstackhq/runtime/zod/input';
const $Schema: typeof _Schema = (_Schema as any).default ?? _Schema;
import { checkRead, checkMutate } from '../helper';
import type { Prisma } from '@prisma/client';
import type { UseTRPCMutationOptions, UseTRPCMutationResult, UseTRPCQueryOptions, UseTRPCQueryResult, UseTRPCInfiniteQueryOptions, UseTRPCInfiniteQueryResult } from '@trpc/react-query/shared';
import type { TRPCClientErrorLike } from '@trpc/client';
import type { AnyRouter } from '@trpc/server';

export default function createRouter<Config extends BaseConfig>(router: RouterFactory<Config>, procedure: ProcBuilder<Config>) {
    return router({

        createMany: procedure.input($Schema.OrganizationInputSchema.createMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).organization.createMany(input as any))),

        create: procedure.input($Schema.OrganizationInputSchema.create).mutation(async ({ ctx, input }) => checkMutate(db(ctx).organization.create(input as any))),

        deleteMany: procedure.input($Schema.OrganizationInputSchema.deleteMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).organization.deleteMany(input as any))),

        delete: procedure.input($Schema.OrganizationInputSchema.delete).mutation(async ({ ctx, input }) => checkMutate(db(ctx).organization.delete(input as any))),

        findFirst: procedure.input($Schema.OrganizationInputSchema.findFirst).query(({ ctx, input }) => checkRead(db(ctx).organization.findFirst(input as any))),

        findMany: procedure.input($Schema.OrganizationInputSchema.findMany).query(({ ctx, input }) => checkRead(db(ctx).organization.findMany(input as any))),

        findUnique: procedure.input($Schema.OrganizationInputSchema.findUnique).query(({ ctx, input }) => checkRead(db(ctx).organization.findUnique(input as any))),

        updateMany: procedure.input($Schema.OrganizationInputSchema.updateMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).organization.updateMany(input as any))),

        update: procedure.input($Schema.OrganizationInputSchema.update).mutation(async ({ ctx, input }) => checkMutate(db(ctx).organization.update(input as any))),

    }
    );
}

export interface ClientType<AppRouter extends AnyRouter, Context = AppRouter['_def']['_config']['$types']['ctx']> {
    createMany: {

        useMutation: <T extends Prisma.OrganizationCreateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.OrganizationCreateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.OrganizationCreateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.OrganizationCreateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    create: {

        useMutation: <T extends Prisma.OrganizationCreateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.OrganizationCreateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.OrganizationGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.OrganizationGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.OrganizationCreateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.OrganizationCreateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.OrganizationGetPayload<T>, Context>) => Promise<Prisma.OrganizationGetPayload<T>>
            };

    };
    deleteMany: {

        useMutation: <T extends Prisma.OrganizationDeleteManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.OrganizationDeleteManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.OrganizationDeleteManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.OrganizationDeleteManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    delete: {

        useMutation: <T extends Prisma.OrganizationDeleteArgs>(opts?: UseTRPCMutationOptions<
            Prisma.OrganizationDeleteArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.OrganizationGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.OrganizationGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.OrganizationDeleteArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.OrganizationDeleteArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.OrganizationGetPayload<T>, Context>) => Promise<Prisma.OrganizationGetPayload<T>>
            };

    };
    findFirst: {

        useQuery: <T extends Prisma.OrganizationFindFirstArgs, TData = Prisma.OrganizationGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.OrganizationFindFirstArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.OrganizationGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.OrganizationFindFirstArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.OrganizationFindFirstArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.OrganizationGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.OrganizationGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findMany: {

        useQuery: <T extends Prisma.OrganizationFindManyArgs, TData = Array<Prisma.OrganizationGetPayload<T>>>(
            input: Prisma.SelectSubset<T, Prisma.OrganizationFindManyArgs>,
            opts?: UseTRPCQueryOptions<string, T, Array<Prisma.OrganizationGetPayload<T>>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.OrganizationFindManyArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.OrganizationFindManyArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Array<Prisma.OrganizationGetPayload<T>>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Array<Prisma.OrganizationGetPayload<T>>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findUnique: {

        useQuery: <T extends Prisma.OrganizationFindUniqueArgs, TData = Prisma.OrganizationGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.OrganizationFindUniqueArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.OrganizationGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.OrganizationFindUniqueArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.OrganizationFindUniqueArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.OrganizationGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.OrganizationGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    updateMany: {

        useMutation: <T extends Prisma.OrganizationUpdateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.OrganizationUpdateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.OrganizationUpdateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.OrganizationUpdateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    update: {

        useMutation: <T extends Prisma.OrganizationUpdateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.OrganizationUpdateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.OrganizationGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.OrganizationGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.OrganizationUpdateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.OrganizationUpdateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.OrganizationGetPayload<T>, Context>) => Promise<Prisma.OrganizationGetPayload<T>>
            };

    };
}

================
File: src/.marblism/api/routers/OrganizationRole.router.ts
================
/* eslint-disable */
import { type RouterFactory, type ProcBuilder, type BaseConfig, db } from ".";
import * as _Schema from '@zenstackhq/runtime/zod/input';
const $Schema: typeof _Schema = (_Schema as any).default ?? _Schema;
import { checkRead, checkMutate } from '../helper';
import type { Prisma } from '@prisma/client';
import type { UseTRPCMutationOptions, UseTRPCMutationResult, UseTRPCQueryOptions, UseTRPCQueryResult, UseTRPCInfiniteQueryOptions, UseTRPCInfiniteQueryResult } from '@trpc/react-query/shared';
import type { TRPCClientErrorLike } from '@trpc/client';
import type { AnyRouter } from '@trpc/server';

export default function createRouter<Config extends BaseConfig>(router: RouterFactory<Config>, procedure: ProcBuilder<Config>) {
    return router({

        createMany: procedure.input($Schema.OrganizationRoleInputSchema.createMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).organizationRole.createMany(input as any))),

        create: procedure.input($Schema.OrganizationRoleInputSchema.create).mutation(async ({ ctx, input }) => checkMutate(db(ctx).organizationRole.create(input as any))),

        deleteMany: procedure.input($Schema.OrganizationRoleInputSchema.deleteMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).organizationRole.deleteMany(input as any))),

        delete: procedure.input($Schema.OrganizationRoleInputSchema.delete).mutation(async ({ ctx, input }) => checkMutate(db(ctx).organizationRole.delete(input as any))),

        findFirst: procedure.input($Schema.OrganizationRoleInputSchema.findFirst).query(({ ctx, input }) => checkRead(db(ctx).organizationRole.findFirst(input as any))),

        findMany: procedure.input($Schema.OrganizationRoleInputSchema.findMany).query(({ ctx, input }) => checkRead(db(ctx).organizationRole.findMany(input as any))),

        findUnique: procedure.input($Schema.OrganizationRoleInputSchema.findUnique).query(({ ctx, input }) => checkRead(db(ctx).organizationRole.findUnique(input as any))),

        updateMany: procedure.input($Schema.OrganizationRoleInputSchema.updateMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).organizationRole.updateMany(input as any))),

        update: procedure.input($Schema.OrganizationRoleInputSchema.update).mutation(async ({ ctx, input }) => checkMutate(db(ctx).organizationRole.update(input as any))),

    }
    );
}

export interface ClientType<AppRouter extends AnyRouter, Context = AppRouter['_def']['_config']['$types']['ctx']> {
    createMany: {

        useMutation: <T extends Prisma.OrganizationRoleCreateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.OrganizationRoleCreateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.OrganizationRoleCreateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.OrganizationRoleCreateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    create: {

        useMutation: <T extends Prisma.OrganizationRoleCreateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.OrganizationRoleCreateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.OrganizationRoleGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.OrganizationRoleGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.OrganizationRoleCreateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.OrganizationRoleCreateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.OrganizationRoleGetPayload<T>, Context>) => Promise<Prisma.OrganizationRoleGetPayload<T>>
            };

    };
    deleteMany: {

        useMutation: <T extends Prisma.OrganizationRoleDeleteManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.OrganizationRoleDeleteManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.OrganizationRoleDeleteManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.OrganizationRoleDeleteManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    delete: {

        useMutation: <T extends Prisma.OrganizationRoleDeleteArgs>(opts?: UseTRPCMutationOptions<
            Prisma.OrganizationRoleDeleteArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.OrganizationRoleGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.OrganizationRoleGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.OrganizationRoleDeleteArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.OrganizationRoleDeleteArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.OrganizationRoleGetPayload<T>, Context>) => Promise<Prisma.OrganizationRoleGetPayload<T>>
            };

    };
    findFirst: {

        useQuery: <T extends Prisma.OrganizationRoleFindFirstArgs, TData = Prisma.OrganizationRoleGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.OrganizationRoleFindFirstArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.OrganizationRoleGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.OrganizationRoleFindFirstArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.OrganizationRoleFindFirstArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.OrganizationRoleGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.OrganizationRoleGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findMany: {

        useQuery: <T extends Prisma.OrganizationRoleFindManyArgs, TData = Array<Prisma.OrganizationRoleGetPayload<T>>>(
            input: Prisma.SelectSubset<T, Prisma.OrganizationRoleFindManyArgs>,
            opts?: UseTRPCQueryOptions<string, T, Array<Prisma.OrganizationRoleGetPayload<T>>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.OrganizationRoleFindManyArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.OrganizationRoleFindManyArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Array<Prisma.OrganizationRoleGetPayload<T>>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Array<Prisma.OrganizationRoleGetPayload<T>>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findUnique: {

        useQuery: <T extends Prisma.OrganizationRoleFindUniqueArgs, TData = Prisma.OrganizationRoleGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.OrganizationRoleFindUniqueArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.OrganizationRoleGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.OrganizationRoleFindUniqueArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.OrganizationRoleFindUniqueArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.OrganizationRoleGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.OrganizationRoleGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    updateMany: {

        useMutation: <T extends Prisma.OrganizationRoleUpdateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.OrganizationRoleUpdateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.OrganizationRoleUpdateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.OrganizationRoleUpdateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    update: {

        useMutation: <T extends Prisma.OrganizationRoleUpdateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.OrganizationRoleUpdateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.OrganizationRoleGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.OrganizationRoleGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.OrganizationRoleUpdateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.OrganizationRoleUpdateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.OrganizationRoleGetPayload<T>, Context>) => Promise<Prisma.OrganizationRoleGetPayload<T>>
            };

    };
}

================
File: src/.marblism/api/routers/Question.router.ts
================
/* eslint-disable */
import { type RouterFactory, type ProcBuilder, type BaseConfig, db } from ".";
import * as _Schema from '@zenstackhq/runtime/zod/input';
const $Schema: typeof _Schema = (_Schema as any).default ?? _Schema;
import { checkRead, checkMutate } from '../helper';
import type { Prisma } from '@prisma/client';
import type { UseTRPCMutationOptions, UseTRPCMutationResult, UseTRPCQueryOptions, UseTRPCQueryResult, UseTRPCInfiniteQueryOptions, UseTRPCInfiniteQueryResult } from '@trpc/react-query/shared';
import type { TRPCClientErrorLike } from '@trpc/client';
import type { AnyRouter } from '@trpc/server';

export default function createRouter<Config extends BaseConfig>(router: RouterFactory<Config>, procedure: ProcBuilder<Config>) {
    return router({

        createMany: procedure.input($Schema.QuestionInputSchema.createMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).question.createMany(input as any))),

        create: procedure.input($Schema.QuestionInputSchema.create).mutation(async ({ ctx, input }) => checkMutate(db(ctx).question.create(input as any))),

        deleteMany: procedure.input($Schema.QuestionInputSchema.deleteMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).question.deleteMany(input as any))),

        delete: procedure.input($Schema.QuestionInputSchema.delete).mutation(async ({ ctx, input }) => checkMutate(db(ctx).question.delete(input as any))),

        findFirst: procedure.input($Schema.QuestionInputSchema.findFirst).query(({ ctx, input }) => checkRead(db(ctx).question.findFirst(input as any))),

        findMany: procedure.input($Schema.QuestionInputSchema.findMany).query(({ ctx, input }) => checkRead(db(ctx).question.findMany(input as any))),

        findUnique: procedure.input($Schema.QuestionInputSchema.findUnique).query(({ ctx, input }) => checkRead(db(ctx).question.findUnique(input as any))),

        updateMany: procedure.input($Schema.QuestionInputSchema.updateMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).question.updateMany(input as any))),

        update: procedure.input($Schema.QuestionInputSchema.update).mutation(async ({ ctx, input }) => checkMutate(db(ctx).question.update(input as any))),

    }
    );
}

export interface ClientType<AppRouter extends AnyRouter, Context = AppRouter['_def']['_config']['$types']['ctx']> {
    createMany: {

        useMutation: <T extends Prisma.QuestionCreateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.QuestionCreateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.QuestionCreateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.QuestionCreateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    create: {

        useMutation: <T extends Prisma.QuestionCreateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.QuestionCreateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.QuestionGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.QuestionGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.QuestionCreateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.QuestionCreateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.QuestionGetPayload<T>, Context>) => Promise<Prisma.QuestionGetPayload<T>>
            };

    };
    deleteMany: {

        useMutation: <T extends Prisma.QuestionDeleteManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.QuestionDeleteManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.QuestionDeleteManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.QuestionDeleteManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    delete: {

        useMutation: <T extends Prisma.QuestionDeleteArgs>(opts?: UseTRPCMutationOptions<
            Prisma.QuestionDeleteArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.QuestionGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.QuestionGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.QuestionDeleteArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.QuestionDeleteArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.QuestionGetPayload<T>, Context>) => Promise<Prisma.QuestionGetPayload<T>>
            };

    };
    findFirst: {

        useQuery: <T extends Prisma.QuestionFindFirstArgs, TData = Prisma.QuestionGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.QuestionFindFirstArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.QuestionGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.QuestionFindFirstArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.QuestionFindFirstArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.QuestionGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.QuestionGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findMany: {

        useQuery: <T extends Prisma.QuestionFindManyArgs, TData = Array<Prisma.QuestionGetPayload<T>>>(
            input: Prisma.SelectSubset<T, Prisma.QuestionFindManyArgs>,
            opts?: UseTRPCQueryOptions<string, T, Array<Prisma.QuestionGetPayload<T>>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.QuestionFindManyArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.QuestionFindManyArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Array<Prisma.QuestionGetPayload<T>>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Array<Prisma.QuestionGetPayload<T>>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findUnique: {

        useQuery: <T extends Prisma.QuestionFindUniqueArgs, TData = Prisma.QuestionGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.QuestionFindUniqueArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.QuestionGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.QuestionFindUniqueArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.QuestionFindUniqueArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.QuestionGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.QuestionGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    updateMany: {

        useMutation: <T extends Prisma.QuestionUpdateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.QuestionUpdateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.QuestionUpdateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.QuestionUpdateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    update: {

        useMutation: <T extends Prisma.QuestionUpdateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.QuestionUpdateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.QuestionGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.QuestionGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.QuestionUpdateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.QuestionUpdateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.QuestionGetPayload<T>, Context>) => Promise<Prisma.QuestionGetPayload<T>>
            };

    };
}

================
File: src/.marblism/api/routers/RagVector.router.ts
================
/* eslint-disable */
import { type RouterFactory, type ProcBuilder, type BaseConfig, db } from ".";
import * as _Schema from '@zenstackhq/runtime/zod/input';
const $Schema: typeof _Schema = (_Schema as any).default ?? _Schema;
import { checkRead, checkMutate } from '../helper';
import type { Prisma } from '@prisma/client';
import type { UseTRPCMutationOptions, UseTRPCMutationResult, UseTRPCQueryOptions, UseTRPCQueryResult, UseTRPCInfiniteQueryOptions, UseTRPCInfiniteQueryResult } from '@trpc/react-query/shared';
import type { TRPCClientErrorLike } from '@trpc/client';
import type { AnyRouter } from '@trpc/server';

export default function createRouter<Config extends BaseConfig>(router: RouterFactory<Config>, procedure: ProcBuilder<Config>) {
    return router({

        createMany: procedure.input($Schema.RagVectorInputSchema.createMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).ragVector.createMany(input as any))),

        create: procedure.input($Schema.RagVectorInputSchema.create).mutation(async ({ ctx, input }) => checkMutate(db(ctx).ragVector.create(input as any))),

        deleteMany: procedure.input($Schema.RagVectorInputSchema.deleteMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).ragVector.deleteMany(input as any))),

        delete: procedure.input($Schema.RagVectorInputSchema.delete).mutation(async ({ ctx, input }) => checkMutate(db(ctx).ragVector.delete(input as any))),

        findFirst: procedure.input($Schema.RagVectorInputSchema.findFirst).query(({ ctx, input }) => checkRead(db(ctx).ragVector.findFirst(input as any))),

        findMany: procedure.input($Schema.RagVectorInputSchema.findMany).query(({ ctx, input }) => checkRead(db(ctx).ragVector.findMany(input as any))),

        findUnique: procedure.input($Schema.RagVectorInputSchema.findUnique).query(({ ctx, input }) => checkRead(db(ctx).ragVector.findUnique(input as any))),

        updateMany: procedure.input($Schema.RagVectorInputSchema.updateMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).ragVector.updateMany(input as any))),

        update: procedure.input($Schema.RagVectorInputSchema.update).mutation(async ({ ctx, input }) => checkMutate(db(ctx).ragVector.update(input as any))),

    }
    );
}

export interface ClientType<AppRouter extends AnyRouter, Context = AppRouter['_def']['_config']['$types']['ctx']> {
    createMany: {

        useMutation: <T extends Prisma.RagVectorCreateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.RagVectorCreateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.RagVectorCreateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.RagVectorCreateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    create: {

        useMutation: <T extends Prisma.RagVectorCreateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.RagVectorCreateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.RagVectorGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.RagVectorGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.RagVectorCreateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.RagVectorCreateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.RagVectorGetPayload<T>, Context>) => Promise<Prisma.RagVectorGetPayload<T>>
            };

    };
    deleteMany: {

        useMutation: <T extends Prisma.RagVectorDeleteManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.RagVectorDeleteManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.RagVectorDeleteManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.RagVectorDeleteManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    delete: {

        useMutation: <T extends Prisma.RagVectorDeleteArgs>(opts?: UseTRPCMutationOptions<
            Prisma.RagVectorDeleteArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.RagVectorGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.RagVectorGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.RagVectorDeleteArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.RagVectorDeleteArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.RagVectorGetPayload<T>, Context>) => Promise<Prisma.RagVectorGetPayload<T>>
            };

    };
    findFirst: {

        useQuery: <T extends Prisma.RagVectorFindFirstArgs, TData = Prisma.RagVectorGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.RagVectorFindFirstArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.RagVectorGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.RagVectorFindFirstArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.RagVectorFindFirstArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.RagVectorGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.RagVectorGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findMany: {

        useQuery: <T extends Prisma.RagVectorFindManyArgs, TData = Array<Prisma.RagVectorGetPayload<T>>>(
            input: Prisma.SelectSubset<T, Prisma.RagVectorFindManyArgs>,
            opts?: UseTRPCQueryOptions<string, T, Array<Prisma.RagVectorGetPayload<T>>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.RagVectorFindManyArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.RagVectorFindManyArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Array<Prisma.RagVectorGetPayload<T>>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Array<Prisma.RagVectorGetPayload<T>>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findUnique: {

        useQuery: <T extends Prisma.RagVectorFindUniqueArgs, TData = Prisma.RagVectorGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.RagVectorFindUniqueArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.RagVectorGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.RagVectorFindUniqueArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.RagVectorFindUniqueArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.RagVectorGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.RagVectorGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    updateMany: {

        useMutation: <T extends Prisma.RagVectorUpdateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.RagVectorUpdateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.RagVectorUpdateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.RagVectorUpdateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    update: {

        useMutation: <T extends Prisma.RagVectorUpdateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.RagVectorUpdateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.RagVectorGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.RagVectorGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.RagVectorUpdateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.RagVectorUpdateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.RagVectorGetPayload<T>, Context>) => Promise<Prisma.RagVectorGetPayload<T>>
            };

    };
}

================
File: src/.marblism/api/routers/Role.router.ts
================
/* eslint-disable */
import { type RouterFactory, type ProcBuilder, type BaseConfig, db } from ".";
import * as _Schema from '@zenstackhq/runtime/zod/input';
const $Schema: typeof _Schema = (_Schema as any).default ?? _Schema;
import { checkRead, checkMutate } from '../helper';
import type { Prisma } from '@prisma/client';
import type { UseTRPCMutationOptions, UseTRPCMutationResult, UseTRPCQueryOptions, UseTRPCQueryResult, UseTRPCInfiniteQueryOptions, UseTRPCInfiniteQueryResult } from '@trpc/react-query/shared';
import type { TRPCClientErrorLike } from '@trpc/client';
import type { AnyRouter } from '@trpc/server';

export default function createRouter<Config extends BaseConfig>(router: RouterFactory<Config>, procedure: ProcBuilder<Config>) {
    return router({

        createMany: procedure.input($Schema.RoleInputSchema.createMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).role.createMany(input as any))),

        create: procedure.input($Schema.RoleInputSchema.create).mutation(async ({ ctx, input }) => checkMutate(db(ctx).role.create(input as any))),

        deleteMany: procedure.input($Schema.RoleInputSchema.deleteMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).role.deleteMany(input as any))),

        delete: procedure.input($Schema.RoleInputSchema.delete).mutation(async ({ ctx, input }) => checkMutate(db(ctx).role.delete(input as any))),

        findFirst: procedure.input($Schema.RoleInputSchema.findFirst).query(({ ctx, input }) => checkRead(db(ctx).role.findFirst(input as any))),

        findMany: procedure.input($Schema.RoleInputSchema.findMany).query(({ ctx, input }) => checkRead(db(ctx).role.findMany(input as any))),

        findUnique: procedure.input($Schema.RoleInputSchema.findUnique).query(({ ctx, input }) => checkRead(db(ctx).role.findUnique(input as any))),

        updateMany: procedure.input($Schema.RoleInputSchema.updateMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).role.updateMany(input as any))),

        update: procedure.input($Schema.RoleInputSchema.update).mutation(async ({ ctx, input }) => checkMutate(db(ctx).role.update(input as any))),

    }
    );
}

export interface ClientType<AppRouter extends AnyRouter, Context = AppRouter['_def']['_config']['$types']['ctx']> {
    createMany: {

        useMutation: <T extends Prisma.RoleCreateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.RoleCreateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.RoleCreateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.RoleCreateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    create: {

        useMutation: <T extends Prisma.RoleCreateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.RoleCreateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.RoleGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.RoleGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.RoleCreateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.RoleCreateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.RoleGetPayload<T>, Context>) => Promise<Prisma.RoleGetPayload<T>>
            };

    };
    deleteMany: {

        useMutation: <T extends Prisma.RoleDeleteManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.RoleDeleteManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.RoleDeleteManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.RoleDeleteManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    delete: {

        useMutation: <T extends Prisma.RoleDeleteArgs>(opts?: UseTRPCMutationOptions<
            Prisma.RoleDeleteArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.RoleGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.RoleGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.RoleDeleteArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.RoleDeleteArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.RoleGetPayload<T>, Context>) => Promise<Prisma.RoleGetPayload<T>>
            };

    };
    findFirst: {

        useQuery: <T extends Prisma.RoleFindFirstArgs, TData = Prisma.RoleGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.RoleFindFirstArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.RoleGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.RoleFindFirstArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.RoleFindFirstArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.RoleGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.RoleGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findMany: {

        useQuery: <T extends Prisma.RoleFindManyArgs, TData = Array<Prisma.RoleGetPayload<T>>>(
            input: Prisma.SelectSubset<T, Prisma.RoleFindManyArgs>,
            opts?: UseTRPCQueryOptions<string, T, Array<Prisma.RoleGetPayload<T>>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.RoleFindManyArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.RoleFindManyArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Array<Prisma.RoleGetPayload<T>>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Array<Prisma.RoleGetPayload<T>>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findUnique: {

        useQuery: <T extends Prisma.RoleFindUniqueArgs, TData = Prisma.RoleGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.RoleFindUniqueArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.RoleGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.RoleFindUniqueArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.RoleFindUniqueArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.RoleGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.RoleGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    updateMany: {

        useMutation: <T extends Prisma.RoleUpdateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.RoleUpdateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.RoleUpdateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.RoleUpdateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    update: {

        useMutation: <T extends Prisma.RoleUpdateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.RoleUpdateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.RoleGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.RoleGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.RoleUpdateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.RoleUpdateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.RoleGetPayload<T>, Context>) => Promise<Prisma.RoleGetPayload<T>>
            };

    };
}

================
File: src/.marblism/api/routers/Session.router.ts
================
/* eslint-disable */
import { type RouterFactory, type ProcBuilder, type BaseConfig, db } from ".";
import * as _Schema from '@zenstackhq/runtime/zod/input';
const $Schema: typeof _Schema = (_Schema as any).default ?? _Schema;
import { checkRead, checkMutate } from '../helper';
import type { Prisma } from '@prisma/client';
import type { UseTRPCMutationOptions, UseTRPCMutationResult, UseTRPCQueryOptions, UseTRPCQueryResult, UseTRPCInfiniteQueryOptions, UseTRPCInfiniteQueryResult } from '@trpc/react-query/shared';
import type { TRPCClientErrorLike } from '@trpc/client';
import type { AnyRouter } from '@trpc/server';

export default function createRouter<Config extends BaseConfig>(router: RouterFactory<Config>, procedure: ProcBuilder<Config>) {
    return router({

        createMany: procedure.input($Schema.SessionInputSchema.createMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).session.createMany(input as any))),

        create: procedure.input($Schema.SessionInputSchema.create).mutation(async ({ ctx, input }) => checkMutate(db(ctx).session.create(input as any))),

        deleteMany: procedure.input($Schema.SessionInputSchema.deleteMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).session.deleteMany(input as any))),

        delete: procedure.input($Schema.SessionInputSchema.delete).mutation(async ({ ctx, input }) => checkMutate(db(ctx).session.delete(input as any))),

        findFirst: procedure.input($Schema.SessionInputSchema.findFirst).query(({ ctx, input }) => checkRead(db(ctx).session.findFirst(input as any))),

        findMany: procedure.input($Schema.SessionInputSchema.findMany).query(({ ctx, input }) => checkRead(db(ctx).session.findMany(input as any))),

        findUnique: procedure.input($Schema.SessionInputSchema.findUnique).query(({ ctx, input }) => checkRead(db(ctx).session.findUnique(input as any))),

        updateMany: procedure.input($Schema.SessionInputSchema.updateMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).session.updateMany(input as any))),

        update: procedure.input($Schema.SessionInputSchema.update).mutation(async ({ ctx, input }) => checkMutate(db(ctx).session.update(input as any))),

    }
    );
}

export interface ClientType<AppRouter extends AnyRouter, Context = AppRouter['_def']['_config']['$types']['ctx']> {
    createMany: {

        useMutation: <T extends Prisma.SessionCreateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.SessionCreateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.SessionCreateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.SessionCreateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    create: {

        useMutation: <T extends Prisma.SessionCreateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.SessionCreateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.SessionGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.SessionGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.SessionCreateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.SessionCreateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.SessionGetPayload<T>, Context>) => Promise<Prisma.SessionGetPayload<T>>
            };

    };
    deleteMany: {

        useMutation: <T extends Prisma.SessionDeleteManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.SessionDeleteManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.SessionDeleteManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.SessionDeleteManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    delete: {

        useMutation: <T extends Prisma.SessionDeleteArgs>(opts?: UseTRPCMutationOptions<
            Prisma.SessionDeleteArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.SessionGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.SessionGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.SessionDeleteArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.SessionDeleteArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.SessionGetPayload<T>, Context>) => Promise<Prisma.SessionGetPayload<T>>
            };

    };
    findFirst: {

        useQuery: <T extends Prisma.SessionFindFirstArgs, TData = Prisma.SessionGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.SessionFindFirstArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.SessionGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.SessionFindFirstArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.SessionFindFirstArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.SessionGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.SessionGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findMany: {

        useQuery: <T extends Prisma.SessionFindManyArgs, TData = Array<Prisma.SessionGetPayload<T>>>(
            input: Prisma.SelectSubset<T, Prisma.SessionFindManyArgs>,
            opts?: UseTRPCQueryOptions<string, T, Array<Prisma.SessionGetPayload<T>>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.SessionFindManyArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.SessionFindManyArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Array<Prisma.SessionGetPayload<T>>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Array<Prisma.SessionGetPayload<T>>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findUnique: {

        useQuery: <T extends Prisma.SessionFindUniqueArgs, TData = Prisma.SessionGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.SessionFindUniqueArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.SessionGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.SessionFindUniqueArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.SessionFindUniqueArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.SessionGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.SessionGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    updateMany: {

        useMutation: <T extends Prisma.SessionUpdateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.SessionUpdateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.SessionUpdateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.SessionUpdateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    update: {

        useMutation: <T extends Prisma.SessionUpdateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.SessionUpdateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.SessionGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.SessionGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.SessionUpdateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.SessionUpdateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.SessionGetPayload<T>, Context>) => Promise<Prisma.SessionGetPayload<T>>
            };

    };
}

================
File: src/.marblism/api/routers/User.router.ts
================
/* eslint-disable */
import { type RouterFactory, type ProcBuilder, type BaseConfig, db } from ".";
import * as _Schema from '@zenstackhq/runtime/zod/input';
const $Schema: typeof _Schema = (_Schema as any).default ?? _Schema;
import { checkRead, checkMutate } from '../helper';
import type { Prisma } from '@prisma/client';
import type { UseTRPCMutationOptions, UseTRPCMutationResult, UseTRPCQueryOptions, UseTRPCQueryResult, UseTRPCInfiniteQueryOptions, UseTRPCInfiniteQueryResult } from '@trpc/react-query/shared';
import type { TRPCClientErrorLike } from '@trpc/client';
import type { AnyRouter } from '@trpc/server';

export default function createRouter<Config extends BaseConfig>(router: RouterFactory<Config>, procedure: ProcBuilder<Config>) {
    return router({

        createMany: procedure.input($Schema.UserInputSchema.createMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).user.createMany(input as any))),

        create: procedure.input($Schema.UserInputSchema.create).mutation(async ({ ctx, input }) => checkMutate(db(ctx).user.create(input as any))),

        deleteMany: procedure.input($Schema.UserInputSchema.deleteMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).user.deleteMany(input as any))),

        delete: procedure.input($Schema.UserInputSchema.delete).mutation(async ({ ctx, input }) => checkMutate(db(ctx).user.delete(input as any))),

        findFirst: procedure.input($Schema.UserInputSchema.findFirst).query(({ ctx, input }) => checkRead(db(ctx).user.findFirst(input as any))),

        findMany: procedure.input($Schema.UserInputSchema.findMany).query(({ ctx, input }) => checkRead(db(ctx).user.findMany(input as any))),

        findUnique: procedure.input($Schema.UserInputSchema.findUnique).query(({ ctx, input }) => checkRead(db(ctx).user.findUnique(input as any))),

        updateMany: procedure.input($Schema.UserInputSchema.updateMany).mutation(async ({ ctx, input }) => checkMutate(db(ctx).user.updateMany(input as any))),

        update: procedure.input($Schema.UserInputSchema.update).mutation(async ({ ctx, input }) => checkMutate(db(ctx).user.update(input as any))),

    }
    );
}

export interface ClientType<AppRouter extends AnyRouter, Context = AppRouter['_def']['_config']['$types']['ctx']> {
    createMany: {

        useMutation: <T extends Prisma.UserCreateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.UserCreateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.UserCreateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.UserCreateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    create: {

        useMutation: <T extends Prisma.UserCreateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.UserCreateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.UserGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.UserGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.UserCreateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.UserCreateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.UserGetPayload<T>, Context>) => Promise<Prisma.UserGetPayload<T>>
            };

    };
    deleteMany: {

        useMutation: <T extends Prisma.UserDeleteManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.UserDeleteManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.UserDeleteManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.UserDeleteManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    delete: {

        useMutation: <T extends Prisma.UserDeleteArgs>(opts?: UseTRPCMutationOptions<
            Prisma.UserDeleteArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.UserGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.UserGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.UserDeleteArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.UserDeleteArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.UserGetPayload<T>, Context>) => Promise<Prisma.UserGetPayload<T>>
            };

    };
    findFirst: {

        useQuery: <T extends Prisma.UserFindFirstArgs, TData = Prisma.UserGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.UserFindFirstArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.UserGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.UserFindFirstArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.UserFindFirstArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.UserGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.UserGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findMany: {

        useQuery: <T extends Prisma.UserFindManyArgs, TData = Array<Prisma.UserGetPayload<T>>>(
            input: Prisma.SelectSubset<T, Prisma.UserFindManyArgs>,
            opts?: UseTRPCQueryOptions<string, T, Array<Prisma.UserGetPayload<T>>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.UserFindManyArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.UserFindManyArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Array<Prisma.UserGetPayload<T>>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Array<Prisma.UserGetPayload<T>>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    findUnique: {

        useQuery: <T extends Prisma.UserFindUniqueArgs, TData = Prisma.UserGetPayload<T>>(
            input: Prisma.SelectSubset<T, Prisma.UserFindUniqueArgs>,
            opts?: UseTRPCQueryOptions<string, T, Prisma.UserGetPayload<T>, TData, Error>
        ) => UseTRPCQueryResult<
            TData,
            TRPCClientErrorLike<AppRouter>
        >;
        useInfiniteQuery: <T extends Prisma.UserFindUniqueArgs>(
            input: Omit<Prisma.SelectSubset<T, Prisma.UserFindUniqueArgs>, 'cursor'>,
            opts?: UseTRPCInfiniteQueryOptions<string, T, Prisma.UserGetPayload<T>, Error>
        ) => UseTRPCInfiniteQueryResult<
            Prisma.UserGetPayload<T>,
            TRPCClientErrorLike<AppRouter>
        >;

    };
    updateMany: {

        useMutation: <T extends Prisma.UserUpdateManyArgs>(opts?: UseTRPCMutationOptions<
            Prisma.UserUpdateManyArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.BatchPayload,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.BatchPayload, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.UserUpdateManyArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.UserUpdateManyArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.BatchPayload, Context>) => Promise<Prisma.BatchPayload>
            };

    };
    update: {

        useMutation: <T extends Prisma.UserUpdateArgs>(opts?: UseTRPCMutationOptions<
            Prisma.UserUpdateArgs,
            TRPCClientErrorLike<AppRouter>,
            Prisma.UserGetPayload<T>,
            Context
        >,) =>
            Omit<UseTRPCMutationResult<Prisma.UserGetPayload<T>, TRPCClientErrorLike<AppRouter>, Prisma.SelectSubset<T, Prisma.UserUpdateArgs>, Context>, 'mutateAsync'> & {
                mutateAsync:
                <T extends Prisma.UserUpdateArgs>(variables: T, opts?: UseTRPCMutationOptions<T, TRPCClientErrorLike<AppRouter>, Prisma.UserGetPayload<T>, Context>) => Promise<Prisma.UserGetPayload<T>>
            };

    };
}

================
File: src/.marblism/api/helper.ts
================
/* eslint-disable */
import { TRPCError } from '@trpc/server';
import { isPrismaClientKnownRequestError } from '@zenstackhq/runtime';

export async function checkMutate<T>(promise: Promise<T>): Promise<T | undefined> {
    try {
        return await promise;
    } catch (err: any) {
        if (isPrismaClientKnownRequestError(err)) {
            if (err.code === 'P2004') {
                if (err.meta?.reason === 'RESULT_NOT_READABLE') {
                    // unable to readback data
                    return undefined;
                } else {
                    // rejected by policy
                    throw new TRPCError({
                        code: 'FORBIDDEN',
                        message: err.message,
                        cause: err,
                    });
                }
            } else {
                // request error
                throw new TRPCError({
                    code: 'BAD_REQUEST',
                    message: err.message,
                    cause: err,
                });
            }
        } else {
            throw err;
        }
    }

}

export async function checkRead<T>(promise: Promise<T>): Promise<T> {
    try {
        return await promise;
    } catch (err: any) {
        if (isPrismaClientKnownRequestError(err)) {
            if (err.code === 'P2004') {
                // rejected by policy
                throw new TRPCError({
                    code: 'FORBIDDEN',
                    message: err.message,
                    cause: err,
                });
            } else if (err.code === 'P2025') {
                // not found
                throw new TRPCError({
                    code: 'NOT_FOUND',
                    message: err.message,
                    cause: err,
                });
            } else {
                // request error
                throw new TRPCError({
                    code: 'BAD_REQUEST',
                    message: err.message,
                    cause: err,
                })
            }
        } else {
            throw err;
        }
    }

}

================
File: src/.marblism/workspace/hooks.tsx
================
'use client'

import { useParams, usePathname, useRouter } from 'next/navigation'
import { closeSnackbar } from 'notistack'
import { useEffect } from 'react'

const restoreUrl = (route: string, params: Record<string, string>) => {
  let routeRestored = route

  Object.entries(params).forEach(
    ([key, value]) => (routeRestored = routeRestored.replace(value, `:${key}`)),
  )

  return routeRestored
}

/**
 * Emit request when the path changed
 */
export const useMessageSend = (isActive = false) => {
  const pathname = usePathname()
  const params: any = useParams()

  useEffect(() => {
    if (!isActive) {
      return
    }

    window.parent.postMessage({ type: 'ready' }, '*')
  }, [isActive])

  useEffect(() => {
    if (!isActive) {
      return
    }

    const url = `${window.location.origin}${pathname}`

    const pathPure = restoreUrl(pathname, params)

    window.parent.postMessage({ type: 'navigation', url, pathPure }, '*')
  }, [pathname, params])
}

/**
 * Change the path on request
 */
export const useMessageReceived = (isActive = false) => {
  const router = useRouter()

  const handleMessage = event => {
    const canContinue = event?.data?.type === 'navigation'

    if (canContinue) {
      const path = event.data.path?.trim()

      if (path && path !== '') {
        router.push(path)
        closeSnackbar()
      }
    }
  }

  useEffect(() => {
    if (!isActive) {
      return
    }

    window.addEventListener('message', handleMessage)

    return () => {
      window.removeEventListener('message', handleMessage)
    }
  }, [])
}

================
File: src/.marblism/workspace/index.tsx
================
import { Api } from '@/core/trpc'
import React, { ReactNode } from 'react'
import { useMessageReceived, useMessageSend } from './hooks'

type Props = {
  children: ReactNode
}

const useWorkspace = () => {
  const { data } = Api.configuration.getPublic.useQuery()

  const isActive = data?.['PUBLIC_MARBLISM_ENV'] === 'workspace'

  useMessageSend(isActive)

  useMessageReceived(isActive)

  return <></>
}

export const WorkspaceProvider: React.FC<Props> = ({ children }) => {
  useWorkspace()

  return <>{children}</>
}

================
File: src/app/(authenticated)/home/page.tsx
================
'use client'

import { Prisma } from '@prisma/client'
import { Typography, Row, Col, Card, Spin } from 'antd'
import { UserOutlined, TeamOutlined } from '@ant-design/icons'
const { Title, Text, Paragraph } = Typography
import { useUserContext } from '@/core/context'
import { useRouter, useParams } from 'next/navigation'
import { useUploadPublic } from '@/core/hooks/upload'
import { useSnackbar } from 'notistack'
import dayjs from 'dayjs'
import { Api } from '@/core/trpc'
import { PageLayout } from '@/designSystem/layouts/Page.layout'

export default function HomePage() {
  const router = useRouter()
  const params = useParams<any>()
  const { user, checkOrganizationRole } = useUserContext()
  const { enqueueSnackbar } = useSnackbar()

  const { data: chatbotInteractions, isLoading: isLoadingChatbot } =
    Api.chatbotInteraction.findMany.useQuery({
      where: { userId: user?.id },
      include: { user: true },
    })

  const { data: workspaceActivities, isLoading: isLoadingWorkspace } =
    Api.workspaceActivity.findMany.useQuery({
      where: { organizationId: params.organizationId },
      include: { organization: true, user: true },
    })

  const isAdmin = checkOrganizationRole('admin')

  return (
    <PageLayout layout="narrow">
      <Title level={2}>Dashboard Overview</Title>
      <Paragraph>
        {isAdmin
          ? 'As an admin, you can see an overview of workspace activity and user engagement.'
          : "As a user, you can see an overview of the chatbot's capabilities and recent interactions."}
      </Paragraph>
      <Row gutter={[16, 16]} justify="center">
        {isAdmin && (
          <Col span={24}>
            <Card title="Workspace Activity" bordered={false}>
              <TeamOutlined />

              {isLoadingWorkspace ? (
                <Spin />
              ) : (
                workspaceActivities?.map(activity => (
                  <div key={activity.id}>
                    <Text strong>{activity.user?.name}</Text> engaged in{' '}
                    <Text strong>{activity.organization?.name}</Text> on{' '}
                    {dayjs(activity.dateCreated).format('MMMM D, YYYY')}
                  </div>
                ))
              )}
            </Card>
          </Col>
        )}
        {!isAdmin && (
          <Col span={24}>
            <Card title="Recent Chatbot Interactions" bordered={false}>
              <UserOutlined />

              {isLoadingChatbot ? (
                <Spin />
              ) : (
                chatbotInteractions?.map(interaction => (
                  <div key={interaction.id}>
                    <Text strong>{interaction.user?.name}</Text> interacted with
                    the chatbot on{' '}
                    {dayjs(interaction.dateCreated).format('MMMM D, YYYY')}
                  </div>
                ))
              )}
            </Card>
          </Col>
        )}
      </Row>
    </PageLayout>
  )
}

================
File: src/app/(authenticated)/organizations/[organizationId]/ai-rag-upload/page.tsx
================
'use client'

import { useState } from 'react'
import { Typography, Upload, Button, List, Spin, Row, Col } from 'antd'
import { UploadOutlined, DeleteOutlined } from '@ant-design/icons'
const { Title, Text } = Typography
import { useUserContext } from '@/core/context'
import { useRouter, useParams } from 'next/navigation'
import { useUploadPublic } from '@/core/hooks/upload'
import { useSnackbar } from 'notistack'
import dayjs from 'dayjs'
import { Api } from '@/core/trpc'
import { PageLayout } from '@/designSystem/layouts/Page.layout'

export default function AIRAGFileUploadPage() {
  const router = useRouter()
  const params = useParams<any>()
  const { user } = useUserContext()
  const { enqueueSnackbar } = useSnackbar()
  const [fileList, setFileList] = useState<any[]>([])

  const {
    data: files,
    isLoading,
    refetch,
  } = Api.ragVector.findMany.useQuery({})
  const { mutateAsync: upload } = useUploadPublic()
  const { mutateAsync: loadFile } = Api.rag.loadFile.useMutation()
  const { mutateAsync: deleteFile } = Api.ragVector.delete.useMutation()

  const handleUpload = async (file: any) => {
    try {
      const { url } = await upload({ file })
      const { key } = await loadFile({ url })
      enqueueSnackbar('File uploaded successfully', { variant: 'success' })
      refetch()
    } catch (error) {
      enqueueSnackbar('Failed to upload file', { variant: 'error' })
    }
  }

  const handleDelete = async (id: string) => {
    try {
      await deleteFile({ where: { id } })
      enqueueSnackbar('File deleted successfully', { variant: 'success' })
      refetch()
    } catch (error) {
      enqueueSnackbar('Failed to delete file', { variant: 'error' })
    }
  }

  const uploadProps = {
    onRemove: (file: any) => {
      setFileList(prevFileList => {
        const index = prevFileList.indexOf(file)
        const newFileList = prevFileList.slice()
        newFileList.splice(index, 1)
        return newFileList
      })
    },
    beforeUpload: (file: any) => {
      setFileList(prevFileList => [...prevFileList, file])
      handleUpload(file)
      return false
    },
    fileList,
  }

  return (
    <PageLayout layout="narrow">
      <Row justify="center">
        <Col span={24}>
          <Title level={2}>AI RAG File Upload</Title>
          <Text>
            As an admin, you can upload and manage files to be used in the AI
            RAG context.
          </Text>
        </Col>
      </Row>
      <Row justify="center" style={{ marginTop: 20 }}>
        <Col span={24}>
          <Upload {...uploadProps} fileList={fileList}>
            <Button icon={<UploadOutlined />}>Upload File</Button>
          </Upload>
        </Col>
      </Row>
      <Row justify="center" style={{ marginTop: 20 }}>
        <Col span={24}>
          {isLoading ? (
            <Spin />
          ) : (
            <List
              itemLayout="horizontal"
              dataSource={files}
              renderItem={(file: any) => (
                <List.Item
                  actions={[
                    <Button
                      type="link"
                      icon={<DeleteOutlined />}
                      onClick={() => handleDelete(file.id)}
                    />,
                  ]}
                >
                  <List.Item.Meta
                    title={file.key}
                    description={`Uploaded on ${file.dateCreated}`}
                  />
                </List.Item>
              )}
            />
          )}
        </Col>
      </Row>
    </PageLayout>
  )
}

================
File: src/app/(authenticated)/organizations/[organizationId]/billing/page.tsx
================
'use client'

import { useState, useEffect } from 'react'
import { Prisma } from '@prisma/client'
import {
  Typography,
  Form,
  Input,
  Button,
  Row,
  Col,
  Card,
  Spin,
  Table,
  Space,
  Modal,
} from 'antd'
import {
  EditOutlined,
  UserAddOutlined,
  DeleteOutlined,
} from '@ant-design/icons'
const { Title, Text } = Typography
import { useUserContext } from '@/core/context'
import { useRouter, useParams } from 'next/navigation'
import { useUploadPublic } from '@/core/hooks/upload'
import { useSnackbar } from 'notistack'
import dayjs from 'dayjs'
import { Api } from '@/core/trpc'
import { PageLayout } from '@/designSystem/layouts/Page.layout'

export default function BillingandSubscriptionPage() {
  const router = useRouter()
  const params = useParams<any>()
  const { user, organization } = useUserContext()
  const { enqueueSnackbar } = useSnackbar()

  const [isEditing, setIsEditing] = useState(false)
  const [billingInfo, setBillingInfo] =
    useState<
      Prisma.BillingDataGetPayload<{ include: { organization: true } }>
    >()
  const [users, setUsers] = useState<Prisma.UserGetPayload<{}>[]>([])

  const {
    data: billingData,
    isLoading: billingLoading,
    refetch: refetchBilling,
  } = Api.billingData.findFirst.useQuery({
    where: { organizationId: organization?.id },
    include: { organization: true },
  })

  const {
    data: usersData,
    isLoading: usersLoading,
    refetch: refetchUsers,
  } = Api.user.findMany.useQuery({
    where: {
      organizationRoles: { some: { organizationId: organization?.id } },
    },
  })

  const { mutateAsync: updateBilling } = Api.billingData.update.useMutation()
  const { mutateAsync: deleteUser } = Api.user.delete.useMutation()

  useEffect(() => {
    if (billingData) setBillingInfo(billingData)
    if (usersData) setUsers(usersData || [])
  }, [billingData, usersData])

  const handleUpdateBilling = async (values: any) => {
    try {
      await updateBilling({ where: { id: billingInfo?.id }, data: values })
      enqueueSnackbar('Billing information updated successfully', {
        variant: 'success',
      })
      setIsEditing(false)
      refetchBilling()
    } catch (error) {
      enqueueSnackbar('Failed to update billing information', {
        variant: 'error',
      })
    }
  }

  const handleDeleteUser = async (userId: string) => {
    try {
      await deleteUser({ where: { id: userId } })
      enqueueSnackbar('User deleted successfully', { variant: 'success' })
      refetchUsers()
    } catch (error) {
      enqueueSnackbar('Failed to delete user', { variant: 'error' })
    }
  }

  const columns = [
    {
      title: 'Name',
      dataIndex: 'name',
      key: 'name',
    },
    {
      title: 'Email',
      dataIndex: 'email',
      key: 'email',
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_: any, record: any) => (
        <Space size="middle">
          <Button
            icon={<DeleteOutlined />}
            onClick={() => handleDeleteUser(record.id)}
          />
        </Space>
      ),
    },
  ]

  return (
    <PageLayout layout="narrow">
      <Title level={2}>Billing and Subscription</Title>
      <Text>
        Manage your current billing plan and usage, update billing information,
        and manage users for billing purposes.
      </Text>

      <Spin spinning={billingLoading || usersLoading}>
        <Card
          title="Current Billing Plan"
          extra={
            <Button icon={<EditOutlined />} onClick={() => setIsEditing(true)}>
              Edit
            </Button>
          }
        >
          {billingInfo && (
            <>
              <p>Number of Users: {billingInfo.numberOfUsers}</p>
              <p>Billing Date: {billingInfo.billingDate}</p>
            </>
          )}
        </Card>

        <Modal
          title="Update Billing Information"
          visible={isEditing}
          onCancel={() => setIsEditing(false)}
          footer={null}
        >
          <Form layout="vertical" onFinish={handleUpdateBilling}>
            <Form.Item
              label="Number of Users"
              name="numberOfUsers"
              initialValue={billingInfo?.numberOfUsers}
            >
              <Input type="number" />
            </Form.Item>
            <Form.Item
              label="Billing Date"
              name="billingDate"
              initialValue={billingInfo?.billingDate}
            >
              <Input type="date" />
            </Form.Item>
            <Form.Item>
              <Button type="primary" htmlType="submit">
                Update
              </Button>
            </Form.Item>
          </Form>
        </Modal>

        <Card
          title="Manage Users"
          extra={<Button icon={<UserAddOutlined />}>Add User</Button>}
        >
          <Table dataSource={users || []} columns={columns} rowKey="id" />
        </Card>
      </Spin>
    </PageLayout>
  )
}

================
File: src/app/(authenticated)/organizations/[organizationId]/chat/page.tsx
================
'use client'

import { useUserContext } from '@/core/context'
import { Api } from '@/core/trpc'
import { PageLayout } from '@/designSystem/layouts/Page.layout'
import { SendOutlined } from '@ant-design/icons'
import { Button, Col, Input, List, Row, Typography } from 'antd'
import dayjs from 'dayjs'
import { useParams, useRouter } from 'next/navigation'
import { useSnackbar } from 'notistack'
import { useState } from 'react'
const { Title, Text } = Typography

export default function ChatbotInteractionPage() {
  const router = useRouter()
  const params = useParams<any>()
  const { user } = useUserContext()
  const { enqueueSnackbar } = useSnackbar()
  const [question, setQuestion] = useState<string>('')
  const [chatHistory, setChatHistory] = useState<
    { question: string; answer: string; timestamp: number }[]
  >([])

  const { mutateAsync: generateAssistantText } =
    Api.ai.generateAssistantText.useMutation()
  const { mutateAsync: generateText } = Api.rag.generateText.useMutation()

  const handleAskQuestion = async () => {
    if (!question.trim()) {
      enqueueSnackbar('Please enter a question', { variant: 'error' })
      return
    }
    try {
      console.log('Starting Rag query now')
      const response = await generateText({ prompt: question })
      const respAnswer = response.answer
      console.log(response)

      // console.log('also launching assistant')
      // const assistResponse = await generateAssistantText({ prompt: question })
      // const respAnswer = assistResponse.answer
      //console.log(assistResponse)

      setChatHistory([
        { question, answer: respAnswer, timestamp: Date.now() },
        ...chatHistory,
      ])

      setQuestion('')
    } catch (error) {
      enqueueSnackbar('Failed to get response from AI', { variant: 'error' })
    }
  }

  return (
    <PageLayout layout="narrow">
      <Row justify="center">
        <Col span={24}>
          <Title level={2}>AI Chatbot</Title>
          <Text>
            Ask questions about company policies, time off, and benefits. View
            responses from the AI chatbot. This is loaded with the PMF handbook.
          </Text>
        </Col>
      </Row>
      <Row justify="center" style={{ marginTop: '20px' }}>
        <Col span={24}>
          <Input
            placeholder="Type your question here..."
            value={question}
            onChange={e => setQuestion(e.target.value)}
            onPressEnter={handleAskQuestion}
            suffix={
              <Button
                type="primary"
                icon={<SendOutlined />}
                onClick={handleAskQuestion}
              >
                Ask
              </Button>
            }
          />
        </Col>
      </Row>
      <Row justify="center" style={{ marginTop: '20px' }}>
        <Col span={24}>
          <List
            bordered
            dataSource={chatHistory}
            renderItem={item => (
              <List.Item>
                <div style={{ width: '100%' }}>
                  <Text strong>Question: </Text>
                  <Text>{item.question}</Text>
                  <br />
                  <Text strong>Answer: </Text>
                  <Text>{item.answer}</Text>
                  <div style={{ textAlign: 'right' }}>
                    <Text type="secondary">
                      {dayjs(item.timestamp).format('YYYY-MM-DD HH:mm:ss')}
                    </Text>
                  </div>
                </div>
              </List.Item>
            )}
          />
        </Col>
      </Row>
    </PageLayout>
  )
}

================
File: src/app/(authenticated)/organizations/[organizationId]/dashboard/page.tsx
================
'use client'

import { Prisma } from '@prisma/client'
import { Typography, Row, Col, Card, Spin, List } from 'antd'
import { UserOutlined, BarChartOutlined } from '@ant-design/icons'
const { Title, Text, Paragraph } = Typography
import { useUserContext } from '@/core/context'
import { useRouter, useParams } from 'next/navigation'
import { useUploadPublic } from '@/core/hooks/upload'
import { useSnackbar } from 'notistack'
import dayjs from 'dayjs'
import { Api } from '@/core/trpc'
import { PageLayout } from '@/designSystem/layouts/Page.layout'

export default function WorkspaceDashboardPage() {
  const router = useRouter()
  const params = useParams<any>()
  const { user, checkOrganizationRole } = useUserContext()
  const { enqueueSnackbar } = useSnackbar()

  const isAdmin = checkOrganizationRole('admin')
  const organizationId = params.organizationId

  const { data: interactions, isLoading: interactionsLoading } =
    Api.interaction.findMany.useQuery({
      where: { userId: user?.id },
      include: { chatbot: true },
    })

  const { data: statistics, isLoading: statisticsLoading } =
    Api.statistics.findMany.useQuery({
      where: { organizationId },
    })

  return (
    <PageLayout layout="narrow">
      <Title level={2}>Workspace Dashboard</Title>
      <Paragraph>
        View your recent interactions and workspace statistics.
      </Paragraph>
      <Row gutter={[16, 16]} justify="center">
        <Col xs={24} md={12}>
          <Card
            title={
              <>
                <UserOutlined /> Recent Interactions
              </>
            }
            loading={interactionsLoading}
          >
            {interactionsLoading ? (
              <Spin />
            ) : (
              <List
                itemLayout="horizontal"
                dataSource={interactions}
                renderItem={(interaction: any) => (
                  <List.Item>
                    <List.Item.Meta
                      title={interaction.chatbot?.name}
                      description={dayjs(interaction.dateCreated).format(
                        'YYYY-MM-DD HH:mm',
                      )}
                    />
                  </List.Item>
                )}
              />
            )}
          </Card>
        </Col>
        {isAdmin && (
          <Col xs={24} md={12}>
            <Card
              title={
                <>
                  <BarChartOutlined /> Workspace Statistics
                </>
              }
              loading={statisticsLoading}
            >
              {statisticsLoading ? (
                <Spin />
              ) : (
                <List
                  itemLayout="horizontal"
                  dataSource={statistics}
                  renderItem={(stat: any) => (
                    <List.Item>
                      <List.Item.Meta
                        title={stat.metric}
                        description={stat.value?.toString()}
                      />
                    </List.Item>
                  )}
                />
              )}
            </Card>
          </Col>
        )}
      </Row>
    </PageLayout>
  )
}

================
File: src/app/(authenticated)/organizations/[organizationId]/members/hooks/useDelete.tsx
================
import { useUserContext } from '@/core/context'
import { Api } from '@/core/trpc'
import { OrganizationRole, User } from '@prisma/client'
import { useSnackbar } from 'notistack'
import { useState } from 'react'

type UserWithOrganizationRoles = User & {
  organizationRoles: OrganizationRole[]
}

type Props = { users: UserWithOrganizationRoles[] }

export const useDelete = ({ users }: Props) => {
  const { enqueueSnackbar } = useSnackbar()

  const { user: userLogged, checkOrganizationRole } = useUserContext()

  const [isLoading, setLoading] = useState(false)

  const countOwners = users.filter(user =>
    user.organizationRoles.find(role => role.name === 'owner'),
  ).length

  const { mutateAsync: deleteOrganizationRole } =
    Api.organizationRole.deleteMany.useMutation()

  const canDeleteUser = (user: UserWithOrganizationRoles) => {
    const isOwner = user.organizationRoles.find(
      organizationRole => organizationRole.name === 'owner',
    )

    const isSelf = userLogged.id === user.id

    if (isSelf) {
      return !isOwner || countOwners > 1
    } else {
      return checkOrganizationRole('owner')
    }
  }

  const deleteUser = async (user: UserWithOrganizationRoles) => {
    setLoading(true)

    let isSuccess = false

    if (canDeleteUser(user)) {
      try {
        await deleteOrganizationRole({
          where: {
            userId: user.id,
          },
        })

        if (user.id === userLogged.id) {
          window.location.replace('/')
        } else {
          enqueueSnackbar(`${user.email} has been removed`)
        }
      } catch (error) {
        enqueueSnackbar(error.message, { variant: 'error' })
      }
    }

    setLoading(false)

    return isSuccess
  }

  return {
    deleteUser,
    isLoadingDelete: isLoading,
    canDeleteUser,
  }
}

================
File: src/app/(authenticated)/organizations/[organizationId]/members/hooks/useInvitation.tsx
================
import { Utility } from '@/core/helpers/utility'
import { Api } from '@/core/trpc'
import { Organization } from '@prisma/client'
import { useSnackbar } from 'notistack'
import { useState } from 'react'

type Props = {
  email: string
  organization: Organization
}

export const useInvitation = ({ organization, email }: Props) => {
  const { enqueueSnackbar } = useSnackbar()

  const [isLoading, setLoading] = useState(false)

  const emailEnsured = email?.trim()?.toLowerCase()

  const { refetch: fetchOrganizationRole } =
    Api.organizationRole.findFirst.useQuery(
      {
        where: {
          organizationId: organization.id,
          user: {
            email: emailEnsured,
          },
        },
      },
      { enabled: false },
    )

  const { mutateAsync: inviteToOrganization } =
    Api.authentication.inviteToOrganization.useMutation()

  const invite = async () => {
    setLoading(true)

    let isSuccess = false

    if (Utility.isDefined(email)) {
      try {
        const organizationRole = await fetchOrganizationRole().then(
          response => response.data,
        )

        if (!organizationRole) {
          await inviteToOrganization({
            organizationId: organization.id,
            email: emailEnsured,
          })

          enqueueSnackbar(`${emailEnsured} has been added`)
        }

        isSuccess = true
      } catch (error) {
        enqueueSnackbar(error.message, { variant: 'error' })
      }
    }

    setLoading(false)

    return isSuccess
  }

  return {
    invite,
    isLoadingInvitation: isLoading,
  }
}

================
File: src/app/(authenticated)/organizations/[organizationId]/members/hooks/useUpdate.tsx
================
import { useUserContext } from '@/core/context'
import { Api } from '@/core/trpc'
import { OrganizationRole, User } from '@prisma/client'
import { useSnackbar } from 'notistack'
import { useState } from 'react'

type UserWithOrganizationRoles = User & {
  organizationRoles: OrganizationRole[]
}

type Props = { users: UserWithOrganizationRoles[] }

export const useUpdate = ({ users }: Props) => {
  const { enqueueSnackbar } = useSnackbar()

  const { checkOrganizationRole } = useUserContext()

  const [isLoading, setLoading] = useState(false)

  const countOwners = users.filter(user =>
    user.organizationRoles.find(role => role.name === 'owner'),
  ).length

  const { mutateAsync: updateOrganizationRole } =
    Api.organizationRole.update.useMutation()

  const canUpdate = () => checkOrganizationRole('owner')

  const update = async (organizationRole: OrganizationRole, name: string) => {
    setLoading(true)

    let isSuccess = false

    if (canUpdate()) {
      try {
        const isDowngrade =
          organizationRole.name === 'owner' && name !== 'owner'

        if (isDowngrade && countOwners < 2) {
          throw new Error(`There must be at least 1 owner`)
        }

        await updateOrganizationRole({
          where: { id: organizationRole.id },
          data: { name },
        })

        isSuccess = true

        enqueueSnackbar(`Role has been updated`)
      } catch (error) {
        enqueueSnackbar(error.message, { variant: 'error' })
      }
    }

    setLoading(false)

    return isSuccess
  }

  return {
    update,
    canUpdate,
    isLoadingUpdate: isLoading,
  }
}

================
File: src/app/(authenticated)/organizations/[organizationId]/members/page.tsx
================
'use client'

import {
  Avatar,
  Button,
  Dropdown,
  Flex,
  Form,
  Input,
  MenuProps,
  Popconfirm,
  Row,
  Table,
  TableProps,
  Tag,
  Tooltip,
  Typography,
} from 'antd'

import { useUserContext } from '@/core/context'
import { Utility } from '@/core/helpers/utility'
import { Api } from '@/core/trpc'
import { PageLayout } from '@/designSystem'
import {
  CheckOutlined,
  CopyOutlined,
  DeleteOutlined,
  EditFilled,
  HourglassOutlined,
  UserAddOutlined,
} from '@ant-design/icons'
import { OrganizationRole, User } from '@prisma/client'
import { useSnackbar } from 'notistack'
import { useState } from 'react'
import { useDelete } from './hooks/useDelete'
import { useInvitation } from './hooks/useInvitation'
import { useUpdate } from './hooks/useUpdate'

type UserWithOrganizationRoles = User & {
  organizationRoles: OrganizationRole[]
}

export default function OrganizationTeamPage() {
  const { enqueueSnackbar } = useSnackbar()

  const { organization } = useUserContext()

  const [form] = Form.useForm()

  const [email, setEmail] = useState<string>('')

  const {
    data: users,
    isLoading: isLoadingUsers,
    refetch: refetchUsers,
  } = Api.user.findMany.useQuery(
    {
      where: {
        organizationRoles: { some: { organizationId: organization.id } },
      },
      include: {
        organizationRoles: { where: { organizationId: organization.id } },
      },
      orderBy: { dateCreated: 'desc' },
    },
    { initialData: [] },
  )

  const { invite, isLoadingInvitation } = useInvitation({ organization, email })

  const { update, canUpdate, isLoadingUpdate } = useUpdate({ users })

  const { deleteUser, canDeleteUser, isLoadingDelete } = useDelete({ users })

  const handleInvite = async () => {
    const isSuccess = await invite()

    if (isSuccess) {
      setEmail('')
      form.setFieldsValue({ email: '' })
      refetchUsers()
    }
  }

  const handleUpdate = async (
    organizationRole: OrganizationRole,
    name: string,
  ) => {
    const isSuccess = await update(organizationRole, name)

    if (isSuccess) {
      refetchUsers()
    }
  }

  const handleDeleteUser = async (user: UserWithOrganizationRoles) => {
    const isSuccess = await deleteUser(user)

    if (isSuccess) {
      refetchUsers()
    }
  }

  const dataSource = users
    .map(item => ({ ...item, key: item.id }))
    .filter(item => {
      const search = email.trim().toLowerCase()
      const userEmail = item.email.trim().toLowerCase()
      const userName = item.name?.trim().toLowerCase() ?? ''

      return userEmail.includes(search) || userName.includes(search)
    })

  const columns: TableProps['columns'] = [
    {
      title: `${dataSource.length} Members`,
      key: 'id',
      render: (user: UserWithOrganizationRoles) => (
        <Flex gap={8} align="center">
          <Avatar src={user.pictureUrl}>
            {Utility.stringToInitials(user.name ?? user.email)}
          </Avatar>

          <Flex vertical style={{ overflow: 'hidden' }}>
            <Typography.Text ellipsis>{user.name}</Typography.Text>
            <Typography.Text ellipsis type="secondary">
              {user.email}
            </Typography.Text>
          </Flex>
        </Flex>
      ),
    },
    {
      title: 'Role',
      key: 'role',
      render: (user: UserWithOrganizationRoles) => (
        <Row gutter={[16, 16]}>
          {user.organizationRoles.map(role => {
            const isInvited = user.status === 'INVITED'

            const isUserOwner = role.name === 'owner'

            const itemsDropdown: MenuProps['items'] = [
              {
                key: 'owner',
                label: (
                  <Flex gap={8}>Owner {isUserOwner && <CheckOutlined />}</Flex>
                ),
                onClick: () => handleUpdate(role, 'owner'),
              },
              {
                key: 'member',
                label: (
                  <Flex gap={8}>
                    Member {!isUserOwner && <CheckOutlined />}
                  </Flex>
                ),
                onClick: () => handleUpdate(role, 'member'),
              },
            ]

            return (
              <Tag
                key={role.id}
                style={{ textTransform: 'capitalize' }}
                bordered={false}
                color={isInvited ? 'warning' : undefined}
              >
                <Flex gap={10} align="center">
                  {isInvited && <HourglassOutlined />}

                  {role.name}

                  {canUpdate() && (
                    <Dropdown
                      trigger={['click']}
                      placement="topRight"
                      menu={{
                        items: itemsDropdown,
                        selectable: false,
                      }}
                    >
                      <Button
                        loading={isLoadingUpdate}
                        size="small"
                        type="text"
                        style={{ color: 'inherit' }}
                      >
                        <EditFilled />
                      </Button>
                    </Dropdown>
                  )}
                </Flex>
              </Tag>
            )
          })}
        </Row>
      ),
    },
    {
      title: '',
      key: 'invite',
      width: '50px',
      render: (user: UserWithOrganizationRoles) => {
        return (
          <Flex gap={8} justify="end">
            {user.status === 'INVITED' && (
              <Button
                icon={<CopyOutlined />}
                type="text"
                size="small"
                onClick={() => {
                  navigator.clipboard.writeText(
                    `${window.location.origin}/register?tokenInvitation=${encodeURIComponent(user.tokenInvitation)}&email=${encodeURIComponent(user.email)}`,
                  )
                  enqueueSnackbar('Invitation URL copied')
                }}
              />
            )}
          </Flex>
        )
      },
    },
    {
      title: '',
      key: 'delete',
      width: '50px',
      render: (user: UserWithOrganizationRoles) => {
        return (
          <Flex gap={8} justify="end">
            {canDeleteUser(user) && (
              <Popconfirm
                title="Are you sure you want to delete this user?"
                onConfirm={() => handleDeleteUser(user)}
                okText="Yes"
                cancelText="No"
              >
                <Button
                  danger
                  size="small"
                  type="text"
                  icon={<DeleteOutlined />}
                  loading={isLoadingDelete}
                />
              </Popconfirm>
            )}
          </Flex>
        )
      },
    },
  ]

  return (
    <PageLayout>
      <Flex
        gap={30}
        vertical
        justify="center"
        align="center"
        style={{ width: '100%' }}
      >
        <Typography.Title level={1}>Members</Typography.Title>

        <Form
          form={form}
          onFinish={handleInvite}
          layout="vertical"
          requiredMark={false}
        >
          <Form.Item name="email">
            <Input
              placeholder="User email"
              style={{ width: 300 }}
              type="email"
              disabled={isLoadingInvitation}
              onChange={event => setEmail(event.target.value)}
              suffix={
                <Tooltip title="Invite">
                  <Button
                    type="text"
                    htmlType="submit"
                    loading={isLoadingInvitation}
                    icon={<UserAddOutlined />}
                  ></Button>
                </Tooltip>
              }
            />
          </Form.Item>
        </Form>

        <Table
          dataSource={dataSource}
          columns={columns}
          loading={isLoadingUsers}
          style={{ width: '100%' }}
        />
      </Flex>
    </PageLayout>
  )
}

================
File: src/app/(authenticated)/organizations/[organizationId]/pricing/page.tsx
================
'use client'

import { Card, Col, Flex, Row, Tag, Typography } from 'antd'

import { Api } from '@/core/trpc'
import { PageLayout } from '@/designSystem'
import { Product } from '@/server/libraries/payment'
import { useParams } from 'next/navigation'

export default function OrganizationPricingPage() {
  const params: { organizationId: string } = useParams()

  const { data: products } = Api.billing.findManyProducts.useQuery(
    {},
    { initialData: [] },
  )

  const { mutateAsync: createPaymentLink } =
    Api.billing.createPaymentLink.useMutation()

  const { data: subscriptions } = Api.billing.findManySubscriptions.useQuery(
    {
      organizationId: params.organizationId,
    },
    { initialData: [] },
  )

  const handleClick = async (product: Product) => {
    const { url } = await createPaymentLink({
      productId: product.id,
      organizationId: params.organizationId,
    })

    window.open(url, '_blank')
  }

  const getPrice = (product: Product) => {
    if (product.price === 0) {
      return 'Free'
    }

    const mapping = {
      usd: '${{price}}',
    }

    const pattern = mapping[product.currency]

    if (pattern) {
      return pattern.replace('{{price}}', product.price)
    }

    return `${product.currency.toUpperCase()} ${product.price}`
  }

  const isSubscribed = (product: Product) => {
    return subscriptions.find(
      subscription => subscription.productId === product.id,
    )
  }

  return (
    <PageLayout>
      <Row gutter={[16, 16]} justify="center">
        {products.map(product => (
          <Col key={product.id} xs={24} sm={12} md={12} lg={12} xl={8}>
            <Card
              style={{ height: '100%', overflow: 'hidden' }}
              hoverable
              onClick={() => handleClick(product)}
              cover={
                <Flex
                  style={{
                    position: 'relative',
                    height: '40vh',
                    width: '100%',
                    overflow: 'hidden',
                    display: 'flex',
                    justifyContent: 'center',
                    alignItems: 'center',
                    borderTopLeftRadius: '10px',
                    borderTopRightRadius: '10px',
                  }}
                >
                  <img
                    src={product.coverUrl}
                    alt={product.name}
                    style={{
                      position: 'absolute',
                      top: 0,
                      left: 0,
                      height: '100%',
                      width: '100%',
                      objectFit: 'cover',
                    }}
                  />
                </Flex>
              }
            >
              <Flex vertical gap={10}>
                <Typography.Title level={3} style={{ margin: 0 }}>
                  {product.name}
                </Typography.Title>

                <Flex align="center">
                  <Typography.Title level={1} style={{ margin: 0 }}>
                    {getPrice(product)}
                  </Typography.Title>
                  {product.interval && (
                    <Typography.Text className="ml-1">
                      / {product.interval}
                    </Typography.Text>
                  )}
                </Flex>

                {isSubscribed(product) && (
                  <div>
                    <Tag color="success">Active</Tag>
                  </div>
                )}

                <Typography.Text type="secondary">
                  {product.description}
                </Typography.Text>
              </Flex>
            </Card>
          </Col>
        ))}
      </Row>
    </PageLayout>
  )
}

================
File: src/app/(authenticated)/organizations/[organizationId]/settings/page.tsx
================
'use client'

import { Avatar, Button, Flex, Form, Input, Popconfirm } from 'antd'

import { useUserContext } from '@/core/context'
import { Utility } from '@/core/helpers/utility'
import { Api } from '@/core/trpc'
import { PageLayout } from '@/designSystem'
import { User } from '@prisma/client'
import { useSnackbar } from 'notistack'
import { useEffect } from 'react'

export default function OrganizationSettingsPage() {
  const { enqueueSnackbar } = useSnackbar()

  const {
    organization,
    refetchOrganization,
    refetchOrganizations,
    checkOrganizationRole,
  } = useUserContext()

  const { mutateAsync: updateOrganization, isLoading: isLoadingUpdate } =
    Api.organization.update.useMutation()

  const { mutateAsync: deleteOrganization, isLoading: isLoadingDelete } =
    Api.organization.delete.useMutation()

  const [form] = Form.useForm()

  useEffect(() => {
    form.setFieldsValue(organization)
  }, [organization])

  const handleSubmit = async (values: Partial<User>) => {
    try {
      await updateOrganization({
        where: { id: organization.id },
        data: {
          name: values.name,
          pictureUrl: values.pictureUrl,
        },
      })

      refetchOrganization()
      refetchOrganizations()
    } catch (error) {
      enqueueSnackbar(`Could not save user: ${error.message}`, {
        variant: 'error',
      })
    }
  }

  const handleClickDelete = async () => {
    await deleteOrganization({ where: { id: organization.id } })

    window.location.replace('/home')
  }

  return (
    <PageLayout layout="super-narrow">
      <Flex justify="center" style={{ marginBottom: '30px' }}>
        <Avatar
          shape="square"
          size={120}
          src={organization.pictureUrl}
          style={{ fontSize: '120px' }}
        >
          {Utility.stringToInitials(organization.name)[0]}
        </Avatar>
      </Flex>

      <Form
        form={form}
        initialValues={organization}
        onFinish={handleSubmit}
        layout="vertical"
        requiredMark={false}
      >
        <Form.Item
          name="name"
          label="Name"
          rules={[{ required: true, message: 'Name is required' }]}
        >
          <Input />
        </Form.Item>

        <Form.Item label="Picture" name="pictureUrl">
          <Input />
        </Form.Item>

        <Form.Item>
          <Flex justify="end">
            <Button type="primary" htmlType="submit" loading={isLoadingUpdate}>
              Save
            </Button>
          </Flex>
        </Form.Item>
      </Form>

      {checkOrganizationRole('owner') && (
        <Flex justify="end" style={{ paddingTop: '100px' }}>
          <Popconfirm
            title="Are you sure?"
            okText="Yes, delete"
            cancelText="Cancel"
            placement="topRight"
            okButtonProps={{ danger: true, loading: isLoadingDelete }}
            onConfirm={handleClickDelete}
          >
            <Button type="text" size="small" danger loading={isLoadingDelete}>
              Delete Organization
            </Button>
          </Popconfirm>
        </Flex>
      )}
    </PageLayout>
  )
}

================
File: src/app/(authenticated)/organizations/[organizationId]/users/page.tsx
================
'use client'

import { useState } from 'react'
import { Prisma } from '@prisma/client'
import {
  Typography,
  Table,
  Button,
  Modal,
  Input,
  Space,
  Popconfirm,
} from 'antd'
import { UserAddOutlined, DeleteOutlined } from '@ant-design/icons'
const { Title, Paragraph } = Typography
import { useUserContext } from '@/core/context'
import { useRouter, useParams } from 'next/navigation'
import { useUploadPublic } from '@/core/hooks/upload'
import { useSnackbar } from 'notistack'
import dayjs from 'dayjs'
import { Api } from '@/core/trpc'
import { PageLayout } from '@/designSystem/layouts/Page.layout'

export default function UserManagementPage() {
  const router = useRouter()
  const params = useParams<any>()
  const { user } = useUserContext()
  const { enqueueSnackbar } = useSnackbar()

  const [isModalVisible, setIsModalVisible] = useState(false)
  const [newUserEmail, setNewUserEmail] = useState('')

  const { data: users, isLoading, refetch } = Api.user.findMany.useQuery({})

  const { mutateAsync: createUser } = Api.user.create.useMutation()
  const { mutateAsync: deleteUser } = Api.user.delete.useMutation()

  const handleInviteUser = async () => {
    try {
      await createUser({ data: { email: newUserEmail, status: 'INVITED' } })

      enqueueSnackbar('User invited successfully', { variant: 'success' })
      refetch()
      setIsModalVisible(false)
      setNewUserEmail('')
    } catch (error) {
      enqueueSnackbar('Failed to invite user', { variant: 'error' })
    }
  }

  const handleRemoveUser = async (userId: string) => {
    try {
      await deleteUser({ where: { id: userId } })
      enqueueSnackbar('User removed successfully', { variant: 'success' })
      refetch()
    } catch (error) {
      enqueueSnackbar('Failed to remove user', { variant: 'error' })
    }
  }

  const columns = [
    {
      title: 'Name',
      dataIndex: 'name',
      key: 'name',
    },
    {
      title: 'Email',
      dataIndex: 'email',
      key: 'email',
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (text: any, record: any) => (
        <Space size="middle">
          <Popconfirm
            title="Are you sure to delete this user?"
            onConfirm={() => handleRemoveUser(record.id)}
            okText="Yes"
            cancelText="No"
          >
            <Button type="primary" danger icon={<DeleteOutlined />}>
              Remove
            </Button>
          </Popconfirm>
        </Space>
      ),
    },
  ]

  return (
    <PageLayout layout="narrow">
      <Title level={2}>User Management</Title>
      <Paragraph>
        As an admin, you can view, invite, and remove users in the workspace.
      </Paragraph>
      <Button
        type="primary"
        icon={<UserAddOutlined />}
        onClick={() => setIsModalVisible(true)}
      >
        Invite User
      </Button>
      <Table
        dataSource={users}
        columns={columns}
        rowKey="id"
        loading={isLoading}
        style={{ marginTop: 20 }}
      />
      <Modal
        title="Invite New User"
        visible={isModalVisible}
        onOk={handleInviteUser}
        onCancel={() => setIsModalVisible(false)}
      >
        <Input
          placeholder="Enter user email"
          value={newUserEmail}
          onChange={e => setNewUserEmail(e.target.value)}
        />
      </Modal>
    </PageLayout>
  )
}

================
File: src/app/(authenticated)/organizations/[organizationId]/layout.tsx
================
'use client'

import { useUserContext } from '@/core/context'
import { MrbSplashScreen } from '@/designSystem'
import { ReactNode, useEffect } from 'react'

type Props = { children: ReactNode }

export default function OrganizationsLayout({ children }: Props) {
  const { isLoadingOrganization, organization } = useUserContext()

  useEffect(() => {
    if (!isLoadingOrganization && !organization) {
      window.location.replace('/')
    }
  }, [isLoadingOrganization, organization])

  if (isLoadingOrganization) {
    return <MrbSplashScreen />
  }

  if (organization) {
    return <>{children}</>
  }
}

================
File: src/app/(authenticated)/organizations/[organizationId]/page.tsx
================
'use client'

import { useUserContext } from '@/core/context'
import { MrbSplashScreen } from '@/designSystem'
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'

export default function OrganizationPage() {
  const router = useRouter()

  const { organization } = useUserContext()

  useEffect(() => {
    if (organization) {
      router.push(`/organizations/${organization.id}/members`)
    }
  }, [organization])

  return <MrbSplashScreen />
}

================
File: src/app/(authenticated)/profile/page.tsx
================
'use client'

import { Avatar, Button, Flex, Form, Input, Typography } from 'antd'

import { useUserContext } from '@/core/context'
import { Utility } from '@/core/helpers/utility'
import { Api } from '@/core/trpc'
import { PageLayout } from '@/designSystem'
import { User } from '@prisma/client'
import { signOut } from 'next-auth/react'
import { useSnackbar } from 'notistack'
import { useEffect, useState } from 'react'

export default function ProfilePage() {
  const { enqueueSnackbar } = useSnackbar()

  const { user, refetch: refetchUser } = useUserContext()

  const [form] = Form.useForm()

  const [isLoading, setLoading] = useState(false)
  const [isLoadingLogout, setLoadingLogout] = useState(false)

  const { mutateAsync: updateUser } = Api.user.update.useMutation()

  useEffect(() => {
    form.setFieldsValue(user)
  }, [user])

  const handleSubmit = async (values: Partial<User>) => {
    setLoading(true)

    try {
      await updateUser({
        where: { id: user.id },
        data: {
          email: values.email,
          name: values.name,
          pictureUrl: values.pictureUrl,
        },
      })

      refetchUser()
    } catch (error) {
      enqueueSnackbar(`Could not save user: ${error.message}`, {
        variant: 'error',
      })
    }

    setLoading(false)
  }

  const handleClickLogout = async () => {
    setLoadingLogout(true)

    try {
      await signOut({ callbackUrl: '/login' })
    } catch (error) {
      enqueueSnackbar(`Could not logout: ${error.message}`, {
        variant: 'error',
      })

      setLoadingLogout(false)
    }
  }

  return (
    <PageLayout layout="super-narrow">
      <Flex justify="space-between" align="center">
        <Typography.Title level={1}>Profile</Typography.Title>
        <Button onClick={handleClickLogout} loading={isLoadingLogout}>
          Logout
        </Button>
      </Flex>

      <Flex justify="center" style={{ marginBottom: '30px' }}>
        <Avatar size={80} src={user.pictureUrl}>
          {Utility.stringToInitials(user.name)}
        </Avatar>
      </Flex>

      <Form
        form={form}
        initialValues={user}
        onFinish={handleSubmit}
        layout="vertical"
        requiredMark={false}
      >
        <Form.Item
          name="name"
          label="Name"
          rules={[{ required: true, message: 'Name is required' }]}
        >
          <Input />
        </Form.Item>

        <Form.Item
          label="Email"
          name="email"
          rules={[{ required: true, message: 'Email is required' }]}
        >
          <Input type="email" placeholder="Your email" autoComplete="email" />
        </Form.Item>

        <Form.Item label="Profile picture" name="pictureUrl">
          <Input />
        </Form.Item>

        <Form.Item>
          <Flex justify="end">
            <Button type="primary" htmlType="submit" loading={isLoading}>
              Save
            </Button>
          </Flex>
        </Form.Item>
      </Form>
    </PageLayout>
  )
}

================
File: src/app/(authenticated)/layout.tsx
================
'use client'

import { useUserContext } from '@/core/context'
import { MrbSplashScreen } from '@/designSystem'
import { NavigationLayout } from '@/designSystem/layouts/NavigationLayout'
import { useRouter } from 'next/navigation'
import { ReactNode, useEffect } from 'react'

type Props = { children: ReactNode }

export default function AuthenticatedLayout({ children }: Props) {
  const { isLoggedIn, isLoading } = useUserContext()

  const router = useRouter()

  useEffect(() => {
    if (!isLoading && !isLoggedIn) {
      router.push('/login')
    }
  }, [isLoading, isLoggedIn])

  if (isLoading) {
    return <MrbSplashScreen />
  }

  if (isLoggedIn) {
    return <NavigationLayout>{children}</NavigationLayout>
  }
}

================
File: src/app/(landing)/layout.tsx
================
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Welcome',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <>{children}</>
}

================
File: src/app/(landing)/page.tsx
================
'use client'
import { LandingCTA } from '@/designSystem/landing/LandingCTA'
import { LandingContainer } from '@/designSystem/landing/LandingContainer'
import LandingFAQ from '@/designSystem/landing/LandingFAQ'
import { LandingFeatures } from '@/designSystem/landing/LandingFeatures'
import { LandingHero } from '@/designSystem/landing/LandingHero'
import { LandingHowItWorks } from '@/designSystem/landing/LandingHowItWorks'
import { LandingPainPoints } from '@/designSystem/landing/LandingPainPoints'
import { LandingPricing } from '@/designSystem/landing/LandingPricing'
import { LandingSocialProof } from '@/designSystem/landing/LandingSocialProof'
import { LandingSocialRating } from '@/designSystem/landing/LandingSocialRating'
import { LandingTestimonials } from '@/designSystem/landing/LandingTestimonials'
import {
  ApiOutlined,
  BarChartOutlined,
  RobotOutlined,
  SafetyOutlined,
  SettingOutlined,
  UserOutlined,
} from '@ant-design/icons'

export default function LandingPage() {
  const features = [
    {
      heading: 'AI-Powered Responses',
      description:
        'Get instant, accurate answers to HR queries using advanced AI technology.',
      icon: <RobotOutlined />,
    },
    {
      heading: 'Multi-Platform Integration',
      description:
        'Seamlessly works with Slack, MS Teams, and email for universal access.',
      icon: <ApiOutlined />,
    },
    {
      heading: 'Customizable Workflows',
      description:
        'Create tailored HR processes and automate routine tasks effortlessly.',
      icon: <SettingOutlined />,
    },
    {
      heading: 'Data-Driven Insights',
      description:
        'Gain valuable HR analytics to make informed decisions and improve policies.',
      icon: <BarChartOutlined />,
    },
    {
      heading: 'Compliance Management',
      description:
        'Stay up-to-date with changing regulations and ensure policy adherence.',
      icon: <SafetyOutlined />,
    },
    {
      heading: 'Employee Self-Service',
      description:
        'Empower employees with easy access to HR information and request management.',
      icon: <UserOutlined />,
    },
  ]

  const testimonials = [
    {
      name: 'Sarah Johnson',
      designation: 'Chief People Officer',
      content:
        'Mel has transformed our HR department. The AI-powered responses have reduced query resolution time by 70%.',
      avatar: 'https://randomuser.me/api/portraits/women/28.jpg',
    },
    {
      name: 'Alex Chen',
      designation: 'Head of Talent Acquisition',
      content:
        'The customizable workflows in Mel have streamlined our onboarding process, saving us countless hours.',
      avatar: 'https://randomuser.me/api/portraits/men/32.jpg',
    },
    {
      name: 'Priya Patel',
      designation: 'Compliance Manager',
      content:
        "Mel's compliance management features keep us ahead of regulatory changes. It's been a game-changer for risk mitigation.",
      avatar: 'https://randomuser.me/api/portraits/women/44.jpg',
    },
    {
      name: 'Tom Baker',
      designation: 'Employee Experience Lead',
      content:
        'The self-service portal has empowered our employees and significantly reduced the load on our HR team.',
      avatar: 'https://randomuser.me/api/portraits/men/41.jpg',
    },
    {
      name: 'Maria Rodriguez',
      designation: 'HR Analytics Specialist',
      content:
        'The data-driven insights from Mel have allowed us to make informed decisions about our HR policies and practices.',
      avatar: 'https://randomuser.me/api/portraits/women/63.jpg',
    },
    {
      name: 'James Lee',
      designation: 'IT Director',
      content:
        'Integrating Mel with our existing systems was seamless. The multi-platform support is impressive.',
      avatar: 'https://randomuser.me/api/portraits/men/55.jpg',
    },
  ]

  const navItems = [
    {
      title: 'Features',
      link: '#features',
    },
    {
      title: 'Pricing',
      link: '#pricing',
    },
    {
      title: 'Testimonials',
      link: '#testimonials',
    },
  ]

  const packages = [
    {
      title: 'Starter',
      description: 'For small businesses',
      monthly: 19,
      yearly: 190,
      features: [
        'AI-Powered Responses',
        'Slack Integration',
        'Basic Analytics',
      ],
    },
    {
      title: 'Professional',
      description: 'For growing companies',
      monthly: 49,
      yearly: 490,
      features: [
        'All Starter Features',
        'MS Teams Integration',
        'Custom Workflows',
        'Advanced Analytics',
      ],
      highlight: true,
    },
    {
      title: 'Enterprise',
      description: 'For large organizations',
      monthly: 'Custom',
      yearly: 'Custom',
      features: [
        'All Professional Features',
        'Dedicated Account Manager',
        'Custom Integrations',
        'On-Premise Deployment Option',
      ],
    },
  ]

  const questionAnswers = [
    {
      question: "How accurate are Mel's AI-powered responses?",
      answer:
        "Mel's AI is trained on vast HR datasets and continuously learns from interactions, achieving over 95% accuracy in responses.",
    },
    {
      question: "Can Mel be customized for our company's specific policies?",
      answer:
        "Absolutely! Mel can be trained on your company's unique HR policies and procedures for tailored, accurate responses.",
    },
    {
      question: 'How does Mel ensure data security and privacy?',
      answer:
        'Mel employs bank-level encryption, regular security audits, and is fully GDPR and CCPA compliant to protect your sensitive HR data.',
    },
    {
      question: 'What kind of analytics does Mel provide?',
      answer:
        'Mel offers comprehensive analytics including query trends, response times, employee satisfaction metrics, and custom reports to drive HR insights.',
    },
    {
      question: 'How often is Mel updated with new features?',
      answer:
        'We release major updates quarterly, with minor improvements and bug fixes rolled out continuously based on user feedback and industry trends.',
    },
  ]

  const logos = [
    { url: 'https://i.imgur.com/afwBIFK.png' },
    { url: 'https://i.imgur.com/LlloOPa.png' },
    { url: 'https://i.imgur.com/j8jPb4H.png' },
    { url: 'https://i.imgur.com/mJ1sZFv.png' },
  ]

  const steps = [
    {
      heading: 'Sign Up',
      description: 'Create your Mel account and choose your plan.',
    },
    {
      heading: 'Configure',
      description: 'Set up your HR knowledge base and customize workflows.',
    },
    {
      heading: 'Integrate',
      description: 'Connect Mel with your existing communication platforms.',
    },
    {
      heading: 'Train',
      description: "Provide company-specific information to enhance Mel's AI.",
    },
    {
      heading: 'Launch',
      description:
        'Introduce Mel to your team and start revolutionizing your HR processes.',
    },
  ]

  const painPoints = [
    {
      emoji: '',
      title: 'Time-Consuming HR Processes',
    },
    {
      emoji: '',
      title: 'Employee Dissatisfaction',
    },
    {
      emoji: '',
      title: 'Inefficient Resource Allocation',
    },
    {
      emoji: '',
      title: 'Inconsistent Policy Implementation',
    },
    {
      emoji: '',
      title: 'Lack of Actionable HR Insights',
    },
  ]

  const avatarItems = [
    {
      src: 'https://randomuser.me/api/portraits/men/51.jpg',
    },
    {
      src: 'https://randomuser.me/api/portraits/women/9.jpg',
    },
    {
      src: 'https://randomuser.me/api/portraits/women/52.jpg',
    },
    {
      src: 'https://randomuser.me/api/portraits/men/5.jpg',
    },
    {
      src: 'https://randomuser.me/api/portraits/men/4.jpg',
    },
  ]

  return (
    <LandingContainer navItems={navItems}>
      <LandingHero
        title="Transform Your HR with AI-Powered Mel"
        subtitle="Streamline Processes, Boost Efficiency, and Enhance Employee Experience"
        buttonText="Start Free Trial"
        pictureUrl="https://marblism-dashboard-api--production-public.s3.us-west-1.amazonaws.com/cmu2QU-melthehr-gwAm"
        socialProof={
          <LandingSocialRating
            avatarItems={avatarItems}
            numberOfUsers={10000}
            suffixText="satisfied users worldwide"
          />
        }
      />
      <LandingSocialProof logos={logos} title="Trusted By" />
      <LandingPainPoints
        title="Common HR Challenges Solved by Mel"
        painPoints={painPoints}
      />
      <LandingFeatures
        id="features"
        title="Revolutionize Your HR Operations"
        subtitle="Harness the Power of AI to Transform Your Workplace"
        features={features}
      />
      <LandingHowItWorks title="Getting Started with Mel" steps={steps} />
      <LandingTestimonials
        id="testimonials"
        title="Success Stories from HR Leaders"
        subtitle="See How Mel is Transforming HR Departments Worldwide"
        testimonials={testimonials}
      />
      <LandingPricing
        id="pricing"
        title="Choose the Perfect Plan for Your Team"
        subtitle="Scalable Solutions for Businesses of All Sizes"
        packages={packages}
      />
      <LandingFAQ
        id="faq"
        title="Frequently Asked Questions"
        subtitle="Everything You Need to Know About Mel"
        questionAnswers={questionAnswers}
      />
      <LandingCTA
        title="Ready to Revolutionize Your HR?"
        subtitle="Join thousands of companies already benefiting from Mel"
        buttonText="Start Free Trial"
        buttonLink="/register"
      />
    </LandingContainer>
  )
}

================
File: src/app/(non-authenticated)/login/page.tsx
================
'use client'

import { Configuration } from '@/core/configuration'
import { AppHeader } from '@/designSystem/ui/AppHeader'
import { Button, Flex, Form, Input, Typography } from 'antd'
import { signIn } from 'next-auth/react'
import { useRouter, useSearchParams } from 'next/navigation'
import { useSnackbar } from 'notistack'
import { useEffect, useState } from 'react'

export default function LoginPage() {
  const router = useRouter()
  const { enqueueSnackbar } = useSnackbar()

  const searchParams = useSearchParams()

  const [isLoading, setLoading] = useState(false)

  const [form] = Form.useForm()

  const errorKey = searchParams.get('error')

  const errorMessage = {
    Signin: 'Try signing in with a different account.',
    OAuthSignin: 'Try signing in with a different account.',
    OAuthCallback: 'Try signing in with a different account.',
    OAuthCreateAccount: 'Try signing in with a different account.',
    EmailCreateAccount: 'Try signing in with a different account.',
    Callback: 'Try signing in with a different account.',
    OAuthAccountNotLinked:
      'To confirm your identity, sign in with the same account you used originally.',
    EmailSignin: 'Check your email address.',
    CredentialsSignin:
      'Sign in failed. Check the details you provided are correct.',
    default: 'Unable to sign in.',
  }[errorKey ?? 'default']

  useEffect(() => {
    if (Configuration.isDevelopment()) {
      form.setFieldValue('email', 'test@test.com')
      form.setFieldValue('password', 'password')
    }
  }, [])

  const handleSubmit = async (values: any) => {
    setLoading(true)

    try {
      await signIn('credentials', {
        email: values.email,
        password: values.password,
        callbackUrl: '/home',
      })
    } catch (error) {
      enqueueSnackbar(`Could not login: ${error.message}`, { variant: 'error' })

      setLoading(false)
    }
  }

  return (
    <Flex align="center" justify="center" vertical flex={1}>
      <Flex
        vertical
        style={{
          width: '340px',
          paddingBottom: '100px',
          paddingTop: '100px',
        }}
        gap="middle"
      >
        <AppHeader description="Welcome!" />

        {errorKey && (
          <Typography.Text type="danger">{errorMessage}</Typography.Text>
        )}

        <Form
          form={form}
          onFinish={handleSubmit}
          layout="vertical"
          requiredMark={false}
        >
          <Form.Item
            label="Email"
            name="email"
            rules={[{ required: true, message: 'Email is required' }]}
          >
            <Input type="email" placeholder="Your email" autoComplete="email" />
          </Form.Item>

          <Form.Item
            label="Password"
            name="password"
            rules={[{ required: true, message: 'Password is required' }]}
          >
            <Input.Password
              type="password"
              placeholder="Your password"
              autoComplete="current-password"
            />
          </Form.Item>

          <Form.Item>
            <Flex justify="end">
              <Button
                type="link"
                onClick={() => router.push('/reset-password')}
                style={{ padding: 0, margin: 0 }}
              >
                Forgot password?
              </Button>
            </Flex>
          </Form.Item>

          <Form.Item>
            <Button type="primary" htmlType="submit" block loading={isLoading}>
              Sign in
            </Button>
          </Form.Item>
        </Form>

        <Button
          ghost
          style={{ border: 'none' }}
          onClick={() => router.push('/register')}
        >
          <Flex gap={'small'} justify="center">
            <Typography.Text type="secondary">No account?</Typography.Text>{' '}
            <Typography.Text>Sign up</Typography.Text>
          </Flex>
        </Button>
      </Flex>
    </Flex>
  )
}

================
File: src/app/(non-authenticated)/register/page.tsx
================
'use client'
import { Utility } from '@/core/helpers/utility'
import { Api } from '@/core/trpc'
import { AppHeader } from '@/designSystem/ui/AppHeader'
import { User } from '@prisma/client'
import { Button, Flex, Form, Input, Typography } from 'antd'
import { signIn } from 'next-auth/react'
import { useRouter, useSearchParams } from 'next/navigation'
import { useSnackbar } from 'notistack'
import { useEffect, useState } from 'react'

export default function RegisterPage() {
  const router = useRouter()
  const { enqueueSnackbar } = useSnackbar()
  const searchParams = useSearchParams()

  const [form] = Form.useForm()

  const [isLoading, setLoading] = useState(false)

  const { mutateAsync: registerUser } =
    Api.authentication.register.useMutation()

  useEffect(() => {
    const email = searchParams.get('email')?.trim()

    if (Utility.isDefined(email)) {
      form.setFieldsValue({ email })
    }
  }, [searchParams])

  const handleSubmit = async (values: Partial<User>) => {
    setLoading(true)

    try {
      const tokenInvitation = searchParams.get('tokenInvitation') ?? undefined

      await registerUser({ ...values, tokenInvitation })

      signIn('credentials', {
        ...values,
        callbackUrl: '/home',
      })
    } catch (error) {
      enqueueSnackbar(`Could not signup: ${error.message}`, {
        variant: 'error',
      })

      setLoading(false)
    }
  }

  return (
    <Flex align="center" justify="center" vertical flex={1}>
      <Flex
        vertical
        style={{
          width: '340px',
          paddingBottom: '100px',
          paddingTop: '100px',
        }}
        gap="middle"
      >
        <AppHeader description="Welcome!" />

        <Form
          form={form}
          onFinish={handleSubmit}
          layout="vertical"
          autoComplete="off"
          requiredMark={false}
        >
          <Form.Item
            label="Email"
            name="email"
            rules={[{ required: true, message: 'Email is required' }]}
          >
            <Input type="email" placeholder="Your email" autoComplete="email" />
          </Form.Item>
          <Form.Item
            name="name"
            rules={[{ required: true, message: 'Name is required' }]}
            label="Name"
          >
            <Input placeholder="Your name" />
          </Form.Item>

          <Form.Item
            label="Password"
            name="password"
            rules={[{ required: true, message: 'Password is required' }]}
          >
            <Input.Password
              type="password"
              placeholder="Your password"
              autoComplete="current-password"
            />
          </Form.Item>

          <Form.Item>
            <Button type="primary" htmlType="submit" loading={isLoading} block>
              Register
            </Button>
          </Form.Item>
        </Form>

        <Button
          ghost
          style={{ border: 'none' }}
          onClick={() => router.push('/login')}
        >
          <Flex gap={'small'} justify="center">
            <Typography.Text type="secondary">Have an account?</Typography.Text>{' '}
            <Typography.Text>Sign in</Typography.Text>
          </Flex>
        </Button>
      </Flex>
    </Flex>
  )
}

================
File: src/app/(non-authenticated)/reset-password/[token]/page.tsx
================
'use client'
import { Api } from '@/core/trpc'
import { AppHeader } from '@/designSystem/ui/AppHeader'
import { Alert, Button, Flex, Form, Input, Typography } from 'antd'
import { useParams, useRouter } from 'next/navigation'
import { useSnackbar } from 'notistack'

const { Text } = Typography

export default function ResetPasswordTokenPage() {
  const router = useRouter()

  const { enqueueSnackbar } = useSnackbar()

  const { token } = useParams<{ token: string }>()

  const [form] = Form.useForm()

  const {
    mutateAsync: resetPassword,
    isLoading,
    isSuccess,
  } = Api.authentication.resetPassword.useMutation()

  const handleSubmit = async (values: any) => {
    try {
      await resetPassword({ token, password: values.password })
    } catch (error) {
      enqueueSnackbar(`Could not reset password: ${error.message}`, {
        variant: 'error',
      })
    }
  }

  return (
    <>
      <Flex align="center" justify="center" vertical flex={1}>
        <Flex
          vertical
          style={{
            width: '340px',
            paddingBottom: '100px',
            paddingTop: '100px',
          }}
          gap="middle"
        >
          <AppHeader description="Change your password" />

          {isSuccess && (
            <Alert
              style={{ textAlign: 'center' }}
              type="success"
              message="Your password has been changed."
            />
          )}

          {!isSuccess && (
            <Form
              form={form}
              onFinish={handleSubmit}
              layout="vertical"
              requiredMark={false}
            >
              <Form.Item
                label="Password"
                name="password"
                rules={[{ required: true, message: 'Password is required' }]}
              >
                <Input.Password
                  type="password"
                  placeholder="Your new password"
                  autoComplete="current-password"
                />
              </Form.Item>

              <Form.Item
                label="Password confirmation"
                name="passwordConfirmation"
                rules={[
                  {
                    required: true,
                    message: 'Password confirmation is required',
                  },
                ]}
              >
                <Input.Password
                  type="password"
                  placeholder="Password confirmation"
                  autoComplete="current-password"
                />
              </Form.Item>
              <Form.Item>
                <Button
                  type="primary"
                  htmlType="submit"
                  loading={isLoading}
                  block
                >
                  Reset Password
                </Button>
              </Form.Item>
            </Form>
          )}

          <Flex justify="center" align="center">
            <Button
              ghost
              style={{ border: 'none' }}
              onClick={() => router.push('/login')}
            >
              <Flex gap={'small'} justify="center">
                <Text>Sign in</Text>
              </Flex>
            </Button>

            <Text type="secondary">or</Text>

            <Button
              ghost
              style={{ border: 'none' }}
              onClick={() => router.push('/register')}
            >
              <Flex gap={'small'} justify="center">
                <Text>Sign up</Text>
              </Flex>
            </Button>
          </Flex>
        </Flex>
      </Flex>
    </>
  )
}

================
File: src/app/(non-authenticated)/reset-password/page.tsx
================
'use client'
import { Api } from '@/core/trpc'
import { AppHeader } from '@/designSystem/ui/AppHeader'
import { Alert, Button, Flex, Form, Input, Typography } from 'antd'
import { useRouter } from 'next/navigation'
import { useSnackbar } from 'notistack'
import { useState } from 'react'

const { Text } = Typography

export default function ResetPasswordPage() {
  const router = useRouter()

  const { enqueueSnackbar } = useSnackbar()

  const [email, setEmail] = useState<string>()

  const [form] = Form.useForm()

  const {
    mutateAsync: resetPassword,
    isLoading,
    isSuccess,
  } = Api.authentication.sendResetPasswordEmail.useMutation()

  const handleSubmit = async (values: any) => {
    try {
      setEmail(values.email)

      await resetPassword({ email: values.email })
    } catch (error) {
      enqueueSnackbar(`Could not reset password: ${error}`, {
        variant: 'error',
      })
    }
  }

  return (
    <Flex align="center" justify="center" vertical flex={1}>
      <Flex
        vertical
        style={{
          width: '340px',
          paddingBottom: '100px',
          paddingTop: '100px',
        }}
        gap="middle"
      >
        <AppHeader description="You will receive a link" />

        {isSuccess && (
          <Alert
            style={{ textAlign: 'center' }}
            message={`We sent an email to ${email} with a link to reset your password`}
            type="success"
          />
        )}

        {!isSuccess && (
          <>
            <Form
              form={form}
              onFinish={handleSubmit}
              layout="vertical"
              requiredMark={false}
            >
              <Form.Item
                label="Email"
                name="email"
                rules={[{ required: true, message: 'Email is required' }]}
              >
                <Input
                  type="email"
                  placeholder="Your email"
                  autoComplete="email"
                />
              </Form.Item>
              <Form.Item>
                <Button
                  type="primary"
                  htmlType="submit"
                  loading={isLoading}
                  block
                >
                  Reset Password
                </Button>
              </Form.Item>
            </Form>
          </>
        )}

        <Flex justify="center" align="center">
          <Button
            ghost
            style={{ border: 'none' }}
            onClick={() => router.push('/login')}
          >
            <Flex gap={'small'} justify="center">
              <Text>Sign in</Text>
            </Flex>
          </Button>

          <Text type="secondary">or</Text>

          <Button
            ghost
            style={{ border: 'none' }}
            onClick={() => router.push('/register')}
          >
            <Flex gap={'small'} justify="center">
              <Text>Sign up</Text>
            </Flex>
          </Button>
        </Flex>
      </Flex>
    </Flex>
  )
}

================
File: src/app/(non-authenticated)/layout.tsx
================
import { ReactNode } from 'react'

type Props = {
  children: ReactNode
}

export default function LoginLayout({ children }: Props) {
  return <>{children}</>
}

================
File: src/app/api/auth/[...nextauth]/route.ts
================
import { Authentication } from '@/core/authentication'
import NextAuth from 'next-auth'

const handler = NextAuth(Authentication.options)

export { handler as GET, handler as POST }

================
File: src/app/api/billing/webhook/stripe/route.ts
================
import { Database } from '@/core/database'
import { Utility } from '@/core/helpers/utility'
import { PaymentService } from '@/server/libraries/payment'
import { User } from '@prisma/client'

import { Organization } from '@prisma/client'

import { headers } from 'next/headers'
import { NextRequest, NextResponse } from 'next/server'

export async function POST(req: NextRequest, res: NextResponse) {
  try {
    console.log('Stripe webhook received')

    if (!PaymentService.isActive()) {
      return new NextResponse(`Stripe not activated`, {
        status: 400,
      })
    }

    const sig = headers().get('Stripe-Signature') as string

    const text = await req.text()

    const buffer = Buffer.from(text)

    const data = await PaymentService.onPayment(buffer, sig)

    if (Utility.isNull(data)) {
      return new NextResponse(`Could not parse request body`, {
        status: 200,
      })
    }

    const {
      userId,
      stripeCustomerId,

      organizationId,
    } = data

    let user: User

    let organization: Organization

    if (organizationId && stripeCustomerId) {
      organization =
        await Database.getUnprotected().organization.findFirstOrThrow({
          where: { id: organizationId, stripeCustomerId },
        })
    } else if (organizationId) {
      organization =
        await Database.getUnprotected().organization.findFirstOrThrow({
          where: { id: organizationId },
        })
    } else if (stripeCustomerId) {
      organization =
        await Database.getUnprotected().organization.findFirstOrThrow({
          where: { stripeCustomerId },
        })
    }

    if (userId && stripeCustomerId && !organizationId) {
      user = await Database.getUnprotected().user.findFirstOrThrow({
        where: { id: userId, stripeCustomerId },
      })
    } else if (userId) {
      user = await Database.getUnprotected().user.findFirstOrThrow({
        where: { id: userId },
      })
    } else if (stripeCustomerId && !organizationId) {
      user = await Database.getUnprotected().user.findFirstOrThrow({
        where: { stripeCustomerId },
      })
    }

    if (!user) {
      return new NextResponse(
        `Could find any user with userId (${userId}) and customerId (${stripeCustomerId})`,
        {
          status: 404,
        },
      )
    }

    if (!organization && organizationId) {
      return new NextResponse(
        `Could find any organization with organizationId (${organizationId}) and customerId (${stripeCustomerId})`,
        {
          status: 404,
        },
      )
    }

    if (!user.stripeCustomerId && !organization) {
      user = await Database.getUnprotected().user.update({
        where: { id: user.id },
        data: { stripeCustomerId: stripeCustomerId },
      })

      console.log(
        `Stripe customer id "${stripeCustomerId}" saved on user "${user.id}"`,
      )
    }

    if (organization && !organization.stripeCustomerId) {
      organization = await Database.getUnprotected().organization.update({
        where: { id: organization.id },
        data: { stripeCustomerId: stripeCustomerId },
      })

      console.log(
        `Stripe customer id "${stripeCustomerId}" saved on organization "${organization.id}"`,
      )
    }

    // Add your custom logic here

    return new NextResponse(`Webhook successful`, {
      status: 200,
    })
  } catch (error: any) {
    console.error('Could not handle Stripe webhook')
    console.error(error)
    return new NextResponse(`Unknown error: ${error.message}`, {
      status: 500,
    })
  }
}

================
File: src/app/api/trpc/[trpc]/route.ts
================
import { Configuration } from '@/core/configuration'
import { Trpc } from '@/core/trpc/server'
import { Server } from '@/server'
import { fetchRequestHandler } from '@trpc/server/adapters/fetch'
import { type NextRequest } from 'next/server'

const handler = (req: NextRequest) =>
  fetchRequestHandler({
    endpoint: '/api/trpc',
    req,
    router: Server.appRouter,
    createContext: () => Trpc.createContext({ req }),
    onError: Configuration.isDevelopment
      ? ({ path, error }) => {
          console.error(
            ` tRPC failed on ${path ?? '<no-path>'}: ${error.message}`,
          )
        }
      : undefined,
  })

export { handler as GET, handler as POST }

================
File: src/app/api/upload/private/route.ts
================
import { Authentication } from '@/core/authentication'
import { UploadFileType, UploadService } from '@/server/libraries/upload'
import { NextRequest, NextResponse } from 'next/server'
import { zfd } from 'zod-form-data'

export async function POST(request: NextRequest, response: NextResponse) {
  const session = await Authentication.getSession()

  if (!session?.user) {
    return NextResponse.error()
  }

  const schema = zfd.formData({
    file: zfd.file(),
  })

  try {
    const formData = await request.formData()

    const data = schema.parse({
      file: formData.get('file'),
    })

    const arrayBuffer = await data.file.arrayBuffer()

    const file: UploadFileType = {
      name: data.file.name,
      mimetype: data.file.type,
      buffer: Buffer.from(arrayBuffer),
    }

    const urls = await UploadService.uploadPrivate(file)

    return NextResponse.json(urls?.[0])
  } catch (error) {
    console.log(error)
    return NextResponse.error()
  }
}

================
File: src/app/api/upload/public/route.ts
================
import { Authentication } from '@/core/authentication'
import { UploadFileType, UploadService } from '@/server/libraries/upload'
import { NextRequest, NextResponse } from 'next/server'
import { zfd } from 'zod-form-data'

export async function POST(request: NextRequest, response: NextResponse) {
  const session = await Authentication.getSession()

  if (!session?.user) {
    return new NextResponse('User not logged in', {
      status: 401,
    })
  }

  const schema = zfd.formData({
    file: zfd.file(),
  })

  try {
    const formData = await request.formData()

    const data = schema.parse({
      file: formData.get('file'),
    })

    const arrayBuffer = await data.file.arrayBuffer()

    const file: UploadFileType = {
      name: data.file.name,
      mimetype: data.file.type,
      buffer: Buffer.from(arrayBuffer),
    }
    const urls = await UploadService.uploadPublic(file)

    return NextResponse.json(urls?.[0])
  } catch (error) {
    console.log(error)
    return NextResponse.error()
  }
}

================
File: src/app/layout.tsx
================
'use client'

import { WorkspaceProvider } from '@/.marblism/workspace'
import { AnalyticsProvider } from '@/core/analytics'
import { UserProvider } from '@/core/context'
import { TRPCProvider } from '@/core/trpc'
import { DesignSystemProvider } from '@/designSystem'
import { SessionProvider } from 'next-auth/react'

type Props = { children: React.ReactNode }

export default function RootLayout({ children }: Props) {
  return (
    <DesignSystemProvider>
      <SessionProvider>
        <TRPCProvider>
          <AnalyticsProvider>
            <WorkspaceProvider>
              <UserProvider>{children}</UserProvider>
            </WorkspaceProvider>
          </AnalyticsProvider>
        </TRPCProvider>
      </SessionProvider>
    </DesignSystemProvider>
  )
}

================
File: src/app/not-found.tsx
================
'use client'

import { Skeleton } from 'antd'
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'

export default function NotFound() {
  const router = useRouter()

  useEffect(() => {
    router.push('/home')
  }, [])
  return <Skeleton />
}

================
File: src/core/analytics/internal/AnalyticsProvider.tsx
================
'use client'
import dynamic from 'next/dynamic'
import posthog from 'posthog-js'
import { PostHogProvider } from 'posthog-js/react'
import { ReactNode, useEffect } from 'react'
import { Configuration } from '../../configuration'
import { Api } from '../../trpc'

const PostHogPageView = dynamic(() => import('./PostHogPageView'), {
  ssr: false,
})

export function AnalyticsProvider({ children }: { children: ReactNode }) {
  const { data, isLoading } = Api.configuration.getPublic.useQuery()

  useEffect(() => {
    const isProduction = Configuration.isProduction()
    const canActivate =
      typeof window !== 'undefined' && !isLoading && data && isProduction

    if (canActivate) {
      const key = data['PUBLIC_POSTHOG_KEY']
      const host = data['PUBLIC_POSTHOG_HOST']

      try {
        posthog.init(key, {
          api_host: host,
          person_profiles: 'identified_only',
          capture_pageview: false,
        })
      } catch (error) {
        console.log(`Could not start analytics: ${error.message}`)
      }
    }
  }, [data, isLoading])

  return (
    <PostHogProvider client={posthog}>
      <PostHogPageView />
      {children}
    </PostHogProvider>
  )
}

================
File: src/core/analytics/internal/PostHogPageView.tsx
================
'use client'

import { usePathname, useSearchParams } from 'next/navigation'
import { usePostHog } from 'posthog-js/react'
import { useEffect } from 'react'

export default function PostHogPageView(): null {
  const pathname = usePathname()
  const searchParams = useSearchParams()
  const posthog = usePostHog()
  useEffect(() => {
    // Track pageviews
    if (pathname && posthog) {
      let url = window.origin + pathname
      if (searchParams.toString()) {
        url = url + `?${searchParams.toString()}`
      }
      posthog.capture('$pageview', {
        $current_url: url,
      })
    }
  }, [pathname, searchParams, posthog])

  return null
}

================
File: src/core/analytics/index.ts
================
export * from './internal/AnalyticsProvider'
export * from './internal/PostHogPageView'

================
File: src/core/authentication/index.ts
================
import { PrismaAdapter } from '@auth/prisma-adapter'
import type { PrismaClient, Role } from '@prisma/client'
import * as Bcrypt from 'bcryptjs'
import {
  CookiesOptions,
  getServerSession,
  type DefaultSession,
  type NextAuthOptions,
} from 'next-auth'
import { type Adapter } from 'next-auth/adapters'
import type { Provider } from 'next-auth/providers'
import CredentialsProvider from 'next-auth/providers/credentials'
import { DatabaseUnprotected } from '../database/internal/unprotected'

/**
 * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session`
 * object and keep type safety.
 *
 * @see https://next-auth.js.org/getting-started/typescript#module-augmentation
 */
declare module 'next-auth' {
  interface Session extends DefaultSession {
    user: {
      id: string
      roles: Role[] // Adjust the type to match your roles model
    } & DefaultSession['user']
  }
}

const providers: Provider[] = [
  CredentialsProvider({
    credentials: {
      email: { type: 'email' },
      password: { type: 'password' },
    },
    authorize: authorize(DatabaseUnprotected),
  }),
  /**
   * ...add more providers here.
   *
   * Most other providers require a bit more work than the Discord provider. For example, the
   * GitHub provider requires you to add the `refresh_token_expires_in` field to the Account
   * model. Refer to the NextAuth.js docs for the provider you want to use. Example:
   *
   * @see https://next-auth.js.org/providers/github
   */
]

const providerMap = providers.map(provider => {
  const isActive =
    provider?.options?.clientId || provider?.options?.clientSecret

  return { id: provider?.id, name: provider?.name, active: isActive }
})

const cookiePrefix = '__Secure-'

const isWorkspace = process.env.PUBLIC_MARBLISM_ENV === 'workspace'

const cookiesForWorkspace: Partial<CookiesOptions> = {
  sessionToken: {
    name: `__Secure-next-auth.session-token`,
    options: {
      httpOnly: true,
      sameSite: 'none',
      path: '/',
      secure: true,
    },
  },
  callbackUrl: {
    name: `__Secure-next-auth.callback-url`,
    options: {
      sameSite: 'none',
      path: '/',
      secure: true,
    },
  },
  csrfToken: {
    name: `__Host-next-auth.csrf-token`,
    options: {
      httpOnly: true,
      sameSite: 'none',
      path: '/',
      secure: true,
    },
  },
  pkceCodeVerifier: {
    name: `${cookiePrefix}next-auth.pkce.code_verifier`,
    options: {
      httpOnly: true,
      sameSite: 'none',
      path: '/',
      secure: true,
      maxAge: 900,
    },
  },
  state: {
    name: `${cookiePrefix}next-auth.state`,
    options: {
      httpOnly: true,
      sameSite: 'none',
      path: '/',
      secure: true,
      maxAge: 900,
    },
  },
  nonce: {
    name: `${cookiePrefix}next-auth.nonce`,
    options: {
      httpOnly: true,
      sameSite: 'none',
      path: '/',
      secure: true,
    },
  },
}

/**
 * Options for NextAuth.js used to configure adapters, providers, callbacks, etc.
 *
 * @see https://next-auth.js.org/configuration/options
 */
const options: NextAuthOptions = {
  session: {
    strategy: 'jwt',
  },
  callbacks: {
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.sub!

        const user = await DatabaseUnprotected.user.findUnique({
          where: { id: token.sub },
          include: {
            roles: true,
          },
        })

        if (user) {
          session.user.roles = user.roles
        }
      }
      return session
    },
  },
  adapter: PrismaAdapter(DatabaseUnprotected) as Adapter,
  providers: providers,
  pages: {
    signIn: '/login',
    signOut: '/profile',
  },
  cookies: isWorkspace ? cookiesForWorkspace : undefined,
}

function authorize(prisma: PrismaClient) {
  return async (
    credentials: Record<'email' | 'password', string> | undefined,
  ) => {
    if (!credentials) {
      throw new Error('Missing credentials')
    }

    if (!credentials.email) {
      throw new Error('"email" is required in credentials')
    }

    if (!credentials.password) {
      throw new Error('"password" is required in credentials')
    }

    const user = await prisma.user.findFirst({
      where: { email: credentials.email },
      select: { id: true, email: true, password: true },
    })

    if (!user?.password) {
      return null
    }

    // verify the input password with stored hash
    const isValid = await Bcrypt.compare(credentials.password, user.password)

    if (!isValid) {
      return null
    }

    return { id: user.id, email: user.email }
  }
}

/**
 * Wrapper for `getServerSession` so that you don't need to import the `authOptions` in every file.
 *
 * @see https://next-auth.js.org/configuration/nextjs
 */
const getServerAuthSession = () => getServerSession(options)

export const Authentication = {
  providers: providerMap,
  getSession: getServerAuthSession,
  options,
}

================
File: src/core/configuration/index.ts
================
const isDevelopment = () => process.env.NODE_ENV === 'development'
const isProduction = () => process.env.NODE_ENV === 'production'

const getBaseUrl = () => {
  const isServer = typeof window !== 'undefined'
  const baseUrl = process.env.NEXTAUTH_URL
  const port = process.env.PORT ?? 8099

  if (isServer) {
    return ''
  }

  if (baseUrl) {
    if (baseUrl.startsWith('http')) {
      return baseUrl
    } else {
      return `https://${baseUrl}`
    }
  }

  return `http://localhost:${port}`
}

const getAuthenticationSecret = () => {
  return process.env.NEXTAUTH_SECRET
}

export const Configuration = {
  isDevelopment,
  isProduction,
  getBaseUrl,
  getAuthenticationSecret,
}

================
File: src/core/context/internal/useOrganizationContext.tsx
================
import { Utility } from '@/core/helpers/utility'
import { Organization, OrganizationRole, User } from '@prisma/client'
import { useParams } from 'next/navigation'
import { useEffect, useState } from 'react'
import { Api } from '../../trpc'

type OrganizationWithRoles = Organization & { roles: OrganizationRole[] }
export interface OrganizationContextType {
  organization: OrganizationWithRoles
  organizationRoles: OrganizationRole[]
  organizations: Organization[]
  isLoadingOrganization: boolean
  checkOrganizationRole(name: string): boolean
  refetchOrganization(): void
  refetchOrganizations(): void
}

export const useOrganizationContext = (options: {
  user: User
}): OrganizationContextType => {
  const params = useParams<{ organizationId?: string }>()

  const [organization, setOrganization] = useState<OrganizationWithRoles>()
  const [isLoadingOrganization, setLoadingOrganization] = useState(true)
  const [isLoadingOrganizations, setLoadingOrganizations] = useState(true)

  const organizationRoles = organization?.roles ?? []
  const keyLocalStorage = `organizationId-${options.user?.id}`
  const organizationIdSaved =
    typeof window !== 'undefined' ? localStorage.getItem(keyLocalStorage) : null

  /* --------------------------------- QUERIES -------------------------------- */

  const { data: organizations, refetch: refetchOrganizations } =
    Api.organization.findMany.useQuery(
      {
        where: { roles: { some: { userId: options.user?.id } } },
        orderBy: { name: 'asc' },
      },
      { enabled: false, initialData: [] },
    )

  const organizationId =
    params.organizationId ??
    organization?.id ??
    organizationIdSaved ??
    organizations[0]?.id

  const { refetch: refetchOrganization } = Api.organization.findUnique.useQuery(
    {
      where: { id: organizationId },
      include: { roles: { where: { userId: options.user?.id } } },
    },
    {
      enabled: false,
      onSuccess(organization) {
        if (!organization) {
          window.location.replace('/home')
          localStorage.removeItem(keyLocalStorage)
        } else {
          setOrganization(organization)
          localStorage.setItem(keyLocalStorage, organization.id)
        }
      },
      onError() {
        setOrganization(null)
        localStorage.removeItem(keyLocalStorage)
      },
    },
  )

  /* --------------------------------- EFFECTS -------------------------------- */

  useEffect(() => {
    handleRefreshOrganizations()
  }, [options.user?.id])

  useEffect(() => {
    handleRefreshOrganization()
  }, [organizationId, options.user?.id])

  /* -------------------------------- HANDLERS -------------------------------- */

  const checkOrganizationRole = (roleName: string) => {
    return !!organizationRoles?.find(role => role.name === roleName)
  }

  const handleRefreshOrganizations = async () => {
    const canFetch = Utility.isDefined(options.user?.id)

    if (canFetch) {
      setLoadingOrganizations(true)
      await refetchOrganizations()
      setLoadingOrganizations(false)
    }
  }

  const handleRefreshOrganization = async () => {
    const canFetch =
      Utility.isDefined(organizationId) &&
      Utility.isDefined(options.user) &&
      organizationId !== organization?.id

    if (canFetch) {
      setLoadingOrganization(true)
      await refetchOrganization()
      setLoadingOrganization(false)
    }
  }

  return {
    organization,
    organizationRoles,
    organizations,
    refetchOrganization: handleRefreshOrganization,
    refetchOrganizations: handleRefreshOrganizations,
    checkOrganizationRole,
    isLoadingOrganization: isLoadingOrganizations || isLoadingOrganization,
  }
}

================
File: src/core/context/internal/useUserContext.tsx
================
import { Role, User } from '@prisma/client'
import { useSession } from 'next-auth/react'
import {
  ReactNode,
  createContext,
  useContext,
  useEffect,
  useState,
} from 'react'
import { Api } from '../../trpc'

import {
  OrganizationContextType,
  useOrganizationContext,
} from './useOrganizationContext'

/**
 * @provider useUserContext
 * @description A provider to get the relevant user context
 * @attribute {boolean} isLoggedIn - Wether the user is authenticated or not
 * @attribute {User} user - The user object. user.id to access the id for example
 * @attribute {(roleName: string) => boolean} checkOrganizationRole - Check if the logged user match the role name in the organization
 * @attribute {Organization} organization - The current organization of the user. You should use the organization id from the router params as much as possible but you can get the organization id from this object too.
 * @attribute {OrganizationRole[]} organizationRoles - The current organization roles (owner or member) of the user within the current organization
 * @attribute {Organizations} organizations - All the organizations of the user
 * @usage  add 'const { user, organization, organizations, organizationRoles, checkOrganizationRole } = useUserContext()' , then you can access the id, name, email like that 'const userId = user?.id'
 * @import import { useUserContext } from '@/core/context'
 */

type AuthenticationStatus = 'unauthenticated' | 'loading' | 'authenticated'

type UserWithRoles = User & { roles: Role[] }

interface UserContextType extends OrganizationContextType {
  user: UserWithRoles | null
  checkRole: (roleName: string) => boolean
  refetch: () => void
  authenticationStatus: AuthenticationStatus
  isLoggedIn: boolean
  isLoading: boolean
}

const UserContext = createContext<UserContextType>(undefined)

export const UserProvider = ({ children }: { children: ReactNode }) => {
  const { data, status } = useSession()

  const [user, setUser] = useState<UserWithRoles>(null)

  const organizationsData = useOrganizationContext({ user })

  const isLoggedIn = status === 'authenticated'

  const { refetch, isLoading: isLoadingUser } = Api.user.findFirst.useQuery(
    {
      where: { id: data?.user?.id },
      include: { roles: true },
    },
    {
      enabled: false,
      onSuccess: user => {
        setUser(user)
      },
    },
  )

  const checkRole = (roleName: string) => {
    return !!user?.roles?.find(role => role.name === roleName)
  }

  const isLoading =
    status === 'loading' || (status === 'authenticated' && isLoadingUser)

  useEffect(() => {
    if (status === 'authenticated') {
      refetch()
    }
  }, [status])

  return (
    <UserContext.Provider
      value={{
        user,
        checkRole,
        refetch,
        authenticationStatus: status,
        isLoggedIn,
        isLoading,

        ...organizationsData,
      }}
    >
      {children}
    </UserContext.Provider>
  )
}

export const useUserContext = (): UserContextType => {
  const context = useContext(UserContext)

  if (context === undefined) {
    throw new Error('useUserContext must be used within a UserProvider')
  }

  return context
}

================
File: src/core/context/index.tsx
================
export * from './internal/useUserContext'

================
File: src/core/database/internal/protected.ts
================
import { Authentication } from '@/core/authentication'
import { enhance } from '@zenstackhq/runtime'
import { DatabaseUnprotected } from './unprotected'

export async function getDatabaseProtected() {
  const session = await Authentication.getSession()

  return enhance(DatabaseUnprotected, { user: session?.user as any })
}

================
File: src/core/database/internal/unprotected.ts
================
import { Configuration } from '@/core/configuration'
import { PrismaClient } from '@prisma/client'

const createPrismaClient = () => {
  return new PrismaClient({
    log: Configuration.isDevelopment ? ['error', 'warn'] : ['error'],
  })
}

class Singleton {
  static prisma = createPrismaClient()
}

export const DatabaseUnprotected = Singleton.prisma

================
File: src/core/database/index.ts
================
import { getDatabaseProtected } from './internal/protected'
import { DatabaseUnprotected } from './internal/unprotected'

export const Database = {
  getUnprotected: () => DatabaseUnprotected,
  get: getDatabaseProtected,
}

================
File: src/core/helpers/date/index.ts
================
/**
 * @provider Dayjs
 * @description A library to transform the date from the models into other format
 * @usage `dayjs(date).format(format)`
 * @import import dayjs from 'dayjs'
 */

export namespace DateHelper {
  export function getNow(): Date {
    return new Date()
  }

  export function addMinutes(date: Date, minutes: number): Date {
    const dateUpdated = new Date(date.getTime())
    const seconds = minutes * 60
    const milliseconds = seconds * 1000

    dateUpdated.setTime(dateUpdated.getTime() + milliseconds)

    return dateUpdated
  }

  export function isBefore(dateBefore: Date, dateAfter: Date): boolean {
    return dateBefore < dateAfter
  }
}

================
File: src/core/helpers/file/index.ts
================
import * as fs from 'fs'
import * as os from 'os'
import * as Path from 'path'
import { join } from 'path'
import { Utility } from '../utility'

type FileType = 'pdf' | 'csv' | 'docx' | 'unknown'

export namespace FileHelper {
  export function getRoot(): string {
    return process.cwd()
  }

  export function findFileContent(path: string): string {
    return fs.readFileSync(path, 'utf-8')
  }

  export function writeFolder(path: string): void {
    fs.mkdirSync(path, { recursive: true })
  }

  export async function getFileBuffer(file: File): Promise<Buffer> {
    return Buffer.from(await file.arrayBuffer())
  }

  export function writeFile(path: string, content: string | Buffer): void {
    const pathFolder = path.split('/').slice(0, -1).join('/')

    writeFolder(pathFolder)

    return fs.writeFileSync(path, content)
  }

  export function joinPaths(...paths: string[]): string {
    return join(...paths)
  }

  export function createReadStream(path: string): fs.ReadStream {
    return fs.createReadStream(path)
  }

  export function buildTemporaryPath(path: string): string {
    const pathTemporary = Path.join(os.tmpdir(), 'marblism-tmp', path)
    return pathTemporary
  }

  export async function createReadStreamFromArrayBuffer(
    arrayBuffer: ArrayBuffer,
    filename: string,
  ) {
    const path = buildTemporaryPath(filename)

    const pathFolder = path.split('/').slice(0, -1).join('/')

    deleteFolder(pathFolder)

    writeFolder(pathFolder)

    fs.writeFileSync(path, Buffer.from(arrayBuffer))

    return fs.createReadStream(path)
  }

  export async function deleteFile(path: string): Promise<void> {
    fs.unlinkSync(path)
  }

  export function deleteFolder(path: string): void {
    try {
      fs.rmdirSync(path, { recursive: true })
    } catch (error) {
      // ignore
    }
  }

  export function getFileType(filename: string, buffer?: Buffer): FileType {
    if (filename.endsWith('.csv')) {
      return 'csv'
    }

    if (filename.endsWith('.pdf')) {
      return 'pdf'
    }

    if (filename.endsWith('.docx') || filename.endsWith('.doc')) {
      return 'docx'
    }

    if (Utility.isNull(buffer)) {
      return 'unknown'
    }

    const signatures = {
      pdf: [0x25, 0x50, 0x44, 0x46],
      docx: [0x50, 0x4b, 0x03, 0x04],
      csv: [0x22, 0x2c, 0x0a],
    }

    for (const [type, signature] of Object.entries(signatures)) {
      if (signature.every((byte, index) => buffer[index] === byte)) {
        return type as FileType
      }
    }

    return 'unknown'
  }
}

================
File: src/core/helpers/utility/index.ts
================
import { v4 as uuidv4 } from 'uuid'

export namespace Utility {
  export function sleep(milliseconds: number): Promise<void> {
    return new Promise(resolve => {
      setTimeout(() => {
        resolve()
      }, milliseconds)
    })
  }

  export function isNull(value: any): boolean {
    return (
      value === null ||
      value === undefined ||
      (typeof value === 'string' && value === '')
    )
  }

  export function getUUID(): string {
    return uuidv4()
  }

  export function isDefined(value: any): boolean {
    const isEmptyString = typeof value === 'string' && value === ''
    return value !== null && value !== undefined && !isEmptyString
  }

  export function openInNewTab(window: Window, url: string): void {
    window.open(url, '_blank')
  }

  export function sortByString<Type>(items: Type[], key: keyof Type): Type[] {
    return items.sort((a: Type, b: Type) =>
      (a[key] as string).localeCompare(b[key] as string),
    )
  }

  export function removeTrailingSlash(content: string): string {
    const REGEX_SLASH = /\/$/g

    return content.replace(REGEX_SLASH, '')
  }

  export function stringToInitials(content: string): string {
    if (isNull(content)) {
      return ''
    }

    const words = content.trim().split(' ')

    const isOneWord = words.length === 1

    if (isOneWord) {
      return words[0].slice(0, 2)?.toUpperCase()
    }

    return `${words[0][0]}${words[1][0]}`.toUpperCase()
  }
}

================
File: src/core/hooks/upload/index.tsx
================
import { useMutation } from '@tanstack/react-query'
import axios from 'axios'

/**
 * @provider UploadHooks
 * @description An Upload hooks to upload one file
 * @function {({options: {file: File}) => Promise<{url: string}>} upload - Hook to upload the File to the server and return the url of the uploaded file so you can then store it
 * @usage `const {mutateAsync: upload} = useUploadPublic(); await upload({file});`
 * @import import { useUploadPublic } from '@/core/hooks/upload'
 */

type Options = { file: File }

export const useUploadPrivate = () =>
  useMutation({
    mutationFn: async ({ file }: Options): Promise<{ url: string }> => {
      const formData = new FormData()
      formData.append('file', file, file.name)

      const response = await axios.post<{ url: string }>(
        '/api/upload/private',
        formData,
      )

      return response.data
    },
  })

export const useUploadPublic = () =>
  useMutation({
    mutationFn: async ({ file }: Options): Promise<{ url: string }> => {
      const formData = new FormData()
      formData.append('file', file, file.name)

      const response = await axios.post<{ url: string }>(
        '/api/upload/public',
        formData,
      )

      return response.data
    },
  })

================
File: src/core/trpc/internal/trpc.client.tsx
================
import { createTRPCReact } from '@/.marblism/api/client/react'
import { Configuration } from '@/core/configuration'
import { AppRouter } from '@/server'
import { loggerLink, unstable_httpBatchStreamLink } from '@trpc/client'
import { inferRouterInputs, inferRouterOutputs } from '@trpc/server'
import superjson from 'superjson'

export const Api = createTRPCReact<AppRouter>()

const transformer = superjson

export const createTrpcClient = () => {
  return Api.createClient({
    transformer,
    links: [
      loggerLink({
        enabled: op =>
          Configuration.isDevelopment() ||
          (op.direction === 'down' && op.result instanceof Error),
      }),
      unstable_httpBatchStreamLink({
        url: Configuration.getBaseUrl() + '/api/trpc',
        headers: options => {
          const headers = new Headers()
          headers.set('x-trpc-source', 'react')
          return Object.fromEntries(headers.entries())
        },
      }),
    ],
  })
}

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>

================
File: src/core/trpc/internal/trpc.server.ts
================
/**
 * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:
 * 1. You want to modify request context (see Part 1).
 * 2. You want to create a new middleware or type of procedure (see Part 3).
 *
 * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will
 * need to use are documented accordingly near the end.
 */

import { Authentication } from '@/core/authentication'
import { Database } from '@/core/database'
import { initTRPC, TRPCError } from '@trpc/server'
import { type NextRequest } from 'next/server'
import superjson from 'superjson'
import { ZodError } from 'zod'

/**
 * 1. CONTEXT
 *
 * This section defines the "contexts" that are available in the backend API.
 *
 * These allow you to access things when processing a request, like the database, the session, etc.
 */

interface CreateContextOptions {
  headers: Headers
}

/**
 * This helper generates the "internals" for a tRPC context. If you need to use it, you can export
 * it from here.
 *
 * Examples of things you may need it for:
 * - testing, so we don't have to mock Next.js' req/res
 * - tRPC's `createSSGHelpers`, where we don't have req/res
 *
 * @see https://create.t3.gg/en/usage/trpc#-serverapitrpcts
 */
const createContextInternal = async (options: CreateContextOptions) => {
  const session = await Authentication.getSession()

  const databaseUnprotected = Database.getUnprotected()

  const database = await Database.get()

  return {
    session,
    headers: options.headers,
    database,
    databaseUnprotected,
    prisma: database,
    masterPrisma: databaseUnprotected,
  }
}

/**
 * This is the actual context you will use in your router. It will be used to process every request
 * that goes through your tRPC endpoint.
 *
 * @see https://trpc.io/docs/context
 */
const createTRPCContext = async (opts: { req: NextRequest }) => {
  // Fetch stuff that depends on the request

  return await createContextInternal({
    headers: opts.req.headers,
  })
}

/**
 * 2. INITIALIZATION
 *
 * This is where the tRPC API is initialized, connecting the context and transformer. We also parse
 * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation
 * errors on the backend.
 */

const trpcInstance = initTRPC.context<typeof createTRPCContext>().create({
  transformer: superjson,
  errorFormatter({ shape, error }) {
    return {
      ...shape,
      data: {
        ...shape.data,
        zodError:
          error.cause instanceof ZodError ? error.cause.flatten() : null,
      },
    }
  },
})

/**
 * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)
 *
 * These are the pieces you use to build your tRPC API. You should import these a lot in the
 * "/src/server/api/routers" directory.
 */

/**
 * This is how you create new routers and sub-routers in your tRPC API.
 *
 * @see https://trpc.io/docs/router
 */
const createTRPCRouter = trpcInstance.router

/**
 * Public (unauthenticated) procedure
 *
 * This is the base piece you use to build new queries and mutations on your tRPC API. It does not
 * guarantee that a user querying is authorized, but you can still access user session data if they
 * are logged in.
 */
const procedurePublic = trpcInstance.procedure

/** Reusable middleware that enforces users are logged in before running the procedure. */
const middlewareAuthenticated = trpcInstance.middleware(({ ctx, next }) => {
  if (!ctx.session?.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED' })
  }

  return next({
    ctx: {
      // infers the `session` as non-nullable
      session: { ...ctx.session, user: ctx.session.user },
    },
  })
})

/**
 * Protected (authenticated) procedure
 *
 * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies
 * the session is valid and guarantees `ctx.session.user` is not null.
 *
 * @see https://trpc.io/docs/procedures
 */
const procedure = trpcInstance.procedure.use(middlewareAuthenticated)

const mergeRouters = trpcInstance.mergeRouters

export const Trpc = {
  createRouter: createTRPCRouter,
  createContext: createTRPCContext,
  mergeRouters,
  procedure,
  procedurePublic,
}

================
File: src/core/trpc/index.tsx
================
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import React, { ReactNode, useState } from 'react'
import { Api, createTrpcClient } from './internal/trpc.client'

type Props = { children: ReactNode }

export const TRPCProvider: React.FC<Props> = ({ children }) => {
  const [queryClient] = useState(() => new QueryClient())

  const [trpcClient] = useState(() => createTrpcClient())

  return (
    <QueryClientProvider client={queryClient}>
      <Api.Provider client={trpcClient} queryClient={queryClient}>
        {children}
      </Api.Provider>
    </QueryClientProvider>
  )
}

export * from './internal/trpc.client'

================
File: src/core/trpc/server.ts
================
export * from './internal/trpc.server'

================
File: src/designSystem/core/html/index.tsx
================
import { theme } from 'antd'
import { ReactNode } from 'react'

const { useToken } = theme

interface Props {
  children: ReactNode
}

export const MrbHtml: React.FC<Props> = ({ children }: Props) => {
  const { token } = useToken()

  return (
    <html
      lang="en"
      style={{ background: token.colorBgBase, color: token.colorTextBase }}
    >
      <head>
        <title>Mel the HR</title>
      </head>
      <body>{children}</body>
    </html>
  )
}

================
File: src/designSystem/core/html/theme.ts
================
export interface MrbHtmlTheme {
  color: string
  background: string
}

================
File: src/designSystem/core/main/index.tsx
================
import { Layout } from 'antd'
import { useSnackbar } from 'notistack'
import React, { useEffect, useState } from 'react'
import { Snackbar } from '../../providers'
import { MrbSplashScreen } from '../splashScreen'

interface Props {
  children: React.ReactNode
}

export const MrbMain: React.FC<Props> = ({ children }: Props) => {
  const [isLoading, setLoading] = useState<boolean>(true)

  useEffect(() => {
    if (isLoading) {
      setLoading(false)
    }
  }, [])

  const snackbar = useSnackbar()

  Snackbar.Instance.setup(snackbar)

  return (
    <Layout className="mrb-main">
      {isLoading ? <MrbSplashScreen /> : children}
    </Layout>
  )
}

================
File: src/designSystem/core/splashScreen/index.tsx
================
import { LoadingOutlined } from '@ant-design/icons'
import { Layout, Spin } from 'antd'
import React, { useEffect, useState } from 'react'

export const MrbSplashScreen: React.FC = () => {
  const [isPageInitialised, setPageInitialised] = useState(false)

  useEffect(() => {
    setPageInitialised(true)
  }, [])

  if (!isPageInitialised) {
    return null
  }

  return (
    <Layout
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
      }}
    >
      <Spin indicator={<LoadingOutlined spin />} size="large" />
    </Layout>
  )
}

================
File: src/designSystem/core/index.tsx
================
export * from './html'
export * from './main'
export * from './splashScreen'

================
File: src/designSystem/helpers/utility.ts
================
import { ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export namespace DesignSystemUtility {
  export function buildClassNames(...values: ClassValue[]) {
    return twMerge(clsx(values))
  }
}

================
File: src/designSystem/landing/images/rightArrow.svg
================
<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg fill="#A2A8B5" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 width="800px" height="800px" viewBox="0 0 403.963 403.963"
	 xml:space="preserve">
<g>
	<path d="M399.908,160.269c-31.824-15.3-64.26-28.152-89.964-52.632c-5.508-4.896-12.24-1.224-12.853,5.508
		c-1.836,15.3-2.448,29.988-2.448,44.676c-29.375-9.18-69.155-3.06-97.308-5.508c-59.976-4.284-119.952-17.748-179.928-15.912
		c-5.508,0-9.792,6.732-6.732,11.628c15.912,23.868,36.108,43.452,55.08,64.26c-20.196,25.093-44.064,45.9-63.648,71.604
		c-4.284,5.508-1.836,13.464,5.508,14.076c103.428,7.956,194.616-64.872,293.76-82.009c-1.836,18.36-1.224,36.721-0.612,55.08
		c0,6.12,7.956,9.792,12.853,5.509c33.048-33.049,63.647-67.32,89.964-105.876C404.804,167.001,402.968,162.105,399.908,160.269z
		 M23.528,282.668c17.136-20.195,35.496-40.392,48.96-63.035c3.672,0.611,7.956-3.673,5.508-7.956
		c-14.076-20.809-31.212-39.168-46.512-59.364c47.736,0.612,94.86,9.18,142.596,14.076c43.452,4.896,89.352,7.344,133.416,8.568
		c5.508,0,7.344-7.344,3.06-10.404c-0.611-0.612-1.224-0.612-1.836-1.224c0-12.24,0.612-24.48,1.836-36.108
		c22.645,17.748,48.349,29.376,74.664,41.616c-21.42,29.988-45.288,57.528-70.38,83.844c-0.612-15.301-1.836-30.601-1.224-45.9
		c0-3.672-3.061-5.508-6.12-5.508c-1.224-1.836-3.06-3.06-6.12-2.448C204.68,209.841,120.836,281.445,23.528,282.668z"/>
</g>
</svg>

================
File: src/designSystem/landing/LandingNavBar/landing.desktop.navbar.tsx
================
'use client'
import { Logo } from '@/designSystem/layouts/NavigationLayout/components/Logo'

import { useUserContext } from '@/core/context'
import { ArrowRightOutlined } from '@ant-design/icons'
import LandingButton from '../LandingButton'
import { LandingNavBarItem } from './landing.navbar.items'

type Props = {
  navItems: {
    link: string
    title: string
    target?: '_blank'
  }[]
}

export const LandingDesktopNavbar = ({ navItems }: Props) => {
  const { isLoggedIn } = useUserContext()

  return (
    <div className="w-full flex relative justify-between px-4 py-2 rounded-full bg-transparent transition duration-200">
      <div className="flex flex-row gap-2 items-center">
        <Logo isLabel height={40} />
        <div className="flex items-center gap-1.5 pl-8">
          {navItems.map(item => (
            <LandingNavBarItem
              href={item.link}
              key={item.title}
              target={item.target}
            >
              {item.title}
            </LandingNavBarItem>
          ))}
        </div>
      </div>
      <div className="flex space-x-2 items-center">
        {isLoggedIn && (
          <LandingButton size="sm" href="/home">
            Dashboard <ArrowRightOutlined />
          </LandingButton>
        )}
        {!isLoggedIn && (
          <LandingButton size="sm" href="/login">
            Get Started
          </LandingButton>
        )}
      </div>
    </div>
  )
}

================
File: src/designSystem/landing/LandingNavBar/landing.mobile.navbar.tsx
================
'use client'

import { useUserContext } from '@/core/context'
import { Logo } from '@/designSystem/layouts/NavigationLayout/components/Logo'
import {
  ArrowRightOutlined,
  CloseOutlined,
  MenuOutlined,
} from '@ant-design/icons'
import Link from 'next/link'
import { useState } from 'react'
import LandingButton from '../LandingButton'

export const LandingMobileNavbar = ({ navItems }: any) => {
  const { isLoggedIn } = useUserContext()
  const [open, setOpen] = useState(false)

  return (
    <div className="flex justify-between  items-center w-full rounded-full px-2.5 py-1.5 transition duration-200">
      <Logo isLabel height={40} />
      <MenuOutlined
        className="text-black dark:text-white h-6 w-6"
        onClick={() => setOpen(!open)}
      />
      {open && (
        <div className="fixed inset-0 bg-white dark:bg-black z-50 flex flex-col items-start justify-start space-y-10  pt-5  text-xl text-zinc-600  transition duration-200 hover:text-zinc-800">
          <div className="flex items-center justify-between w-full px-5">
            <Logo isLabel height={40} />
            <div className="flex items-center space-x-2">
              <CloseOutlined
                className="h-8 w-8 text-black dark:text-white"
                onClick={() => setOpen(!open)}
              />
            </div>
          </div>
          <div className="flex flex-col items-start justify-start gap-[14px] px-8">
            {navItems.map((navItem: any, idx: number) => (
              <>
                {navItem.children && navItem.children.length > 0 ? (
                  <>
                    {navItem.children.map((childNavItem: any, idx: number) => (
                      <Link
                        key={`link=${idx}`}
                        href={childNavItem.link}
                        onClick={() => setOpen(false)}
                        className="relative max-w-[15rem] text-left text-2xl"
                      >
                        <span className="block text-black">
                          {childNavItem.title}
                        </span>
                      </Link>
                    ))}
                  </>
                ) : (
                  <Link
                    key={`link=${idx}`}
                    href={navItem.link}
                    onClick={() => setOpen(false)}
                    className="relative"
                  >
                    <span className="block text-[26px] text-black dark:text-white">
                      {navItem.title}
                    </span>
                  </Link>
                )}
              </>
            ))}
          </div>
          <div className="flex flex-row w-full items-start gap-2.5  px-8 py-4 ">
            {isLoggedIn && (
              <LandingButton size="sm" href="/home">
                Dashboard <ArrowRightOutlined />
              </LandingButton>
            )}
            {!isLoggedIn && (
              <>
                <LandingButton href="/register" size="sm">
                  Sign Up
                </LandingButton>
                <LandingButton href="/login" size="sm">
                  Login
                </LandingButton>
              </>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

================
File: src/designSystem/landing/LandingNavBar/landing.navbar.items.tsx
================
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { ReactNode } from 'react'
import { DesignSystemUtility } from '../../helpers/utility'

type Props = {
  href: string
  children: ReactNode
  active?: boolean
  className?: string
  target?: '_blank'
}

export function LandingNavBarItem({
  children,
  href,
  active,
  target,
  className,
}: Props) {
  const pathname = usePathname()

  return (
    <Link
      href={href}
      className={DesignSystemUtility.buildClassNames(
        'text-lg flex items-center justify-center   leading-[110%] px-4 py-2 rounded-md hover:bg-[#F5F5F5] dark:hover:bg-white dark:hover:text-black hover:text-black text-muted dark:text-muted-dark',
        (active || pathname?.includes(href)) &&
          'bg-gray-100 dark:bg-neutral-800 text-black',
        className,
      )}
      target={target}
    >
      {children}
    </Link>
  )
}

================
File: src/designSystem/landing/LandingNavBar/landing.navbar.tsx
================
'use client'

import { useDesignSystem } from '@/designSystem/provider'
import { LandingDesktopNavbar } from './landing.desktop.navbar'
import { LandingMobileNavbar } from './landing.mobile.navbar'

interface Props {
  navItems: {
    link: string
    title: string
    target?: '_blank'
  }[]
}

export const LandingNavBar: React.FC<Props> = ({ navItems }) => {
  const { isMobile } = useDesignSystem()

  return (
    <div className="max-w-7xl  pt-4 mx-auto inset-x-0 z-50 w-[95%] lg:w-full">
      <div className="hidden lg:block w-full">
        {!isMobile && <LandingDesktopNavbar navItems={navItems} />}
      </div>
      <div className="flex h-full w-full items-center">
        {isMobile && <LandingMobileNavbar navItems={navItems} />}
      </div>
    </div>
  )
}

================
File: src/designSystem/landing/LandingAvatar.tsx
================
import clsx from 'clsx'
import { ImgHTMLAttributes } from 'react'

interface LandingAvatarProps extends ImgHTMLAttributes<HTMLImageElement> {
  size?: 'small' | 'medium' | 'large'
}

/**
 * Shows an avatar image.
 */
export const LandingAvatar = ({
  className,
  src,
  width = 128,
  height = 128,
  size = 'medium',
  ...remainingProps
}: LandingAvatarProps) => {
  return (
    <img
      src={src}
      width={width}
      height={height}
      className={clsx(
        'rounded-full border-2 border-solid border-primary-100',
        size === 'small' ? 'w-6 h-6' : '',
        size === 'medium' ? 'h-9 w-9' : '',
        size === 'large' ? 'h-16 w-16' : '',
        className,
      )}
      {...remainingProps}
    />
  )
}

================
File: src/designSystem/landing/LandingButton.tsx
================
import { AnchorHTMLAttributes } from 'react'
import { twMerge } from 'tailwind-merge'

export interface IButton extends AnchorHTMLAttributes<HTMLAnchorElement> {
  href: string
  size?: 'sm' | 'md' | 'lg'
  block?: boolean
  type?: 'outline' | 'primary' | 'inverted' | 'muted'
  children?: React.ReactNode
}

const LandingButton = (props: IButton) => {
  const {
    href,
    block,
    size = 'md',
    type = 'primary',
    className,
    children,
    ...remainingProps
  } = props

  const sizes = {
    lg: 'px-5 py-2.5',
    md: 'px-4 py-2',
    sm: 'px-2 py-1',
  }

  const styles = {
    outline:
      'bg-white  hover:text-black dark:hover:text-black border-2 border-black hover:bg-gray-100 text-black dark:bg-black dark:text-white dark:border-white',
    primary:
      'bg-black text-white hover:text-white dark:hover:text-black  hover:bg-slate-800 border-2 border-transparent dark:bg-white dark:text-black dark:hover:bg-gray-200 ',
    inverted:
      'bg-white text-black hover:text-black dark:hover:text-black border-2 border-transparent hover:bg-gray-100 dark:bg-black dark:text-white',
    muted:
      'bg-gray-100 hover:text-black dark:hover:text-black hover:bg-gray-200 border-2 border-transparent text-black dark:bg-gray-700 dark:text-white',
  }

  return (
    <a
      href={href}
      {...remainingProps}
      className={twMerge(
        'rounded text-center transition focus-visible:ring-2 ring-offset-2 ring-gray-200',
        block && 'w-full',
        sizes[size],
        styles[type],
        className,
      )}
    >
      {children}
    </a>
  )
}

export default LandingButton

================
File: src/designSystem/landing/LandingContainer.tsx
================
import { HTMLAttributes } from 'react'
import { LandingFooter } from './LandingFooter'
import { LandingNavBar } from './LandingNavBar/landing.navbar'

interface Props extends HTMLAttributes<HTMLElement> {
  navItems: {
    link: string
    title: string
    target?: '_blank'
  }[]
  children: React.ReactNode
}

export const LandingContainer: React.FC<Props> = ({
  navItems,
  children,
  ...props
}) => {
  return (
    <main {...props} className="bg-[#FFA07A] text-white min-h-screen">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <LandingNavBar navItems={navItems} />
        {children}
        <LandingFooter />
      </div>
    </main>
  )
}

================
File: src/designSystem/landing/LandingCTA.tsx
================
import { HTMLAttributes } from 'react'
import { DesignSystemUtility } from '../helpers/utility'
import LandingButton from './LandingButton'

interface Props extends HTMLAttributes<HTMLElement> {
  title?: string
  subtitle?: string
  buttonText?: string
  buttonLink?: string
}

export const LandingCTA: React.FC<Props> = ({
  title,
  subtitle,
  buttonText,
  buttonLink,
  className,
  ...props
}) => {
  return (
    <section
      className={DesignSystemUtility.buildClassNames('py-16 px-5', className)}
      {...props}
    >
      <div className="max-w-7xl mx-auto ">
        <div className="bg-black p-8 md:px-20 md:py-20 mt-20 mx-auto max-w-5xl rounded-lg flex flex-col items-center text-center">
          <h2 className="text-white text-4xl lg:text-5xl font-bold lg:tracking-tight">
            {title}
          </h2>
          <p className="text-slate-400 mt-4 text-lg md:text-xl">{subtitle}</p>
          <div className="flex mt-10">
            <LandingButton href={buttonLink ?? '/register'} size="lg">
              {buttonText}
            </LandingButton>
          </div>
        </div>
      </div>
    </section>
  )
}

================
File: src/designSystem/landing/LandingFAQ.tsx
================
import { ArrowRightOutlined } from '@ant-design/icons'
import { HTMLAttributes } from 'react'
import { DesignSystemUtility } from '../helpers/utility'

interface Props extends HTMLAttributes<HTMLElement> {
  title: string
  subtitle: string
  questionAnswers: { question: string; answer: string }[]
}

export const LandingFAQ: React.FC<Props> = ({
  title,
  subtitle,
  questionAnswers,
  className,
  ...props
}) => {
  return (
    <section
      className={DesignSystemUtility.buildClassNames('py-16 px-5', className)}
      {...props}
    >
      <div className="max-w-7xl mx-auto ">
        <div className="flex flex-col md:flex-row">
          <div className="md:w-1/2">
            <h3 className="text-3xl lg:text-4xl font-bold lg:tracking-tight">
              {title}
            </h3>
            <p className="text-lg mt-4 text-slate-600 dark:text-slate-400">
              {subtitle}
            </p>
          </div>
          <div className="w-full md:w-1/2 max-w-xl mx-auto">
            <div className="grid divide-y divide-neutral-200 dark:divide-slate-400">
              {questionAnswers.map((item, index) => (
                <div className="py-5" key={index}>
                  <details className="group">
                    <summary className="flex justify-between text-lg items-center font-medium cursor-pointer list-none">
                      <span>{item.question}</span>
                      <span className="transition group-open:rotate-180">
                        <ArrowRightOutlined />
                      </span>
                    </summary>
                    <p className="text-slate-600 dark:text-slate-400 mt-3 group-open:animate-fadeIn">
                      {item.answer}
                    </p>
                  </details>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
    </section>
  )
}

export default LandingFAQ

================
File: src/designSystem/landing/LandingFeatures.tsx
================
import { HTMLAttributes } from 'react'
import { DesignSystemUtility } from '../helpers/utility'
import { Card, Typography } from 'antd'

const { Title, Paragraph } = Typography

type FeatureType = {
  heading: string
  description: string | any
  icon: any
}

interface Props extends HTMLAttributes<HTMLElement> {
  title: string
  subtitle: string
  features: FeatureType[]
}

export const LandingFeatures: React.FC<Props> = ({
  title,
  subtitle,
  features,
  className,
  ...props
}) => {
  return (
    <section
      className={DesignSystemUtility.buildClassNames('py-16 px-5', className)}
      {...props}
    >
      <div className="max-w-7xl mx-auto text-center">
        <Title
          level={2}
          className="text-4xl lg:text-5xl font-bold lg:tracking-tight mb-4"
        >
          {title}
        </Title>
        <Paragraph className="text-lg mb-12 text-slate-600 dark:text-slate-400">
          {subtitle}
        </Paragraph>

        <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-8">
          {features?.map((item, idx) => (
            <Card
              key={idx + 'feature'}
              className="flex flex-col items-center text-center p-6 bg-white dark:bg-slate-800 rounded-lg shadow-md hover:shadow-lg transition-shadow"
            >
              <div className="text-primary text-4xl mb-4">{item.icon}</div>
              <Title level={4} className="font-semibold mb-2">
                {item.heading}
              </Title>
              <Paragraph className="text-slate-600 dark:text-slate-400">
                {item.description}
              </Paragraph>
            </Card>
          ))}
        </div>
      </div>
    </section>
  )
}

================
File: src/designSystem/landing/LandingFooter.tsx
================
import { Logo } from '@/designSystem/layouts/NavigationLayout/components/Logo'
import { LinkedinFilled, TwitterCircleFilled } from '@ant-design/icons'
import Link from 'next/link'
import { HTMLAttributes } from 'react'

interface Props extends HTMLAttributes<HTMLElement> {}

export const LandingFooter: React.FC<Props> = ({ ...props }) => {
  const socials = [
    {
      name: 'X',
      icon: <TwitterCircleFilled />,
      link: 'https://twitter.com/',
    },
    {
      name: 'LinkedIn',
      icon: <LinkedinFilled />,
      link: 'https://linkedin.com/',
    },
  ]
  return (
    <div className="relative mt-16" {...props}>
      <div className="border-t border-neutral-100  dark:border-neutral-800 px-8 pt-20 pb-32 relative bg-white dark:bg-black">
        <div className="max-w-7xl mx-auto  flex sm:flex-row flex-col justify-between items-start ">
          <div>
            <div className="mr-4  md:flex mb-4">
              <Logo height={50} isLabel />
            </div>
            <div>Copyright &copy; 2024</div>
            <div className="mt-2">All rights reserved</div>
          </div>
          <div className="grid grid-cols-3 gap-10 items-start mt-10 md:mt-0">
            <div className="flex justify-center space-y-4 flex-col mt-4">
              {socials.map(link => (
                <Link
                  key={link.name}
                  className="transition-colors  text-xs sm:text-sm"
                  href={link.link}
                >
                  {link.name}
                </Link>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

================
File: src/designSystem/landing/LandingHero.tsx
================
import { HTMLAttributes, ReactNode } from 'react'
import { DesignSystemUtility } from '../helpers/utility'
import LandingButton from './LandingButton'
import { Typography } from 'antd'

const { Title, Paragraph } = Typography

interface Props extends HTMLAttributes<HTMLElement> {
  title: string
  subtitle: string
  buttonText: string
  pictureUrl?: string
  socialProof?: ReactNode
}

export const LandingHero: React.FC<Props> = ({
  title,
  subtitle,
  buttonText,
  pictureUrl,
  socialProof = '',
  className,
  ...props
}) => {
  return (
    <section
      className={DesignSystemUtility.buildClassNames(
        'bg-primary text-white',
        className,
      )}
      {...props}
    >
      <div className="py-16 lg:py-24 px-5 max-w-7xl mx-auto grid lg:grid-cols-2 gap-12 items-center">
        <div className="text-center lg:text-left">
          <Title
            level={1}
            className="text-4xl lg:text-5xl font-bold text-white mb-6"
          >
            {title}
          </Title>
          <Paragraph className="text-lg mb-8 text-white/80">
            {subtitle}
          </Paragraph>
          <div className="flex justify-center lg:justify-start">
            <LandingButton
              href={'/login'}
              className="bg-white text-primary hover:bg-white/90"
              size="large"
            >
              {buttonText}
            </LandingButton>
          </div>
          {socialProof && <div className="mt-8">{socialProof}</div>}
        </div>

        <div className="relative">
          <img
            src={pictureUrl}
            alt="Hero image"
            className="rounded-lg shadow-xl w-full"
          />
        </div>
      </div>
    </section>
  )
}

================
File: src/designSystem/landing/LandingHowItWorks.tsx
================
import { HTMLAttributes } from 'react'
import { DesignSystemUtility } from '../helpers/utility'

type StepType = {
  heading: string
  description: string | any
}

interface Props extends HTMLAttributes<HTMLElement> {
  title: string
  subtitle?: string
  steps: StepType[]
}

export const LandingHowItWorks: React.FC<Props> = ({
  title,
  subtitle = '',
  steps,
  className,
  ...props
}) => {
  return (
    <section
      className={DesignSystemUtility.buildClassNames('py-16 px-5', className)}
      {...props}
    >
      <div className="max-w-7xl mx-auto text-center">
        <h2 className="text-4xl lg:text-5xl font-bold lg:tracking-tight">
          {title}
        </h2>
        <div className="max-w-xl space-y-8 mt-12 mx-auto">
          {steps.map((item, idx) => (
            <div key={idx} className="flex items-start">
              <div className="flex-shrink-0 w-16 h-16 bg-gray-200 dark:bg-slate-800 rounded-full flex items-center justify-center text-2xl font-bold ">
                {idx + 1}
              </div>
              <div className="ml-4 text-left">
                <h3 className="font-semibold text-lg ">{item.heading}</h3>
                <p className="dark:text-slate-400">{item.description}</p>
              </div>
            </div>
          ))}
        </div>
      </div>
    </section>
  )
}

================
File: src/designSystem/landing/LandingPainPoints.tsx
================
import { ArrowDownOutlined } from '@ant-design/icons'
import { HTMLAttributes } from 'react'
import { DesignSystemUtility } from '../helpers/utility'
import RightArrow from './images/rightArrow.svg'

type PainPointType = {
  emoji: string
  title: string
}

interface Props extends HTMLAttributes<HTMLElement> {
  title?: string
  subtitle?: string
  painPoints: PainPointType[]
}

export const LandingPainPoints: React.FC<Props> = ({
  title,
  subtitle,
  painPoints,
  className,
  ...props
}) => {
  return (
    <section
      className={DesignSystemUtility.buildClassNames('py-16 px-5', className)}
      {...props}
    >
      <div className="max-w-5xl mx-auto text-center">
        <h2 className="text-4xl lg:text-5xl font-bold lg:tracking-tight">
          {title}
        </h2>
        <p className="text-lg mt-4 text-slate-600 dark:text-slate-400 mb-12">
          {subtitle}
        </p>

        <div className="flex justify-center items-center space-x-8">
          {painPoints?.map((painPoint, idx) => (
            <>
              <div className="flex flex-col items-center">
                <span className="text-5xl mb-4">{painPoint.emoji}</span>
                <span className="font-semibold text-lg text-gray-900 dark:text-slate-200">
                  {painPoint.title}
                </span>
              </div>
              {idx < painPoints.length - 1 && (
                <img src={RightArrow.src} width="50" className="dark:invert" />
              )}
            </>
          ))}
        </div>
        <div className="text-center pt-20">
          <div className="flex flex-col items-center">
            <p className="text-slate-600 dark:text-slate-400 text-lg">
              <ArrowDownOutlined /> there is an easier way
            </p>
          </div>
        </div>
      </div>
    </section>
  )
}

================
File: src/designSystem/landing/LandingPricing.tsx
================
import { CheckCircleFilled } from '@ant-design/icons'
import { HTMLAttributes } from 'react'
import { DesignSystemUtility } from '../helpers/utility'
import LandingButton from './LandingButton'

type Package = {
  title: string
  description: string
  monthly: number
  features: string[]
  className?: string
  type?: string
  highlight?: boolean
}

interface Props extends HTMLAttributes<HTMLElement> {
  title: string
  subtitle: string
  packages: Package[]
}

export const LandingPricing: React.FC<Props> = ({
  title,
  subtitle,
  packages,
  className,
  ...props
}) => {
  return (
    <section
      className={DesignSystemUtility.buildClassNames('py-16 px-5', className)}
      {...props}
    >
      <div className="max-w-7xl mx-auto relative group overflow-hidden text-center">
        <div className="mt-16 md:mt-0">
          <h2 className="text-4xl lg:text-5xl font-bold lg:tracking-tight">
            {title}
          </h2>
          <p className="text-lg mt-4 text-slate-600 dark:text-slate-400">
            {subtitle}
          </p>
        </div>

        <div className="grid md:grid-cols-3 gap-10 mx-auto max-w-screen-lg mt-12">
          {packages.map((item, idx) => (
            <PricingCard key={idx + 'pricingcard'} {...item} />
          ))}
        </div>
      </div>
    </section>
  )
}

const PricingCard = (props: Package) => {
  const { title, description, monthly, features, className, type, highlight } =
    props
  return (
    <div>
      <div
        className={`flex flex-col w-full order-first lg:order-none border py-5 px-6 relative rounded-lg ${
          highlight ? 'border-orange-500 ' : 'border-slate-400 '
        }`}
      >
        <div className="text-center">
          {highlight && (
            <span className="inline-flex absolute px-3 py-1 text-xs -top-3 left-1/2 -translate-x-1/2 font-medium rounded-full bg-gradient-to-r from-red-500 to-orange-500 text-white ">
              Popular
            </span>
          )}

          <h4 className="text-lg font-medium text-slate-600 dark:text-slate-400">
            {title}
          </h4>
          <p className="mt-3 text-4xl font-bold text-black dark:text-white md:text-4xl">
            <span className="text-sm font-normal">$</span>
            {monthly}
            <span className="text-sm font-normal text-slate-600 dark:text-slate-400">
              /month
            </span>
          </p>
        </div>
        <ul className="grid mt-8 text-left gap-y-4">
          {features.map((item, idx) => (
            <li
              key={idx + 'pricingfeature'}
              className="flex items-start gap-3 text-slate-600 dark:text-slate-400"
            >
              <CheckCircleFilled className="w-6 h-6" />
              <span>{item}</span>
            </li>
          ))}
        </ul>
        <div className="flex mt-8">
          <LandingButton
            href={'/register'}
            block
            type={highlight ? 'primary' : 'outline'}
          >
            {'Get Started'}
          </LandingButton>
        </div>
      </div>
    </div>
  )
}

================
File: src/designSystem/landing/LandingRating.tsx
================
import { StarFilled, StarOutlined } from '@ant-design/icons'
import clsx from 'clsx'

/**
 * Shows a rating with stars.
 */
export const LandingRating = ({
  className,
  rating = 5,
  maxRating = 5,
  size = 'medium',
}: {
  className?: string
  rating?: number
  maxRating?: number
  size?: 'small' | 'medium' | 'large'
}) => {
  return (
    <div
      className={clsx('flex items-center gap-1', className)}
      aria-description={`Rating: ${rating} out of ${maxRating}`}
    >
      {Array.from({ length: maxRating }).map((_, index) => {
        return (
          <div
            key={index}
            className={clsx(
              size === 'small' ? 'h-3 w-3' : '',
              size === 'medium' ? 'h-4 w-4' : '',
              size === 'large' ? 'h-5 w-5' : '',
            )}
          >
            {
              // Return half star for half ratings
              rating % 1 !== 0 &&
              index === Math.floor(rating) &&
              index + 1 === Math.ceil(rating) ? (
                <div className="relative" key={index}>
                  <StarFilled
                    className="absolute top-0 left-0 w-full h-full text-gray-300 fill-gray-300"
                    aria-hidden="true"
                  />

                  <StarOutlined
                    className="relative z-10 w-full h-full text-yellow-400 fill-yellow-400"
                    aria-hidden="true"
                  />
                </div>
              ) : (
                <StarFilled
                  key={index}
                  className={clsx('w-full h-full', {
                    'text-yellow-400 fill-yellow-400': index < rating,
                    'text-gray-300 fill-gray-300': index >= rating,
                  })}
                  aria-hidden="true"
                />
              )
            }
          </div>
        )
      })}
    </div>
  )
}

================
File: src/designSystem/landing/LandingSocialProof.tsx
================
import { HTMLAttributes } from 'react'

type LogoType = {
  url: string
}

interface Props extends HTMLAttributes<HTMLElement> {
  title: string
  logos: LogoType[]
}

export const LandingSocialProof: React.FC<Props> = ({ logos }) => {
  return (
    <section className="py-16">
      <div className="max-w-7xl mx-auto">
        <h2 className="text-center  text-slate-600 dark:text-slate-400">
          Featured on
        </h2>
        <div className="flex gap-8 md:gap-20 items-center justify-center mt-8 flex-wrap">
          {logos.map((logo, idx) => (
            <img className="h-6 md:h-10" key={`logo-${idx}`} src={logo.url} />
          ))}
        </div>
      </div>
    </section>
  )
}

================
File: src/designSystem/landing/LandingSocialRating.tsx
================
import clsx from 'clsx'
import { LandingAvatar } from './LandingAvatar'
import { LandingRating } from './LandingRating'

export const LandingSocialRating = ({
  children,
  avatarItems,
  numberOfUsers = 100,
  suffixText = 'happy users',
}: {
  children?: React.ReactNode
  avatarItems: { src: string }[]
  numberOfUsers: number
  suffixText?: string
}) => {
  const numberText =
    numberOfUsers > 1000
      ? `${(numberOfUsers / 1000).toFixed(0)}k`
      : `${numberOfUsers}`

  return (
    <div className="group flex flex-wrap gap-2">
      <div className="flex gap-1">
        {avatarItems.map((avatarItem, index) => (
          <LandingAvatar
            key={index}
            src={avatarItem.src}
            className={clsx(
              'relative',
              index === 1 || index === 2 ? `-ml-4` : '',
              index === 3 ? `-ml-5` : '',
              index > 3 ? `-ml-6` : '',
            )}
          />
        ))}
      </div>

      <div className="flex flex-col justify-center gap-1">
        <LandingRating />

        {!children ? (
          <p className="text-xs max-w-sm text-slate-600 dark:text-slate-400 ">
            {numberText}+ {suffixText}
          </p>
        ) : (
          children
        )}
      </div>
    </div>
  )
}

================
File: src/designSystem/landing/LandingTestimonials.tsx
================
import { HTMLAttributes } from 'react'
import { Typography, Avatar, Card } from 'antd'
import { DesignSystemUtility } from '../helpers/utility'

const { Title, Paragraph } = Typography

type Testimonial = {
  name: string
  content: string
  designation?: string
  avatar?: string
}

interface Props extends HTMLAttributes<HTMLElement> {
  anchorId?: string
  title: string
  subtitle: string
  testimonials: Testimonial[]
}

export const LandingTestimonials: React.FC<Props> = ({
  title,
  subtitle,
  testimonials,
  className,
  ...props
}) => {
  return (
    <section
      className={DesignSystemUtility.buildClassNames('py-16 px-5', className)}
      {...props}
    >
      <div className="max-w-6xl mx-auto px-4 py-16">
        <div className="text-center mb-12">
          <Title level={2} className="text-4xl font-bold mb-4">
            {title}
          </Title>
          <Paragraph className="text-lg text-gray-600">{subtitle}</Paragraph>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
          {testimonials?.map((testimonial: Testimonial, idx: number) => (
            <TestimonialCard key={`testimonial-${idx}`} {...testimonial} />
          ))}
        </div>
      </div>
    </section>
  )
}

const TestimonialCard = ({
  name,
  content,
  designation,
  avatar,
}: Testimonial) => {
  return (
    <Card className="h-full shadow-md hover:shadow-lg transition-shadow duration-300">
      <div className="flex items-center mb-4">
        <Avatar src={avatar} size={64} className="mr-4" />
        <div>
          <Title level={4} className="mb-0">
            {name}
          </Title>
          <Paragraph className="text-gray-600 mb-0">{designation}</Paragraph>
        </div>
      </div>
      <Paragraph className="text-gray-700">{content}</Paragraph>
    </Card>
  )
}

================
File: src/designSystem/layouts/NavigationLayout/components/Leftbar/index.tsx
================
import { Flex, Menu, Row } from 'antd'
import Sider from 'antd/es/layout/Sider'
import { useParams, usePathname } from 'next/navigation'
import { ReactNode } from 'react'

interface Props {
  header?: ReactNode
  items: { key: string; label: string; onClick: () => void }[]
  itemsBottom?: { key: string; label: string; onClick: () => void }[]
}

export const Leftbar: React.FC<Props> = ({ header, items, itemsBottom }) => {
  const pathname = usePathname()
  const params: Record<string, string> = useParams()

  let pathnamePure = pathname

  Object.entries(params).forEach(([key, value]) => {
    pathnamePure = pathnamePure.replace(`/${value}`, `/:${key}`)
  })

  return (
    <>
      <Sider width={250} trigger={null} style={{ height: '100%' }}>
        {header && <Row style={{ padding: 16 }}>{header}</Row>}
        <Flex vertical justify="space-between" flex={1} className="pb-4">
          <Menu
            mode="inline"
            inlineIndent={16}
            items={items}
            selectedKeys={[pathnamePure]}
            style={{ width: '100%' }}
          />
          <Menu
            mode="inline"
            inlineIndent={16}
            items={itemsBottom}
            style={{ width: '100%' }}
          />
        </Flex>
      </Sider>
    </>
  )
}

================
File: src/designSystem/layouts/NavigationLayout/components/Logo/index.tsx
================
import { Flex, Typography } from 'antd'
import { useRouter } from 'next/navigation'
import React, { ImgHTMLAttributes } from 'react'

interface Props extends ImgHTMLAttributes<HTMLImageElement> {
  isLabel?: boolean
}

export const Logo: React.FC<Props> = ({
  height = 50,
  isLabel = false,
  style,
  ...props
}) => {
  const router = useRouter()

  const goTo = (url: string) => {
    router.push(url)
  }

  return (
    <Flex align="center" gap={10}>
      <img
        src="https://marblism-dashboard-api--production-public.s3.us-west-1.amazonaws.com/cmu2QU-melthehr-vwpn"
        height={height}
        style={{
          borderRadius: '5px',
          cursor: 'pointer',
          objectFit: 'contain',
          height: `${height}px`,
          ...style,
        }}
        {...props}
        onClick={() => goTo('/home')}
      />
      {isLabel && (
        <Typography.Title level={4} style={{ margin: '0px' }}>
          Mel the HR
        </Typography.Title>
      )}
    </Flex>
  )
}

================
File: src/designSystem/layouts/NavigationLayout/components/OrganizationSelect/index.tsx
================
import { useUserContext } from '@/core/context'
import { Utility } from '@/core/helpers/utility'
import { Api } from '@/core/trpc'
import {
  CheckOutlined,
  DownOutlined,
  PlusOutlined,
  SettingOutlined,
  UserAddOutlined,
} from '@ant-design/icons'
import { Organization } from '@prisma/client'
import { Avatar, Button, Dropdown, Flex, MenuProps, Typography } from 'antd'
import { useParams, usePathname, useRouter } from 'next/navigation'
import { useSnackbar } from 'notistack'

export const OrganizationItem = ({
  organization,
  isSelected = false,
}: {
  organization: Organization
  isSelected?: boolean
}) => {
  const initial = Utility.stringToInitials(organization.name)[0]

  return (
    <Flex
      align="center"
      gap={8}
      style={{
        width: '100%',
        maxWidth: '243px',
        overflow: 'hidden',
        cursor: 'pointer',
      }}
    >
      <Avatar shape="square" size={20} src={organization.pictureUrl}>
        {initial}
      </Avatar>

      <Flex flex={1} style={{ overflow: 'hidden' }}>
        <Typography.Text ellipsis={true}>{organization.name}</Typography.Text>
      </Flex>

      {isSelected && (
        <Typography.Text type="secondary">
          <CheckOutlined />
        </Typography.Text>
      )}
    </Flex>
  )
}

export const OrganizationSelect: React.FC = () => {
  const router = useRouter()
  const params = useParams()
  const pathname = usePathname()
  const { enqueueSnackbar } = useSnackbar()

  const {
    user,
    organization: organizationSelected,
    organizations,
    refetchOrganizations,
    checkOrganizationRole,
  } = useUserContext()

  const {
    mutateAsync: createOrganization,
    isLoading: isLoadingCreateOrganization,
  } = Api.organization.create.useMutation()

  const handleClickCreate = async () => {
    try {
      const organization = await createOrganization({
        data: {
          name: 'My Team',
          roles: { create: { userId: user.id, name: 'owner' } },
        },
      })

      refetchOrganizations()

      router.push(`/organizations/${organization.id}/settings`)
    } catch (error) {
      enqueueSnackbar(error.message, { variant: 'error' })
    }
  }

  const items: MenuProps['items'] = [
    ...organizations.map(organization => ({
      key: organization.id,
      label: (
        <OrganizationItem
          organization={organization}
          isSelected={organization.id === organizationSelected?.id}
        />
      ),
      onClick: () => {
        const keys = Object.keys(params)
        const canReplace = keys.length === 1 && keys[0] === 'organizationId'

        if (canReplace) {
          const path = pathname.replace(
            params.organizationId as string,
            organization.id,
          )
          router.push(path)
        } else {
          router.push(`/organizations/${organization.id}/members`)
        }
      },
    })),
    {
      key: 'create',
      disabled: true,
      label: (
        <Flex gap={4} justify="center" align="center">
          <Button
            type="text"
            size="small"
            block
            onClick={handleClickCreate}
            loading={isLoadingCreateOrganization}
          >
            <PlusOutlined />
            Create
          </Button>
        </Flex>
      ),
    },
  ]

  if (organizationSelected) {
    items.unshift({
      key: 'settings',
      disabled: true,
      label: (
        <Flex gap={4} className="pb-4" style={{ cursor: 'default' }}>
          {checkOrganizationRole('owner') && (
            <Button
              size="small"
              type="text"
              icon={<SettingOutlined />}
              block
              onClick={() =>
                router.push(
                  `/organizations/${organizationSelected.id}/settings`,
                )
              }
            >
              Settings
            </Button>
          )}

          <Button
            size="small"
            type="text"
            icon={<UserAddOutlined />}
            block
            onClick={() =>
              router.push(`/organizations/${organizationSelected.id}/members`)
            }
          >
            Invite
          </Button>
        </Flex>
      ),
    })
  }

  return (
    <Dropdown
      menu={{
        items,
        className: 'organization-select__menu',
        style: { width: '275px' },
        selectable: false,
      }}
      trigger={['click']}
    >
      <Button type="text" block size="small">
        <Flex style={{ width: '100%', overflow: 'hidden' }} justify="start">
          {organizationSelected && (
            <OrganizationItem organization={organizationSelected} />
          )}

          {!organizationSelected && <>Organizations</>}
        </Flex>

        <Typography.Text type="secondary">
          <DownOutlined />
        </Typography.Text>
      </Button>
    </Dropdown>
  )
}

================
File: src/designSystem/layouts/NavigationLayout/components/Topbar/index.tsx
================
import { MenuOutlined } from '@ant-design/icons'
import { Avatar, Flex, Layout, Menu, Tag } from 'antd'
import { useParams, usePathname, useRouter } from 'next/navigation'
import { ReactNode } from 'react'

import { useUserContext } from '@/core/context'
import { Utility } from '@/core/helpers/utility'

const { Header } = Layout

interface Props {
  isMobile?: boolean
  isLoggedIn?: boolean
  header?: ReactNode
  items: { key: string; label: string; onClick: () => void }[]
  itemsMobile: { key: string; label: string; onClick: () => void }[]
}

export const Topbar: React.FC<Props> = ({
  isMobile = false,
  isLoggedIn = false,
  header,
  items,
  itemsMobile,
}) => {
  const pathname = usePathname()
  const router = useRouter()
  const params = useParams()

  let pathnamePure = pathname

  Object.entries(params).forEach(([key, value]) => {
    pathnamePure = pathnamePure.replace(`/${value}`, `/:${key}`)
  })

  const { user, checkRole } = useUserContext()

  const style: any = {}

  const isThin = items.length === 0

  if (isThin) {
    style.height = '60px'
  }

  if (isMobile) {
    return (
      <>
        <Header>
          <Flex align="center" justify="space-between">
            {header && <Flex>{header}</Flex>}

            <Menu
              mode="horizontal"
              items={itemsMobile}
              selectedKeys={[pathnamePure]}
              style={{ width: 46 }}
              overflowedIndicator={<MenuOutlined />}
            />
          </Flex>
        </Header>
      </>
    )
  }

  return (
    <>
      <Header style={style}>
        <Flex align="center" style={style}>
          {header && <Flex>{header}</Flex>}

          <Flex vertical flex={1}>
            <Menu
              mode="horizontal"
              items={items}
              selectedKeys={[pathnamePure]}
              overflowedIndicator={<MenuOutlined />}
              style={{ flex: 1 }}
            />
          </Flex>

          <Flex align="center" gap="middle">
            {isLoggedIn && (
              <>
                {checkRole('admin') && (
                  <Tag color="red" bordered={false}>
                    Admin
                  </Tag>
                )}
                <Avatar
                  src={user?.pictureUrl}
                  alt={user.name}
                  size="default"
                  onClick={() => router.push('/profile')}
                  style={{ cursor: 'pointer' }}
                >
                  {Utility.stringToInitials(user?.name)}
                </Avatar>
              </>
            )}
          </Flex>
        </Flex>
      </Header>
    </>
  )
}

================
File: src/designSystem/layouts/NavigationLayout/types/NavigationItem.tsx
================
export type NavigationItem = {
  key: string
  label: string
  onClick: () => void
}

================
File: src/designSystem/layouts/NavigationLayout/index.tsx
================
import { useUserContext } from '@/core/context'
import { DollarOutlined } from '@ant-design/icons'
import { Col, Layout, Row } from 'antd'
import { useRouter } from 'next/navigation'
import { ReactNode } from 'react'
import { useDesignSystem } from '../../provider'
import { Leftbar } from './components/Leftbar'
import { Topbar } from './components/Topbar'

import { OrganizationSelect } from './components/OrganizationSelect'

interface Props {
  children: ReactNode
}

export const NavigationLayout: React.FC<Props> = ({ children }) => {
  const router = useRouter()

  const { organization, authenticationStatus: isLoggedIn } = useUserContext()

  const { isMobile } = useDesignSystem()

  const goTo = (url: string) => {
    router.push(url)
  }

  const itemsOrganization = [
    {
      key: '/organizations/:organizationId/dashboard',
      label: 'Workspace Dashboard',
      onClick: () =>
        goTo(
          '/organizations/:organizationId/dashboard'.replace(
            ':organizationId',
            organization.id,
          ),
        ),
    },

    {
      key: '/organizations/:organizationId/chat',
      label: 'Chatbot Interaction',
      onClick: () =>
        goTo(
          '/organizations/:organizationId/chat'.replace(
            ':organizationId',
            organization.id,
          ),
        ),
    },

    {
      key: '/organizations/:organizationId/users',
      label: 'User Management',
      onClick: () =>
        goTo(
          '/organizations/:organizationId/users'.replace(
            ':organizationId',
            organization.id,
          ),
        ),
    },

    {
      key: '/organizations/:organizationId/billing',
      label: 'Billing and Subscription',
      onClick: () =>
        goTo(
          '/organizations/:organizationId/billing'.replace(
            ':organizationId',
            organization.id,
          ),
        ),
    },

    {
      key: '/organizations/:organizationId/ai-rag-upload',
      label: 'AI RAG File Upload',
      onClick: () =>
        goTo(
          '/organizations/:organizationId/ai-rag-upload'.replace(
            ':organizationId',
            organization.id,
          ),
        ),
    },

    {
      key: '/organizations/:organizationId/pricing',
      icon: <DollarOutlined />,
      label: 'Pricing',
      onClick: () =>
        goTo(
          '/organizations/:organizationId/pricing'.replace(
            ':organizationId',
            organization.id,
          ),
        ),
    },
  ].filter(_ => !!organization)

  const itemsLeftbar = []

  const itemsTopbar = [
    {
      key: '/home',
      label: 'Home Page',
      onClick: () => goTo('/home'),
    },

    ...itemsOrganization,
  ]

  const itemsLeftbarBottom = []

  const itemsMobile = [
    {
      key: '/profile',
      label: 'Profile',
      onClick: () => goTo('/profile'),
    },
    ...itemsTopbar,
    ...itemsLeftbar,
    ...itemsLeftbarBottom,
  ]

  const isLeftbar = itemsLeftbar.length > 0 && !isMobile

  return (
    <>
      <Layout>
        <Row
          style={{
            height: '100vh',
            width: '100vw',
          }}
        >
          {isLeftbar && (
            <Col>
              <Leftbar
                header={<OrganizationSelect />}
                items={itemsLeftbar}
                itemsBottom={itemsLeftbarBottom}
              />
            </Col>
          )}

          <Col
            style={{
              flex: 1,
              height: '100%',
              display: 'flex',
              flexDirection: 'column',
              overflow: 'hidden',
            }}
          >
            <Topbar
              isMobile={isMobile}
              itemsMobile={itemsMobile}
              isLoggedIn={isLoggedIn === 'authenticated'}
              items={itemsTopbar}
              header={!isLeftbar && <OrganizationSelect />}
            />

            <Col
              style={{
                flex: 1,
                overflowY: 'auto',
                overflowX: 'hidden',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
              }}
            >
              {children}
            </Col>
          </Col>
        </Row>
      </Layout>
    </>
  )
}

================
File: src/designSystem/layouts/index.tsx
================
export * from './NavigationLayout'
export * from './Page.layout'

================
File: src/designSystem/layouts/Page.layout.tsx
================
import { Col, Flex } from 'antd'

type LayoutType = 'full-width' | 'narrow' | 'super-narrow'

interface Props {
  children: React.ReactNode
  layout?: LayoutType
  isCentered?: boolean
}

const getLayoutBreakpoints = (layout: LayoutType) => {
  const mapping: Record<LayoutType, Record<string, { span: number }>> = {
    'full-width': {
      xs: { span: 24 },
      sm: { span: 24 },
      md: { span: 24 },
      lg: { span: 24 },
      xl: { span: 24 },
      xxl: { span: 24 },
    },
    narrow: {
      xs: { span: 24 },
      sm: { span: 24 },
      md: { span: 24 },
      lg: { span: 16 },
      xl: { span: 14 },
      xxl: { span: 12 },
    },
    'super-narrow': {
      xs: { span: 24 },
      sm: { span: 24 },
      md: { span: 24 },
      lg: { span: 12 },
      xl: { span: 10 },
      xxl: { span: 8 },
    },
  }

  return mapping[layout] ?? mapping['full-width']
}

export const PageLayout: React.FC<Props> = ({
  children,
  layout = 'full-width',
  isCentered = false,
  ...props
}) => {
  const breakpoints = getLayoutBreakpoints(layout)

  return (
    <>
      <Flex style={{ width: '100%' }} justify="center">
        <Col {...props} {...breakpoints} className="p-2">
          {isCentered && (
            <Flex
              align="center"
              justify="center"
              vertical
              flex={1}
              style={{ minHeight: '100%' }}
            >
              {children}
            </Flex>
          )}
          {!isCentered && children}
        </Col>
      </Flex>
    </>
  )
}

================
File: src/designSystem/providers/snackbar/index.tsx
================
import { OptionsObject, ProviderContext, SnackbarProvider } from 'notistack'
import React, { ReactNode } from 'react'

/**
 * @provider Snackbar
 * @description Notistack is a React library which makes it super easy to display notifications on your web apps
 * @usage `const { enqueueSnackbar } = useSnackbar()`
 * @import import { useSnackbar } from 'notistack'
 * @function {(message: string, {variant: 'error' | 'success' | 'info'}) => void} enqueueSnackbar - Display a toast to the user

 */
export namespace Snackbar {
  export class Instance {
    private static isSetup = false
    private static enqueueSnackbarRef: ProviderContext['enqueueSnackbar']

    static async setup(useSnackbar: ProviderContext) {
      if (this.isSetup) {
        return
      }

      this.enqueueSnackbarRef = useSnackbar.enqueueSnackbar

      this.isSetup = true
    }

    static enqueueSnackbar(message: string, options: OptionsObject) {
      return this.enqueueSnackbarRef(message, {
        ...options,
        style: { whiteSpace: 'pre-line', fontFamily: 'Helvetica Neue' },
      })
    }
  }

  export const Provider: React.FC<{ children: ReactNode }> = ({ children }) => {
    return <SnackbarProvider maxSnack={3}>{children}</SnackbarProvider>
  }
}

================
File: src/designSystem/providers/index.tsx
================
export * from './snackbar'

================
File: src/designSystem/style/landing.scss
================
@tailwind base;
@tailwind components;
@tailwind utilities;

.anticon {
  display: inline-flex !important;
  vertical-align: -0.125em !important;
  align-items: center;
}

.mask-stripes {
  -webkit-mask-image: url(https://i.imgur.com/xYBtnf5.png);
  -webkit-mask-position: center center;
  -webkit-mask-repeat: no-repeat;
  -webkit-mask-size: contain;
  mask-image: url(https://i.imgur.com/xYBtnf5.png);
  mask-position: center center;
  mask-repeat: no-repeat;
  mask-size: contain;
}

================
File: src/designSystem/style/main.scss
================
@import './landing.scss';

:root {
  --primary-color: #1890ff;
  --text-color: #333333;
  --background-color: #ffffff;
}

body {
  display: block;
  margin: 0px;
  font-family: 'Inter', sans-serif;
  color: var(--text-color);
  background-color: var(--background-color);
}

body,
.mrb-main {
  min-height: 100vh;
  min-height: 100svh;
  overflow-x: hidden;
  overflow-y: auto;
}

a {
  color: var(--primary-color);
  text-decoration: none;

  &:hover {
    text-decoration: underline;
  }
}

.ant-breadcrumb a,
.ant-dropdown-menu-title-content a {
  text-decoration: none;
}

.ant-layout-sider-children {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.ant-menu-item-selected::after,
.ant-menu-item::after,
.ant-menu-item-active::after,
.ant-menu-horizontal,
.ant-menu-submenu,
.ant-menu-submenu::after {
  border-bottom: none !important;
}

.ant-typography {
  a,
  .ant-btn-link > span {
    text-underline-offset: 0.2em;
    text-decoration: underline;

    &:hover {
      color: color-mix(in srgb, var(--primary-color) 90%, black);
    }
  }
}

.ant-menu-item-selected {
  font-weight: 600;
  color: var(--primary-color);
}

.ant-form {
  .ant-form-item:last-child {
    margin-bottom: 0;
  }

  .ant-form-item {
    font-weight: 500;
  }

  .ant-form-item label:not(.ant-form-item-required):after {
    content: '(optional)';
    font-weight: normal;
    visibility: visible;
    padding-left: 10px;
    color: #888888;
  }
}

.ant-btn-background-ghost {
  &:active,
  &:hover {
    border-color: transparent;
    color: color-mix(in srgb, var(--primary-color) 90%, black);
  }
}

.css-var-Rcq.ant-typography {
  --ant-typography-title-margin-top: 0em;
  --ant-typography-title-margin-bottom: 0em;
}

.organization-select__menu {
  li {
    cursor: default !important;
  }
}

// New global classes
.text-primary {
  color: var(--primary-color);
}

.bg-primary {
  background-color: var(--primary-color);
}

.font-bold {
  font-weight: 700;
}

.rounded {
  border-radius: 8px;
}

.shadow-md {
  box-shadow:
    0 4px 6px -1px rgba(0, 0, 0, 0.1),
    0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

================
File: src/designSystem/theme/theme.tsx
================
import { theme } from 'antd'
import { Inter } from 'next/font/google'

const interFont = Inter({
  subsets: ['latin'],
})

export const Theme = {
  algorithm: theme.defaultAlgorithm,
  token: {
    // Colors
    colorPrimary: 'black',
    colorError: '#ff4d4f',
    colorInfo: '#1677ff',
    colorSuccess: '#52c41a',
    colorWarning: '#faad14',
    colorTextBase: 'black',
    colorLink: 'black',
    colorBgBase: 'white',
    colorBgContainer: 'white',
    colorBorder: '#d4d4d8',
    colorBorderSecondary: '#e4e4e7',
    colorSplit: 'rgba(24, 24, 27, 0.07)',
    // Typography
    fontFamily: `${interFont.style.fontFamily}, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial`,
    fontSize: 14,
    fontSizeHeading1: 38,
    fontSizeHeading2: 30,
    fontSizeHeading3: 24,
    linkDecoration: 'underline',

    //Form
    controlItemBgActive: '#f4f4f5',
    controlOutline: 'rgba(24, 24, 27, 0.1)',
    controlHeight: 36,
    controlHeightSM: 32,

    // Layout
    padding: 16,
    boxShadow:
      '0 6px 16px 0 rgba(0, 0, 0, 0.08), 0 3px 6px -4px rgba(0, 0, 0, 0.12), 0 9px 28px 8px rgba(0, 0, 0, 0.05)',
    borderRadius: 6,
    lineType: 'solid',
    lineWidth: 1,
    motion: false,
  },
  components: {
    Form: {
      itemMarginBottom: '22px',
    },

    Layout: {
      headerBg: 'white', // topBar background color
      footerBg: 'white', // footer background color
      bodyBg: 'white', // page background color
      siderBg: '#fbfbfb', // leftBar background color
    },
    Menu: {
      activeBarBorderWidth: 0,
      itemHeight: 30,
      //topbar menu items
      horizontalItemSelectedColor: 'black',
      horizontalItemSelectedBg: 'transparent',
      //leftbar menu items
      itemSelectedColor: 'black',
      itemSelectedBg: 'transparent',
      itemActiveBg: 'transparent',
      //topbar and leftbar menu items
      itemHoverColor: 'black',
      itemHoverBg: 'transparent',
      itemColor: '#909090',
      itemBg: 'transparent',
      iconMarginInlineEnd: 8,
      iconSize: 16,
    },
    Button: {
      paddingInlineSM: 11,
      fontWeight: 500,
    },
  },
}

================
File: src/designSystem/ui/AppHeader/index.tsx
================
import { Logo } from '@/designSystem/layouts/NavigationLayout/components/Logo'
import { Flex, Typography } from 'antd'
import React from 'react'

const { Text, Title } = Typography

type Props = {
  title?: string
  description?: string
}

export const AppHeader: React.FC<Props> = ({
  title = 'Mel the HR',
  description,
}) => {
  return (
    <>
      <Flex justify="center">
        <Logo height="100" />
      </Flex>

      <Flex vertical align="center">
        <Title level={3} style={{ margin: 0 }}>
          {title}
        </Title>
        {description && <Text type="secondary">{description}</Text>}
      </Flex>
    </>
  )
}

================
File: src/designSystem/index.tsx
================
export * from './core'
export * from './layouts'
export * from './provider'
export * from './providers'

================
File: src/designSystem/provider.tsx
================
'use client'

import { ConfigProvider } from 'antd'
import React, {
  ReactNode,
  createContext,
  useContext,
  useEffect,
  useState,
} from 'react'

import { MrbHtml, MrbMain } from './core'
import { Snackbar } from './providers/snackbar'
import './style/main.scss'
import { Theme } from './theme/theme'

export type DesignSystemContext = {
  isMobile: boolean
}

const DesignSystemContext = createContext<DesignSystemContext>({
  isMobile: false,
})

export const useDesignSystem = (): DesignSystemContext => {
  return useContext(DesignSystemContext)
}

const ProviderGeneral = ({ children }) => {
  const [isMobile, setMobile] = useState(false)

  const isWindow = typeof window !== 'undefined'

  const theme = Theme as any

  useEffect(() => {
    if (!isWindow) {
      return
    }

    setMobile(window.innerWidth < 992)

    const handleResize = () => {
      setMobile(window.innerWidth < 992)
    }

    window.addEventListener('resize', handleResize)

    return () => {
      if (!isWindow) {
        return
      }

      window.removeEventListener('resize', handleResize)
    }
  }, [])

  return (
    <ConfigProvider theme={theme}>
      <DesignSystemContext.Provider value={{ isMobile }}>
        {children}
      </DesignSystemContext.Provider>
    </ConfigProvider>
  )
}

type Props = {
  children: ReactNode
}

export const DesignSystemProvider: React.FC<Props> = ({ children }) => {
  return (
    <ProviderGeneral>
      <MrbHtml>
        <MrbMain>
          <Snackbar.Provider>{children}</Snackbar.Provider>
        </MrbMain>
      </MrbHtml>
    </ProviderGeneral>
  )
}

================
File: src/server/libraries/email/internal/providers/mailjet/mailjet.provider.ts
================
import Mailjet from 'node-mailjet'
import { EmailSender, EmailType } from '../../email.type'
import { EmailTemplateService } from '../../templates/email.template.service'
import { Provider, SendOptions } from '../provider'

export class MailjetProvider implements Provider {
  private client: Mailjet
  private templateService = new EmailTemplateService()

  private templateIds: Record<EmailType, number> = {
    [EmailType.DEFAULT]: null,
    [EmailType.AUTHENTICATION_WELCOME]: null,
    [EmailType.AUTHENTICATION_FORGOT_PASSWORD]: null,
    [EmailType.AUTHORIZATION_VERIFICATION_CODE]: null,
  }

  constructor() {
    this.initialise()
  }

  private initialise(): void {
    const isProduction = process.env.NODE_ENV === 'production'

    if (!isProduction) {
      console.warn(`Mailjet is disabled in development`)
      return
    }

    try {
      const apiKey = process.env.SERVER_EMAIL_MAILJET_API_KEY
      const secretKey = process.env.SERVER_EMAIL_MAILJET_SECRET_KEY

      if (!apiKey || !secretKey) {
        console.warn(
          `Set EMAIL_MAILJET_API_KEY and EMAIL_MAILJET_SECRET_KEY to activate Mailjet`,
        )
        return
      }

      this.client = new Mailjet({ apiKey, apiSecret: secretKey })

      console.log(`Mailjet service active`)
    } catch (error) {
      console.error(`Could not start Mailjet service`)
      console.error(error)
    }
  }

  async send(options: SendOptions): Promise<void> {
    const message = this.buildMessage(options)

    return this.client
      .post('send', { version: 'v3.1' })
      .request({
        Messages: [
          {
            ...message,
          },
        ],
      })
      .then(result => {
        console.log(`Emails sent`, result)
      })
      .catch(error => {
        console.error(`Could not send emails (${error.statusCode})`)
      })
  }

  private buildMessage(options: SendOptions): {
    From: { Email: string; Name: string }
    To: { Email: string; Name: string }[]
    Subject: string
    HTMLPart?: string
    Variables?: Record<string, any>
    TemplateLanguage?: boolean
    templateId?: number
  } {
    const from = {
      Email: EmailSender.default.email,
      Name: EmailSender.default.name,
    }

    const to = options.to.map(item => ({ Email: item.email, Name: item.name }))

    const message = {
      From: from,
      To: to,
      Subject: options.subject,
      HTMLPart: undefined,
      Variables: undefined,
      TemplateLanguage: undefined,
      templateId: undefined,
    }

    const templateId = this.templateIds[options.type]

    if (templateId) {
      message.TemplateLanguage = true
      message.templateId = templateId
      message.Variables = options.variables
    } else {
      const content = this.templateService.get(options)

      message.HTMLPart = content
    }

    return message
  }
}

================
File: src/server/libraries/email/internal/providers/nodemailer/nodemailer.provider.ts
================
import * as NodemailerSDK from 'nodemailer'
import Mail from 'nodemailer/lib/mailer'
import { EmailSender } from '../../email.type'
import { EmailTemplateService } from '../../templates/email.template.service'
import { Provider, SendOptions } from '../provider'

export class NodemailerProvider implements Provider {
  private client: Mail
  private templateService = new EmailTemplateService()

  constructor() {
    this.initialise()
  }

  private initialise() {
    try {
      const host = process.env.SERVER_EMAIL_MAILPIT_HOST ?? 'localhost'

      const port = process.env.SERVER_EMAIL_MAILPIT_PORT ?? 1022

      this.client = NodemailerSDK.createTransport({
        host,
        port,
      })

      console.log(`Nodemailer is active (${host}:${port})`)
    } catch (error) {
      console.error(`Nodemailer failed to start: ${error.message}`)
    }
  }

  async send(options: SendOptions): Promise<void> {
    const from = EmailSender.default

    const content = this.templateService.get(options)

    for (const to of options.to) {
      await this.client
        .sendMail({
          from: `${from.name} <${from.email}>`,
          to: to.email,
          subject: options.subject,
          html: content,
        })
        .then(result => {
          console.log(`Emails sent`)
        })
        .catch(error => {
          console.error(`Could not send emails (${error.statusCode})`)
          console.error(error)
        })
    }
  }
}

================
File: src/server/libraries/email/internal/providers/provider.ts
================
import { EmailType } from '../email.type'

export type SendOptions = {
  subject: string

  content?: string

  type: EmailType

  variables?: Record<string, any>

  to: {
    email: string
    name: string
  }[]
}

export interface Provider {
  send(options: SendOptions): Promise<void>
}

================
File: src/server/libraries/email/internal/templates/components.ts
================
export const Components: Record<string, string> = {
  '<Card>': `
      <div class="card">
    `.trim(),
  '</Card>': '</div>',
  '<Card.Header>': `
      <table 
        class="card-header"
        cellpadding="0" 
        cellspacing="0" 
        style="border-collapse:separate;border-spacing:0;table-layout:fixed;width:100%;text-align:center"
      >
        <tbody>
    `.trim(),
  '</Card.Header>': '</tbody></table>',
  '<Card.Body>': `
      <table 
        class="card-body"
        cellpadding="0" 
        cellspacing="0" 
        style="border-collapse:separate;border-spacing:0;table-layout:fixed;width:100%"
      >
        <tbody>
    `.trim(),
  '</Card.Body>': '</tbody></table>',
  '<Card.Footer>': `
      <table 
        class="card-footer"
        cellpadding="0" 
        cellspacing="0" 
        style="border-collapse:separate;border-spacing:0;table-layout:fixed;width:100%;text-align:center"
      >
        <tbody>
    `.trim(),
  '</Card.Footer>': '</tbody></table>',
  '<p>': '<tr><td><p>',
  '</p>': '</p></td></tr>',
  '<h2>': '<tr><td><h2>',
  '</h2>': '</h2></td></tr>',
  '<hr />': '<tr><td><hr /></td></tr>',
}

================
File: src/server/libraries/email/internal/templates/email.template.service.ts
================
import { FileHelper } from '@/core/helpers/file'
import { EmailType } from '../email.type'
import { SendOptions } from '../providers/provider'
import { Components } from './components'

export class EmailTemplateService {
  private pathTemplates: string = `${FileHelper.getRoot()}/assets/emails`

  private mapping: Record<EmailType, string> = {
    [EmailType.AUTHORIZATION_VERIFICATION_CODE]:
      'authorization-verification-code',
    [EmailType.AUTHENTICATION_WELCOME]: 'authentication-welcome',
    [EmailType.AUTHENTICATION_FORGOT_PASSWORD]:
      'authentication-forgot-password',
    [EmailType.DEFAULT]: 'default',
  }

  get(options: SendOptions): string {
    const values = options.variables ?? { content: options.content }

    const pathBase = this.getPathBase()

    const pathCSS = this.getPathCSS()

    const pathTemplate = this.getPathTemplate(options.type)

    const contentBase = FileHelper.findFileContent(pathBase)

    const contentCSS = FileHelper.findFileContent(pathCSS)

    const contentTemplate = FileHelper.findFileContent(pathTemplate)

    let content = this.buildContent(contentTemplate, values)

    content = this.buildContent(contentBase, { style: contentCSS, content })

    content = this.buildComponents(content)

    return content
  }

  private getPathTemplate(type: EmailType): string {
    const name = this.mapping[type] ?? this.mapping[EmailType.DEFAULT]

    const path = `${this.pathTemplates}/${name}.template.html`

    return path
  }

  private getPathBase(): string {
    const path = `${this.pathTemplates}/base.html`

    return path
  }

  private getPathCSS(): string {
    const path = `${this.pathTemplates}/style.css`

    return path
  }

  private buildContent(content: string, values: Record<string, any>): string {
    let contentBuilt = content

    for (const [key, value] of Object.entries(values)) {
      const token = new RegExp(`\{\{ ${key} \}\}`, 'g')

      contentBuilt = contentBuilt.replace(token, value)
    }

    return contentBuilt
  }

  private buildComponents(content: string): string {
    let contentUpdated = content

    for (const [key, value] of Object.entries(Components)) {
      const tag = new RegExp(`${key}`, 'g')
      contentUpdated = contentUpdated.replace(tag, value)
    }

    return contentUpdated
  }
}

================
File: src/server/libraries/email/internal/email.type.ts
================
export enum EmailType {
  DEFAULT = 'default',
  AUTHENTICATION_WELCOME = 'authentication.welcome.password',
  AUTHENTICATION_FORGOT_PASSWORD = 'authentication.forgot.password',
  AUTHORIZATION_VERIFICATION_CODE = 'authorization.verification.code',
}

export const EmailSender = {
  default: {
    email: 'no-reply@marblism.com',
    name: 'Marblism',
  },
}

================
File: src/server/libraries/email/email.service.ts
================
import { EmailType } from './internal/email.type'
import { MailjetProvider } from './internal/providers/mailjet/mailjet.provider'
import { NodemailerProvider } from './internal/providers/nodemailer/nodemailer.provider'
import { Provider } from './internal/providers/provider'

type SendOptions = {
  name: string
  email: string
  subject: string
  type: EmailType
  content?: string
  variables: Record<string, string>
}

export class Service {
  private provider: Provider

  public Type = EmailType

  constructor() {
    const isProduction = process.env.NODE_ENV === 'production'

    if (isProduction) {
      this.provider = new MailjetProvider()
    } else {
      this.provider = new NodemailerProvider()
    }
  }

  async send(options: SendOptions): Promise<void> {
    return this.provider
      .send({
        type: options.type,
        content: options.content,
        to: [
          {
            name: options.name,
            email: options.email,
          },
        ],
        variables: options.variables,
        subject: options.subject,
      })
      .then(() => {
        console.log(`Email sent to ${options.email}`, options)
      })
  }
}

class Singleton {
  static service = new Service()
}

export const EmailService = Singleton.service

================
File: src/server/libraries/email/index.ts
================
export * from './email.service'

================
File: src/server/libraries/openai/internal/openai.ts
================
import { ReadStream } from 'fs'
import OpenaiSDK from 'openai'
import { zodResponseFormat } from 'openai/helpers/zod'
import { ParsedChatCompletion } from 'openai/resources/beta/chat/completions'
import { z, ZodType } from 'zod'

enum OpenaiModel {
  DEFAULT = 'gpt-4o-mini',
  JSON = 'gpt-4o-mini',
  IMAGE = 'dall-e-3',
  AUDIO_TO_TEXT = 'whisper-1',
  TEXT_TO_AUDIO = 'tts-1',
}

export class Openai {
  private api: OpenaiSDK
  private assistantApi: OpenaiSDK
  private exampleAssistantId: any

  constructor() {
    this.initialize()
  }

  private initialize(): void {
    try {
      const apiKey = process.env.SERVER_OPENAI_API_KEY
      const exampleAssistantId = process.env.TEST_ASSISTANT_PMF_HB_ID
      const assistKey = process.env.ASSISTANT_API_KEY

      if (!apiKey) {
        console.log(`Set SERVER_OPENAI_API_KEY in your .env to activate OpenAI`)
        return
      }
      if (!exampleAssistantId) {
        console.log(
          `Set TEST_ASSISTANT_PMF_HB_ID in your .env to activate OpenAI Assistants`,
        )
        return
      }

      this.assistantApi = new OpenaiSDK({ apiKey: assistKey })
      this.api = new OpenaiSDK({ apiKey })
      this.exampleAssistantId = exampleAssistantId

      console.log(`Openai is active`)
    } catch (error) {
      console.error(`Openai failed to start`)
    }
  }

  isActive(): boolean {
    if (this.api) {
      return true
    } else {
      return false
    }
  }

  async generateText(
    prompt: string,
    attachmentUrls?: string[],
  ): Promise<string> {
    console.log('in generateText - building messages first', { prompt })
    const messages = this.buildMessages(prompt, attachmentUrls)

    const response = await this.api.chat.completions.create({
      model: OpenaiModel.DEFAULT,
      messages: messages,
    })

    const content = this.parseResponseContent(response)

    return content
  }

  async generateAssistantText(
    prompt: string,
    attachmentUrls?: string[],
  ): Promise<string> {
    console.log('in generateAssistantText - building messages first', {
      prompt,
    })
    const messages = this.buildMessages(prompt, attachmentUrls)
    const thread = await this.assistantApi.beta.threads.create({
      messages,
    })
    let threadId = thread.id
    console.log('Created thread with Id: ' + threadId)

    // See if we can create an assistant
    // const assistant = await this.api.beta.assistants.create({
    //   model: OpenaiModel.DEFAULT,
    //   name: 'Math Tutor',
    //   instructions: 'You are working in the HR department.',
    //   // tools = [],
    // })
    const run = await this.assistantApi.beta.threads.runs.createAndPoll(
      thread.id,
      {
        assistant_id: this.exampleAssistantId,
        //assistant_id: assistant.id,
      },
    )

    console.log('Run finished with status: ' + run.status)

    if (run.status == 'completed') {
      const messages = await this.assistantApi.beta.threads.messages.list(
        thread.id,
      )
      const paginatedMsgs = messages.getPaginatedItems()
      return paginatedMsgs[0]?.content[0]?.text?.value
      // for (const message of messages.getPaginatedItems()) {
      //   console.log(message);
      // }
    }

    return null
  }

  async generateJson<
    SchemaType extends ZodType,
    JsonType = z.infer<SchemaType>,
  >(
    instruction: string,
    content: string,
    schema: SchemaType,
    attachmentUrls?: string[],
  ): Promise<JsonType> {
    const messages = this.buildMessages(content, attachmentUrls)

    const response = await this.api.beta.chat.completions.parse({
      model: OpenaiModel.JSON,
      messages: [{ role: 'system', content: instruction }, ...messages],
      response_format: zodResponseFormat(schema, 'result'),
    })

    const json = this.parseResponseJson<JsonType>(response)

    return json
  }

  async generateImage(prompt: string): Promise<string> {
    const response = await this.api.images.generate({
      model: OpenaiModel.IMAGE,
      prompt: prompt,
    })

    const imageUrl = this.parseResponseImage(response)

    return imageUrl
  }

  async fromAudioToText(readStream: ReadStream): Promise<string> {
    const transcription = await this.api.audio.transcriptions.create({
      file: readStream,
      model: OpenaiModel.AUDIO_TO_TEXT,
    })

    return transcription.text
  }

  async fromTextToAudio(text: string): Promise<Buffer> {
    const mp3 = await this.api.audio.speech.create({
      model: OpenaiModel.TEXT_TO_AUDIO,
      voice: 'alloy',
      input: text,
    })

    const buffer = Buffer.from(await mp3.arrayBuffer())

    return buffer
  }

  private buildMessages(content: string, attachmentUrls: string[] = []) {
    const message = {
      role: 'user',
      content: [
        { type: 'text', text: content },
        ...attachmentUrls.map(url => ({
          type: 'image_url',
          image_url: { url },
        })),
      ],
    }

    return [message] as OpenaiSDK.Chat.Completions.ChatCompletionMessageParam[]
  }

  private parseResponseContent(
    response: OpenaiSDK.Chat.Completions.ChatCompletion,
  ): string {
    return response.choices[0].message.content
  }

  private parseResponseImage(
    response: OpenaiSDK.Images.ImagesResponse,
  ): string {
    return response.data[0].url
  }

  private parseResponseJson<JsonType = unknown>(
    response: ParsedChatCompletion<JsonType>,
  ) {
    return response.choices[0].message.parsed
  }
}

================
File: src/server/libraries/openai/index.ts
================
import { ReadStream } from 'fs'
import { ZodType } from 'zod'
import { Openai } from './internal/openai'

class Service {
  private openai = new Openai()

  async generateText(
    prompt: string,
    attachmentUrls?: string[],
  ): Promise<string> {
    // Use regular openAI generateText
    return this.openai.generateText(prompt, attachmentUrls)
    // Use our assistant AI
    //return this.openai.generateAssistantText(prompt, attachmentUrls)
  }
  async generateAssistantText(
    prompt: string,
    attachmentUrls?: string[],
  ): Promise<string> {
    // Use regular openAI generateText
    //return this.openai.generateText(prompt, attachmentUrls)
    // Use our assistant AI
    return this.openai.generateAssistantText(prompt, attachmentUrls)
  }

  async generateJson<SchemaType extends ZodType>(
    instruction: string,
    content: string,
    schema: SchemaType,
    attachmentUrls?: string[],
  ) {
    return this.openai.generateJson<SchemaType>(
      instruction,
      content,
      schema,
      attachmentUrls,
    )
  }

  async generateImage(prompt: string): Promise<string> {
    return this.openai.generateImage(prompt)
  }

  async fromAudioToText(readStream: ReadStream): Promise<string> {
    return this.openai.fromAudioToText(readStream)
  }

  async fromTextToAudio(text: string): Promise<Buffer> {
    return this.openai.fromTextToAudio(text)
  }

  isActive(): boolean {
    return this.openai.isActive()
  }
}

class Singleton {
  static service = new Service()
}

export const OpenaiService = Singleton.service

================
File: src/server/libraries/payment/internal/providers/stripe/stripe.provider.ts
================
import { Utility } from '@/core/helpers/utility'
import { Stripe as StripeSDK } from 'stripe'
import {
  Payment,
  Product,
  ProductType,
  StripeWebhookResponse,
  Subscription,
} from '../../../payment.type'
import { Provider, ProviderCreatePaymentLinkOptions } from '../provider'

export class StripeProvider implements Provider {
  private client: StripeSDK
  private webhookSecret: string

  constructor() {
    this.initialise()
  }

  isActive(): boolean {
    if (this.client) {
      return true
    } else {
      return false
    }
  }

  private initialise(): void {
    console.log('Initialization...')

    try {
      const secretKey = process.env.SERVER_PAYMENT_STRIPE_SECRET_KEY

      this.webhookSecret = process.env.SERVER_PAYMENT_STRIPE_WEBHOOK_SECRET

      if (!secretKey) {
        throw new Error(
          'Set SERVER_PAYMENT_STRIPE_SECRET_KEY in your .env to activate',
        )
      }

      this.client = new StripeSDK(secretKey, {
        apiVersion: '2024-04-10',
      })

      console.log(`Stripe active`)
    } catch (error) {
      console.warn(`Stripe failed to start`)
      console.warn(error.message)
    }
  }

  async findManySubscriptions(customerId: string): Promise<Subscription[]> {
    const response = await this.client.subscriptions.list({
      customer: customerId,
    })

    const subscriptions = []

    for (const subscription of response.data) {
      subscriptions.push({
        productId: subscription.items?.data?.[0].price?.product,
        dateExpired: new Date(subscription.current_period_end * 1000),
        status: subscription.status,
      })
    }
    return subscriptions
  }

  async findManyPayments(customerId: string): Promise<Payment[]> {
    const response = await this.client.checkout.sessions.list({
      expand: ['data.line_items'],
      customer: customerId,
    })
    const checkoutSessions = response.data?.filter(
      session => session.payment_status === 'paid',
    )

    const payments = []

    for (const session of checkoutSessions) {
      for (const lineItem of session.line_items.data) {
        payments.push({
          productId: lineItem.price.product,
          amount: lineItem.price.unit_amount / 100,
          currency: lineItem.price.currency,
          date: new Date(session.created * 1000),
        })
      }
    }

    return payments
  }

  async findManyProducts(): Promise<Product[]> {
    const response = await this.client.products.list({
      expand: ['data.default_price'],
    })

    const products = []

    for (const item of response.data) {
      if (!item.active) {
        continue
      }

      const product: Product = {
        id: item.id,
        type: ProductType.ONE_TIME,
        name: item.name,
        price: 0,
        interval: null,
        description: item.description,
        currency: 'usd',
        coverUrl: item.images[0] ?? 'https://i.imgur.com/iQyYgUS.jpeg',
      }

      const price = item.default_price as StripeSDK.Price

      if (price?.recurring) {
        product.type = ProductType.SUBSCRIPTION
        product.interval = price.recurring.interval
      }

      if (Utility.isDefined(price?.unit_amount)) {
        product.price = price.unit_amount / 100 ?? 0
        product.currency = price.currency
      }

      products.push(product)
    }

    const productsOrdered = products.sort((a, b) => a.price - b.price)

    return productsOrdered
  }

  async onPayment(body: Buffer, sig: string): Promise<StripeWebhookResponse> {
    try {
      if (!this.webhookSecret) {
        throw new Error(
          'Set SERVER_PAYMENT_STRIPE_WEBHOOK_SECRET in your .env to activate',
        )
      }

      const event = this.client.webhooks.constructEvent(
        body.toString(),
        sig,
        this.webhookSecret,
      ) as StripeSDK.CheckoutSessionCompletedEvent

      const data = event.data?.object

      if (event.type === 'checkout.session.completed') {
        console.log(`Stripe event "${event.type}" received`)

        return {
          userId: data.client_reference_id ?? data.metadata?.userId,

          organizationId: data.metadata?.organizationId,

          stripeCustomerId: data.customer as string,
          metadata: data.metadata ?? {},
          customerDetails: data.customer_details,
        }
      }

      console.log(`Stripe event "${event.type}" is not handled.`)

      return null
    } catch (error) {
      throw new Error(`Could not check webhook: ${error.message}`)
    }
  }

  async createPaymentLink({
    customerId,
    productId,
    urlRedirection,
    metadata = {},
  }: ProviderCreatePaymentLinkOptions): Promise<string> {
    const price = await this.findOnePriceByIdOrFail(productId)

    const session = await this.client.checkout.sessions.create({
      line_items: [
        {
          price: price.id,
          quantity: 1,
        },
      ],
      mode: price.recurring ? 'subscription' : 'payment',
      customer: customerId,
      ui_mode: 'hosted',
      success_url: urlRedirection,
      metadata: { ...metadata, productId },
    })

    return session.url
  }

  async createCustomer(customer: {
    name: string
    email: string
  }): Promise<string> {
    const result = await this.client.customers.create({
      name: customer.name,
      email: customer.email,
    })

    return result.id
  }

  private async findOnePriceByIdOrFail(
    productId: string,
  ): Promise<StripeSDK.Price> {
    const prices = await this.client.prices.list({
      product: productId,
      limit: 1,
    })

    const price = prices.data?.[0]

    if (!price) {
      throw new Error(`Could not find price for product ${productId}`)
    }

    return price
  }
}

================
File: src/server/libraries/payment/internal/providers/provider.ts
================
import {
  Payment,
  Product,
  StripeWebhookResponse,
  Subscription,
} from '../../payment.type'

export type ProviderCreatePaymentLinkOptions = {
  customerId: string
  productId: string
  metadata?: Record<string, string>
  urlRedirection?: string
}

export interface Provider {
  createCustomer(customer: { email: string; name: string }): Promise<string>
  createPaymentLink(options: ProviderCreatePaymentLinkOptions): Promise<string>
  findManySubscriptions(customerId: string): Promise<Subscription[]>
  findManyPayments(customerId: string): Promise<Payment[]>
  findManyProducts(): Promise<Product[]>
  onPayment(body: Buffer, sig: string): Promise<StripeWebhookResponse>
  isActive(): boolean
}

================
File: src/server/libraries/payment/index.ts
================
export * from './payment.service'
export * from './payment.type'

================
File: src/server/libraries/payment/payment.service.ts
================
import { User } from '@prisma/client'
import { Provider } from './internal/providers/provider'
import { StripeProvider } from './internal/providers/stripe/stripe.provider'
import {
  Payment,
  Product,
  StripeWebhookResponse,
  Subscription,
} from './payment.type'

import { Organization } from '@prisma/client'

class Service {
  private provider: Provider = new StripeProvider()

  isActive(): boolean {
    if (this.provider) {
      return this.provider?.isActive()
    }

    return false
  }

  getCustomerId(user: User | Organization): string {
    return user.stripeCustomerId
  }

  async findManyProducts(): Promise<Product[]> {
    return this.provider.findManyProducts()
  }

  async findManySubscriptions(
    customer: User | Organization,
  ): Promise<Subscription[]> {
    return this.provider.findManySubscriptions(this.getCustomerId(customer))
  }

  async findManyPayments(user: User): Promise<Payment[]> {
    return this.provider.findManyPayments(this.getCustomerId(user))
  }

  async createPaymentLink(options: {
    user: User

    organization: Organization

    productId: string
    metadata?: Record<string, string>
    urlRedirection?: string
  }): Promise<string> {
    const optionsPayment = {
      ...options,

      customerId: this.getCustomerId(options.organization ?? options.user),
    }

    return this.provider.createPaymentLink(optionsPayment)
  }

  async onPayment(body: Buffer, sig: string): Promise<StripeWebhookResponse> {
    return this.provider.onPayment(body, sig)
  }

  async createCustomer(
    customer: User,

    organization?: Organization,
  ): Promise<string> {
    return this.provider.createCustomer({
      name: organization?.name ?? customer.name ?? customer.email,

      email: customer.email,
    })
  }
}

class Singleton {
  static service = new Service()
}

export const PaymentService = Singleton.service

================
File: src/server/libraries/payment/payment.type.ts
================
import { Stripe as StripeSDK } from 'stripe'

export type Subscription = {
  productId: string
  dateExpired: string
  status: string
}

export type Payment = {
  productId: string
  amount: number
  currency: string
  date: string
}

export enum ProductType {
  SUBSCRIPTION = 'SUBSCRIPTION',
  ONE_TIME = 'ONE_TIME',
}

export type Product = {
  id: string
  type: ProductType
  name: string
  price: number
  description: string
  interval?: string
  coverUrl?: string
  currency: string
}

export type StripeWebhookResponse = {
  userId: string

  organizationId?: string

  stripeCustomerId: string
  metadata: Record<string, string>
  customerDetails?: StripeSDK.Checkout.Session.CustomerDetails
}

================
File: src/server/libraries/rag/index.ts
================
import { DatabaseUnprotected } from '@/core/database/internal/unprotected'
import { FileHelper } from '@/core/helpers/file'
import { Utility } from '@/core/helpers/utility'
import { HNSWLib } from '@langchain/community/vectorstores/hnswlib'
import { AIMessage, BaseMessage, HumanMessage } from '@langchain/core/messages'
import {
  ChatPromptTemplate,
  MessagesPlaceholder,
} from '@langchain/core/prompts'
import { ChatOpenAI, OpenAIEmbeddings } from '@langchain/openai'
import { RagVector } from '@prisma/client'
import axios from 'axios'
import * as cheerio from 'cheerio'
import * as crypto from 'crypto'
import { createStuffDocumentsChain } from 'langchain/chains/combine_documents'
import { createHistoryAwareRetriever } from 'langchain/chains/history_aware_retriever'
import { createRetrievalChain } from 'langchain/chains/retrieval'
import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter'
import mammoth from 'mammoth'
import Papaparse from 'papaparse'
import PdfParse from 'pdf-parse'

const downloadFile = async (url: string) => {
  try {
    const response = await axios.get(url, { responseType: 'arraybuffer' })
    const dataBuffer = Buffer.from(response.data, 'binary')
    return dataBuffer
  } catch (error) {
    throw new Error(`Could not dowload file at "${url}"`)
  }
}

const downloadWebPage = async (url: string) => {
  try {
    const response = await axios.get(url)

    const $ = cheerio.load(response.data)

    const textContent = $('body').text()

    return textContent.split('\n').filter(line => Utility.isDefined(line))
  } catch (error) {
    throw new Error(`Could not fetch web page: ${error.message}`)
  }
}

const parsePDF = async (buffer: Buffer) => {
  const data = await PdfParse(buffer)

  return data.text.split('\n').filter(line => Utility.isDefined(line))
}

const parseCSV = async (buffer: Buffer): Promise<string[]> => {
  return new Promise((resolve, reject) => {
    Papaparse.parse(buffer.toString(), {
      complete: results => {
        const content = JSON.stringify(results)
        const lines = content
          .split('\n')
          .filter(line => Utility.isDefined(line))
        resolve(lines)
      },
      error: error => {
        reject(error)
      },
    })
  })
}

const parseDOCX = async (buffer: Buffer) => {
  const result = await mammoth.extractRawText({ buffer: buffer })
  return result.value.split('\n').filter(line => Utility.isDefined(line))
}

const buildDocuments = async (lines: string[]) => {
  const MAX_LINES = 10000 // Security to avoid loading huge files

  const textSplitter = new RecursiveCharacterTextSplitter({
    chunkSize: 1000,
    chunkOverlap: 100,
    separators: ['\n'],
  })

  const texts = lines.slice(0, MAX_LINES)

  const documents = await textSplitter.createDocuments([texts.join('\n')])

  return documents
}

const createHash = (input: string) => {
  const hash = crypto.createHash('sha256').update(input).digest('base64')
  return hash.slice(0, 8)
}

const createRetriever = async (vectorStore: HNSWLib, model: ChatOpenAI) => {
  const retriever = vectorStore.asRetriever()

  const contextualizeQSystemPrompt = `
Given a chat history and the latest user question
which might reference context in the chat history,
formulate a standalone question which can be understood
without the chat history. Do NOT answer the question, just
reformulate it if needed and otherwise return it as is.`

  const contextualizeQPrompt = ChatPromptTemplate.fromMessages([
    ['system', contextualizeQSystemPrompt],
    new MessagesPlaceholder('chat_history'),
    ['human', '{input}'],
  ])

  const historyAwareRetriever = await createHistoryAwareRetriever({
    llm: model,
    retriever,
    rephrasePrompt: contextualizeQPrompt,
  })

  return historyAwareRetriever
}

const createPromptSystem = (personality?: string) => {
  const personalityDefault =
    `You are an assistant for question-answering tasks. Use
  the following pieces of retrieved context to answer the
  question. If you don't know the answer, just say that you
  don't know. Use three sentences maximum and keep the answer
  concise.`.trim()

  const system = `
${personality ?? personalityDefault}
\n\n
{context}`

  const prompt = ChatPromptTemplate.fromMessages([
    ['system', system],
    new MessagesPlaceholder('chat_history'),
    ['human', '{input}'],
  ])

  return prompt
}

const getVectors = (vectorStore: HNSWLib) => {
  const index = vectorStore.index

  const vectors = []

  for (let i = 0; i < index.getCurrentCount(); i++) {
    vectors.push(index.getPoint(i))
  }

  return vectors
}

const createModel = () => {
  try {
    return new ChatOpenAI({
      openAIApiKey: process.env.SERVER_OPENAI_API_KEY,
      model: 'gpt-4o-mini',
      temperature: 0,
    })
  } catch (error) {
    return
  }
}

const createEmbeddings = () => {
  try {
    return new OpenAIEmbeddings({
      openAIApiKey: process.env.SERVER_OPENAI_API_KEY,
    })
  } catch (error) {
    return
  }
}

class Service {
  private model = createModel()

  private embeddings = createEmbeddings()

  private pathStorage = FileHelper.getRoot() + `/tmp/rag/vectors`

  private vectorStore: HNSWLib

  async createAndSaveFile(url: string, tags: string[] = []) {
    const key = createHash(url)

    const ragVectorFound = await DatabaseUnprotected.ragVector.findFirst({
      where: {
        key,
      },
    })

    if (ragVectorFound) {
      console.log(`Vector already exists for "${url}".`)

      return ragVectorFound
    }

    const type = FileHelper.getFileType(url)

    let lines: string[]

    if (type === 'unknown') {
      lines = await downloadWebPage(url)
    } else {
      const buffer = await downloadFile(url)

      switch (type) {
        case 'pdf':
          lines = await parsePDF(buffer)
          break
        case 'csv':
          lines = await parseCSV(buffer)
          break
        case 'docx':
          lines = await parseDOCX(buffer)
          break
        default:
          throw new Error(
            `File type is not supported. Supported types are PDF, DOCX, CSV and web pages`,
          )
      }
    }

    const documents = await buildDocuments(lines)

    const vectorStore = await HNSWLib.fromDocuments(documents, this.embeddings)

    const vectors = getVectors(vectorStore)

    const vectorsBuffer = Buffer.from(JSON.stringify(vectors))
    const documentsBuffer = Buffer.from(JSON.stringify(documents))

    const ragVector = await DatabaseUnprotected.ragVector.create({
      data: {
        key,
        url,
        vectors: vectorsBuffer,
        documents: documentsBuffer,
        tags: [key, ...tags],
      },
    })

    const { vectorStore: vectorStoreGlobal } =
      await this.createVectorStoreGlobal()

    this.vectorStore = vectorStoreGlobal

    return ragVector
  }

  /**
   * ? If tags are provided, we create a temporary vector store with the right subset of vectors.
   * ? Otherwise, we use the global store.
   */
  async query(prompt: string, history: string[] = [], tags: string[] = []) {
    let vectorStore: HNSWLib
    let pathStorageToClean: string

    const isTemporary = tags.length > 0

    if (isTemporary) {
      console.log('Creating vector store by tags...')
      const result = await this.createVectorStoreByTags(tags)

      vectorStore = result.vectorStore
      pathStorageToClean = result.pathStorage
    } else if (!this.vectorStore) {
      console.log('Refreshing global vector store...')

      const result = await this.createVectorStoreGlobal()

      this.vectorStore = result.vectorStore
      vectorStore = result.vectorStore
    } else {
      console.log('Using global vector store...')
      vectorStore = this.vectorStore
    }

    const retriever = await createRetriever(vectorStore, this.model)

    const promptSystem = createPromptSystem()

    const questionAnswerChain = await createStuffDocumentsChain({
      llm: this.model,
      prompt: promptSystem,
    })

    const ragChain = await createRetrievalChain({
      retriever: retriever,
      combineDocsChain: questionAnswerChain,
    })

    const MAX_HISTORY = 20
    const chat_history: BaseMessage[] = history
      .slice(0, MAX_HISTORY)
      .map((content, index) =>
        index % 2 === 0 ? new HumanMessage(content) : new AIMessage(content),
      )

    const response = await ragChain.invoke({
      chat_history,
      input: prompt,
    })

    if (pathStorageToClean) {
      FileHelper.deleteFolder(pathStorageToClean)
    }

    return response.answer
  }

  /**
   * Vector Store to query all files from the RAG context
   */
  private async createVectorStoreGlobal() {
    const ragVectors = await DatabaseUnprotected.ragVector.findMany({
      select: {
        id: true,
        key: true,
        url: true,
        tags: true,
        vectors: true,
        documents: true,
      },
    })

    if (ragVectors.length === 0) {
      throw new Error(`no rag vectors found`)
    }

    const pathVectorStore = `${this.pathStorage}/global`

    const vectorStore = await this.createVectorStore(
      ragVectors,
      pathVectorStore,
    )

    return { vectorStore, pathStorage: pathVectorStore }
  }

  /**
   * Vector Store to query some files from the RAG context filtered by tags
   */
  private async createVectorStoreByTags(tags: string[]) {
    const ragVectors = await DatabaseUnprotected.ragVector
      .findMany({
        select: {
          id: true,
          key: true,
          url: true,
          tags: true,
          vectors: true,
          documents: true,
        },
      })
      .then(items =>
        items.filter(item => item.tags.some(tag => tags.includes(tag))),
      )

    if (ragVectors.length === 0) {
      throw new Error(
        `no rag vectors found matching tags: ${tags.map(tag => `"${tag}"`).join(', ')}`,
      )
    }

    const id = Utility.getUUID()

    const pathVectorStore = `${this.pathStorage}/${id}`

    const vectorStore = await this.createVectorStore(
      ragVectors,
      pathVectorStore,
    )

    return {
      vectorStore,
      pathStorage: pathVectorStore,
    }
  }

  private async createVectorStore(
    ragVectors: RagVector[],
    pathStorage: string,
  ) {
    const data = await Promise.all(
      ragVectors.map(ragVector => {
        const vectorsAsString = ragVector.vectors.toString('utf-8')
        const documentsAsString = ragVector.documents.toString('utf-8')

        const vectors = JSON.parse(vectorsAsString)
        const documents = JSON.parse(documentsAsString)

        return [vectors, documents]
      }),
    )

    FileHelper.deleteFolder(pathStorage)

    const vectorStore = await HNSWLib.fromDocuments([], this.embeddings)

    for (const [vectors, documents] of data) {
      vectorStore.addVectors(vectors, documents)
    }

    await vectorStore.save(pathStorage)

    return vectorStore
  }
}

class Singleton {
  static service = new Service()
}

export const RagService = Singleton.service

================
File: src/server/libraries/upload/internal/providers/aws/upload.provider.aws.ts
================
import { DateHelper } from '@/core/helpers/date'
import { Utility } from '@/core/helpers/utility'
import {
  GetObjectCommand,
  ListBucketsCommand,
  PutObjectCommand,
  S3Client,
} from '@aws-sdk/client-s3'
import { getSignedUrl } from '@aws-sdk/s3-request-presigner'
import axios, { AxiosRequestConfig } from 'axios'
import {
  FromPrivateToPublicUrlOptions,
  UploadPrivateOptions,
  UploadPrivateReturn,
  UploadProvider,
  UploadPublicOptions,
  UploadPublicReturn,
} from '../../../upload.provider'

const ONE_HOUR_IN_SECONDS = 60 * 60

type Bucket = {
  dateCreation: Date
  name: string
}

type Credentials = {
  accessKeyId: string
  secretAccessKey: string
  sessionToken: string
  expiration: Date
}

type CredentialsResponse = {
  accessKeyId: string
  secretAccessKey: string
  sessionToken: string
  expiration: string
  bucketNamePrivate: string
  bucketNamePublic: string
  bucketKey: string
}

export class UploadProviderAws extends UploadProvider {
  private static isMarblismInitialised: boolean = false

  private client: S3Client
  private bucketNamePublic: string
  private bucketNamePrivate: string
  private region: string
  private credentials: Credentials
  private marblismApiKey: string
  private bucketKey: string

  private httpClient = axios.create()

  private httpClientOptions: AxiosRequestConfig<any> = {
    headers: {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    },
  }

  public async initialise() {
    this.region = process.env.SERVER_UPLOAD_AWS_REGION

    if (Utility.isNull(this.region)) {
      this.region = 'us-west-1'
    }

    try {
      this.marblismApiKey = process.env.SERVER_UPLOAD_MARBLISM_API_KEY

      if (Utility.isDefined(this.marblismApiKey)) {
        if (UploadProviderAws.isMarblismInitialised) {
          return
        }

        await this.initializeWithMarblism()

        console.log(`AWS library (Marblism) active in region ${this.region}`)

        UploadProviderAws.isMarblismInitialised = true

        return
      }
    } catch (error) {
      console.warn(`AWS library (Marblism) failed to start: ${error.message}`)
    }

    try {
      const accessKey = process.env.SERVER_UPLOAD_AWS_ACCESS_KEY

      const secretKey = process.env.SERVER_UPLOAD_AWS_SECRET_KEY

      if (!accessKey && !secretKey) {
        throw new Error(
          'Set SERVER_UPLOAD_AWS_ACCESS_KEY && SERVER_UPLOAD_AWS_SECRET_KEY in your .env to activate',
        )
      }

      if (!accessKey) {
        throw new Error(
          'Set SERVER_UPLOAD_AWS_ACCESS_KEY in your .env to activate',
        )
      }

      if (!secretKey) {
        throw new Error(
          'Set SERVER_UPLOAD_AWS_SECRET_KEY in your .env to activate',
        )
      }

      this.bucketNamePublic = process.env.SERVER_UPLOAD_AWS_BUCKET_PUBLIC_NAME

      if (!this.bucketNamePublic) {
        console.warn(
          `Set SERVER_UPLOAD_AWS_BUCKET_PUBLIC_NAME in your .env to activate a public bucket with infinite urls`,
        )
      }

      this.bucketNamePrivate = process.env.SERVER_UPLOAD_AWS_BUCKET_PRIVATE_NAME

      if (!this.bucketNamePrivate) {
        console.warn(
          `Set SERVER_UPLOAD_AWS_BUCKET_PRIVATE_NAME in your .env to activate a private bucket with signed urls`,
        )
      }

      this.client = new S3Client({
        region: this.region,
        credentials: {
          accessKeyId: accessKey,
          secretAccessKey: secretKey,
        },
      })

      await this.check()

      console.log(`AWS library active in region ${this.region}`)
    } catch (error) {
      console.warn(`AWS library failed to start`)

      throw new Error(error)
    }
  }

  private async initializeWithMarblism() {
    const url = `/v1/addons/upload/create-credentials`

    this.setApiKey(this.marblismApiKey)

    const response = await this.postMarblism<CredentialsResponse>(url)

    this.bucketNamePrivate = response.bucketNamePrivate
    this.bucketNamePublic = `${response.bucketNamePublic}`

    this.credentials = {
      accessKeyId: response.accessKeyId,
      secretAccessKey: response.secretAccessKey,
      sessionToken: response.sessionToken,
      expiration: new Date(response.expiration),
    }

    this.bucketKey = response.bucketKey

    this.client = new S3Client({
      region: this.region,
      credentials: {
        accessKeyId: this.credentials.accessKeyId,
        secretAccessKey: this.credentials.secretAccessKey,
        sessionToken: this.credentials.sessionToken,
      },
    })

    await this.check()
  }

  private async ensureCredentials() {
    if (!UploadProviderAws.isMarblismInitialised) {
      return
    }

    if (this.areCredentialsValid()) {
      return
    }

    const url = `/v1/addons/upload/refresh-credentials`

    this.setApiKey(this.marblismApiKey)

    const response = await this.postMarblism<CredentialsResponse>(url)

    this.credentials = {
      accessKeyId: response.accessKeyId,
      secretAccessKey: response.secretAccessKey,
      sessionToken: response.sessionToken,
      expiration: new Date(response.expiration),
    }

    this.client = new S3Client({
      region: this.region,
      credentials: {
        accessKeyId: this.credentials.accessKeyId,
        secretAccessKey: this.credentials.secretAccessKey,
        sessionToken: this.credentials.sessionToken,
      },
    })

    await this.check()
  }

  private areCredentialsValid(): boolean {
    const isTokenDefined = Utility.isDefined(this.credentials)

    const isTokenValid =
      isTokenDefined &&
      DateHelper.isBefore(DateHelper.getNow(), this.credentials.expiration)

    return isTokenValid
  }

  private async check(): Promise<void> {
    const buckets = await this.listBuckets()

    if (this.bucketNamePrivate) {
      console.log(`Checking bucket "${this.bucketNamePrivate}"...`)

      const bucket = buckets.find(
        bucket => bucket.name === this.bucketNamePrivate,
      )

      if (bucket) {
        console.log(`Bucket "${this.bucketNamePrivate}" is active`)
      } else {
        throw new Error(`Bucket "${this.bucketNamePrivate}" was not found`)
      }
    }

    if (this.bucketNamePublic) {
      console.log(`Checking bucket "${this.bucketNamePublic}"...`)

      const bucket = buckets.find(
        bucket => bucket.name === this.bucketNamePublic,
      )

      if (bucket) {
        console.log(`Bucket "${this.bucketNamePublic}" is active`)
      } else {
        throw new Error(`Bucket "${this.bucketNamePublic}" was not found`)
      }
    }
  }

  public async uploadPublic(
    options: UploadPublicOptions,
  ): Promise<UploadPublicReturn> {
    await this.ensureCredentials()

    const { file } = options

    let key = this.ensureFilename(file.name)

    key = this.ensureKey(key)

    const command = new PutObjectCommand({
      Bucket: `${this.bucketNamePublic}`,
      Key: key,
      Body: file.buffer,
      ContentType: file.mimetype,
    })

    try {
      await this.client.send(command)

      console.log(`File ${file.name} saved (public)`)

      const url = `${this.getBaseUrlPublic()}/${key}`

      return { url }
    } catch (error) {
      console.error(`${error}`)
      throw new Error(`Could not upload public file with key "${key}"`)
    }
  }

  public async uploadPrivate(
    options: UploadPrivateOptions,
  ): Promise<UploadPrivateReturn> {
    await this.ensureCredentials()

    const { file } = options

    const key = this.ensureFilename(file.name)

    const command = new PutObjectCommand({
      Bucket: `${this.bucketNamePrivate}`,
      Key: this.ensureKey(key),
      Body: file.buffer,
      ContentType: file.mimetype,
    })

    try {
      await this.client.send(command)

      console.log(`File ${file.name} saved (private)`)

      const url = `${this.getBaseUrlPrivate()}/${key}`

      return { url }
    } catch (error) {
      console.error(`${error}`)
      throw new Error(`Could not upload private file with key "${key}"`)
    }
  }

  async fromPrivateToPublicUrl({
    url,
    expiresInSeconds = ONE_HOUR_IN_SECONDS,
  }: FromPrivateToPublicUrlOptions): Promise<UploadPrivateReturn> {
    if (!this.isUrlPrivate(url)) {
      throw new Error(`${url} must be a private url`)
    }

    await this.ensureCredentials()

    const key = this.extractKeyFromUrlPrivate(url)

    const params = {
      Bucket: `${this.bucketNamePrivate}`,
      Key: this.ensureKey(key),
    }

    const command = new GetObjectCommand(params)

    const urlPublic = await getSignedUrl(this.client, command, {
      expiresIn: expiresInSeconds,
    })

    return { url: urlPublic }
  }

  /* -------------------------------------------------------------------------- */
  /*                                   PRIVATE                                  */
  /* -------------------------------------------------------------------------- */

  private async listBuckets(): Promise<Bucket[]> {
    const result = await this.client.send(new ListBucketsCommand({}))

    const buckets = result.Buckets.map(item => ({
      name: item.Name,
      dateCreation: item.CreationDate,
    }))

    return buckets
  }

  private getBaseUrlPrivate(): string {
    return `https://${this.bucketNamePrivate}.s3.${this.region}.amazonaws.com`
  }

  private getBaseUrlPublic(): string {
    return `https://${this.bucketNamePublic}.s3.${this.region}.amazonaws.com`
  }

  private ensureKey(key: string): string {
    let keyClean = key

    const isPrefixedSlash = keyClean.startsWith('/')

    if (isPrefixedSlash) {
      keyClean = keyClean.slice(1)
    }

    const isPrefixedBucketKey = keyClean.startsWith(this.bucketKey)

    if (!isPrefixedBucketKey) {
      keyClean = `${this.bucketKey}/${keyClean}`
    }

    return keyClean
  }

  private isUrlPrivate(url: string): boolean {
    const baseUrlPrivate = this.getBaseUrlPrivate()

    const isPrivate = url.startsWith(baseUrlPrivate)

    return isPrivate
  }

  private extractKeyFromUrlPrivate(url: string): string {
    const baseUrlPrivate = this.getBaseUrlPrivate()

    return url.replace(baseUrlPrivate, '')
  }

  private setApiKey(apiKey: string) {
    this.httpClientOptions.headers['Authorization'] = apiKey
    this.httpClientOptions['credentials'] = 'include'
  }

  private async postMarblism<ReturnType>(url: string) {
    const baseUrl = this.getDashboardBaseUrl()

    const response = await this.httpClient
      .post<ReturnType>(`${baseUrl}${url}`, {}, this.httpClientOptions)
      .catch(error => {
        console.error(error)
        throw new Error(`Could not post to ${url}`)
      })

    return response.data
  }

  private getDashboardBaseUrl() {
    const isProduction = process.env.NODE_ENV === 'production'

    const valueDefault = `http://localhost:3001/api`
    const valueProduction = `https://api.marblism.com/api`

    return isProduction ? valueProduction : valueDefault
  }
}

================
File: src/server/libraries/upload/internal/providers/local/upload.provider.local.ts
================
import { Configuration } from '@/core/configuration'
import { FileHelper } from '@/core/helpers/file'
import {
  FromPrivateToPublicUrlOptions,
  UploadPrivateOptions,
  UploadPrivateReturn,
  UploadProvider,
  UploadPublicOptions,
  UploadPublicReturn,
} from '../../../upload.provider'

export class UploadProviderLocal extends UploadProvider {
  private staticServerUrl: string

  private pathPublicInternal = `./public/upload/public`
  private pathPrivateInternal = `./public/upload/private`
  private pathPublicExternal = `/upload/public`
  private pathPrivateExternal = `/upload/private`

  public initialise(): Promise<void> {
    try {
      FileHelper.writeFolder(this.pathPublicInternal)

      this.staticServerUrl = `${Configuration.getBaseUrl()}`

      console.log(`Upload Local is active`)
    } catch (error) {
      console.error(`Upload Local failed to start: ${error.message}`)
    }

    return
  }

  async uploadPublic({
    file,
  }: UploadPublicOptions): Promise<UploadPublicReturn> {
    const content = file.buffer

    const filename = this.ensureFilename(file.name)

    const path = FileHelper.joinPaths(this.pathPublicInternal, filename)

    FileHelper.writeFile(path, content)

    const url = `${this.staticServerUrl}${this.pathPublicExternal}/${filename}`

    return { url }
  }

  async uploadPrivate({
    file,
  }: UploadPrivateOptions): Promise<UploadPrivateReturn> {
    const content = Buffer.from(file.buffer)

    const filename = this.ensureFilename(file.name)

    const path = FileHelper.joinPaths(this.pathPrivateInternal, filename)

    FileHelper.writeFile(path, content)

    const url = `${this.staticServerUrl}${this.pathPrivateExternal}/${filename}`

    return { url }
  }

  async fromPrivateToPublicUrl({
    url,
  }: FromPrivateToPublicUrlOptions): Promise<UploadPrivateReturn> {
    return { url }
  }
}

================
File: src/server/libraries/upload/index.ts
================
export * from './upload.service'
export * from './upload.type'

================
File: src/server/libraries/upload/upload.provider.ts
================
import { DateHelper } from '@/core/helpers/date'
import { UploadFileType } from './upload.type'

export type UploadPrivateOptions = {
  file: UploadFileType
}

export type UploadPrivateReturn = {
  url: string
}

export type UploadPublicOptions = UploadPrivateOptions

export type UploadPublicReturn = UploadPrivateReturn

export type FromPrivateToPublicUrlOptions = {
  url: string
  expiresInSeconds?: number
}

export type FromPrivateToPublicUrlReturn = UploadPrivateReturn

export abstract class UploadProvider {
  abstract uploadPublic(
    options: UploadPublicOptions,
  ): Promise<UploadPublicReturn>
  abstract uploadPrivate(
    options: UploadPrivateOptions,
  ): Promise<UploadPrivateReturn>

  abstract fromPrivateToPublicUrl(
    options: FromPrivateToPublicUrlOptions,
  ): Promise<FromPrivateToPublicUrlReturn>

  public initialise(): Promise<void> {
    return
  }

  protected ensureFilename(filenameBefore: string): string {
    const filenameClean = filenameBefore.replace(/[^\w\.]/gi, '')
    const timestamp = DateHelper.getNow().getTime()

    return `${timestamp}-${filenameClean}`
  }
}

================
File: src/server/libraries/upload/upload.service.ts
================
import { UploadProviderAws } from './internal/providers/aws/upload.provider.aws'
import { UploadProviderLocal } from './internal/providers/local/upload.provider.local'
import { UploadProvider } from './upload.provider'
import { UploadFileType } from './upload.type'

export class Service {
  private isMounted = false
  private instance: UploadProvider

  constructor() {}

  async ensureInstance(): Promise<void> {
    if (this.isMounted) {
      return
    }

    if (!this.instance) {
      this.instance = await this.createInstance()
    }
  }

  private async createInstance(): Promise<UploadProvider> {
    try {
      console.log(`Trying using AWS...`)

      const instance = new UploadProviderAws()

      await instance.initialise()

      return instance
    } catch (error) {
      console.warn(`Could not use AWS: ${error.message}`)
    }

    console.log(
      `Falling back on local provider (not recommended for production)`,
    )

    try {
      const instance = new UploadProviderLocal()

      await instance.initialise()

      return instance
    } catch (error) {
      console.warn(`Could not use local provider: ${error.message}`)
    }
  }

  async uploadPublic(...files: UploadFileType[]): Promise<{ url: string }[]> {
    await this.ensureInstance()

    const responses = []

    for (const file of files) {
      const response = await this.instance.uploadPublic({ file })

      responses.push(response)
    }

    return responses
  }

  async uploadPrivate(...files: UploadFileType[]): Promise<{ url: string }[]> {
    await this.ensureInstance()

    const responses = []

    for (const file of files) {
      const response = await this.instance.uploadPrivate({ file })

      responses.push(response)
    }

    return responses
  }

  async fromPrivateToPublicUrl(
    ...items: { url: string; expiresInSeconds?: number }[]
  ): Promise<{ url: string }[]> {
    await this.ensureInstance()

    const responses = []

    for (const item of items) {
      const response = await this.instance.fromPrivateToPublicUrl(item)

      responses.push(response)
    }

    return responses
  }
}

class Singleton {
  static service = new Service()
}

export const UploadService = Singleton.service

================
File: src/server/libraries/upload/upload.type.ts
================
export type UploadFileType = {
  name: string
  buffer: Buffer
  mimetype: string
}

================
File: src/server/routers/ai.router.ts
================
import { DateHelper } from '@/core/helpers/date'
import { FileHelper } from '@/core/helpers/file'
import { Trpc } from '@/core/trpc/server'
import { TRPCError } from '@trpc/server'
import axios from 'axios'
import { z } from 'zod'
import { OpenaiService } from '../libraries/openai'
import { UploadFileType, UploadService } from '../libraries/upload'

/**
 * @provider AiApi
 * @description An AI library to query OpenAI
 * @function {({ prompt: string }) => Promise<{ answer: string}>} generateText - Send the prompt to OpenAI and get back its answer
 * @function {({ prompt: string }) => Promise<{ url: string }>} generateImage - Send the prompt to OpenAI to generate an Image and get back the URL of the image in the answer
 * @function {({ url: string }) => Promise<{ translation: string }>} audioToText - Send the readStream of an audio file to OpenAI to transcribe it into text and get back the text in the answer
 * @function {({ text: string } => Promise<{ url: string }>} textToAudio - Send the text to OpenAI to convert it into an mp3 file and get back the url of the audio file
 * @usage `const generateText = Api.ai.generateText.useMutation(); generateText.mutateAsync({ prompt: 'How are you?' }).then(response => response.answer);`
 * @isImportOverriden false
 * @isAlwaysIncluded false
 * @import import { Api } from '@/core/trpc'
 */
const check = () => {
  if (!OpenaiService.isActive()) {
    throw new TRPCError({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Set OPENAI_API_KEY in your .env to activate OpenAI',
    })
  }
}

export const AiRouter = Trpc.createRouter({
  generateText: Trpc.procedure
    .input(
      z.object({
        prompt: z.string(),
        attachmentUrls: z.array(z.string()).optional(),
      }),
    )
    .mutation(async ({ input }) => {
      check()

      const answer = await OpenaiService.generateText(
        input.prompt,
        input.attachmentUrls,
      )

      return { answer }
    }),
  generateAssistantText: Trpc.procedure
    .input(
      z.object({
        prompt: z.string(),
        attachmentUrls: z.array(z.string()).optional(),
      }),
    )
    .mutation(async ({ input }) => {
      check()

      const answer = await OpenaiService.generateAssistantText(
        input.prompt,
        input.attachmentUrls,
      )

      return { answer }
    }),

  /**
   * ? The schema in this function is an example. You should update it to your use-case.
   * ? If you need multiple schemas, you can create one dedicated function for each.
   */
  generateJson: Trpc.procedure
    .input(
      z.object({
        instruction: z.string(),
        content: z.string(),
        attachmentUrls: z.array(z.string()).optional(),
      }),
    )
    .mutation(async ({ input }) => {
      const schema = z.object({
        results: z.array(
          z.object({
            description: z.string(),
          }),
        ),
      })

      const json = await OpenaiService.generateJson(
        input.instruction,
        input.content,
        schema,
        input.attachmentUrls,
      )

      return json
    }),

  generateImage: Trpc.procedure
    .input(z.object({ prompt: z.string() }))
    .mutation(async ({ input }) => {
      check()

      const url = await OpenaiService.generateImage(input.prompt)

      return { url }
    }),

  audioToText: Trpc.procedure
    .input(z.object({ url: z.string() }))
    .mutation(async ({ input }) => {
      check()

      const arrayBuffer = await axios
        .get<ArrayBuffer>(input.url, { responseType: 'arraybuffer' })
        .then(response => response.data)

      const readstream = await FileHelper.createReadStreamFromArrayBuffer(
        arrayBuffer,
        'audio.wav',
      )

      const translation = await OpenaiService.fromAudioToText(readstream)

      return { translation }
    }),

  textToAudio: Trpc.procedure
    .input(z.object({ text: z.string() }))
    .mutation(async ({ input }) => {
      check()

      const buffer = await OpenaiService.fromTextToAudio(input.text)

      const now = DateHelper.getNow()

      const name = `${now.getTime()}__text-to-audio.mp3`

      const file: UploadFileType = {
        name,
        mimetype: 'audio/mp3',
        buffer,
      }

      const urls = await UploadService.uploadPublic(file)

      const url = urls[0].url

      return { url }
    }),
})

================
File: src/server/routers/authentication.router.ts
================
import { Configuration } from '@/core/configuration'
import { Utility } from '@/core/helpers/utility'
import { Trpc } from '@/core/trpc/server'
import { User } from '@prisma/client'
import { TRPCError } from '@trpc/server'
import * as Bcrypt from 'bcryptjs'
import * as Jwt from 'jsonwebtoken'
import { z } from 'zod'
import { EmailService } from '../libraries/email'

export const AuthenticationRouter = Trpc.createRouter({
  register: Trpc.procedurePublic
    .input(
      z.object({
        email: z.string().email(),
        name: z.string(),
        pictureUrl: z.string().optional(),
        password: z.string(),

        tokenInvitation: z.string().optional(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      checkPassword(input.password)

      const payload = checkTokenInvitation(input.tokenInvitation)

      const email = input.email.trim().toLowerCase()

      let user: User

      if (payload?.userId) {
        user = await ctx.databaseUnprotected.user.findUnique({
          where: { id: payload.userId, status: 'INVITED' },
        })

        if (!user) {
          throw new TRPCError({
            code: 'CONFLICT',
            message: 'User was not found',
          })
        }
      } else {
        const userExisting = await ctx.databaseUnprotected.user.findUnique({
          where: { email },
        })

        if (userExisting) {
          throw new TRPCError({
            code: 'CONFLICT',
            message: 'Email is not available',
          })
        }
      }

      const passwordHashed = hashPassword(input.password)

      if (user) {
        user = await ctx.databaseUnprotected.user.update({
          where: { id: user.id },
          data: { ...input, password: passwordHashed, status: 'VERIFIED' },
        })
      } else {
        user = await ctx.databaseUnprotected.user.create({
          data: { ...input, password: passwordHashed },
        })
      }

      return { id: user.id }
    }),

  sendResetPasswordEmail: Trpc.procedurePublic
    .input(z.object({ email: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const email = input.email.trim().toLowerCase()

      const user = await ctx.databaseUnprotected.user.findUniqueOrThrow({
        where: { email },
      })

      const payload = { userId: user.id }

      const secret = Configuration.getAuthenticationSecret()

      const TIME_24_HOURS = 60 * 60 * 24

      const token = Jwt.sign(payload, secret, { expiresIn: TIME_24_HOURS })

      const url = Configuration.getBaseUrl()

      const urlResetPassword = `${url}/reset-password/${token}`

      const type = EmailService.Type.AUTHENTICATION_FORGOT_PASSWORD

      try {
        await EmailService.send({
          type,
          email: user.email,
          name: user.name ?? user.email,
          subject: `Reset your password`,
          variables: {
            url_password_reset: urlResetPassword,
          },
        })

        return { success: true }
      } catch (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Could not send the email',
        })
      }
    }),

  resetPassword: Trpc.procedurePublic
    .input(z.object({ token: z.string(), password: z.string() }))
    .mutation(async ({ ctx, input }) => {
      checkPassword(input.password)

      const secret = Configuration.getAuthenticationSecret()

      let decoded: { userId: string }

      try {
        decoded = Jwt.verify(input.token, secret) as { userId: string }
      } catch (error) {
        throw new TRPCError({
          code: 'UNAUTHORIZED',
          message: 'Token is invalid',
        })
      }

      const user = await ctx.databaseUnprotected.user.findUniqueOrThrow({
        where: { id: decoded.userId },
      })

      const passwordHashed = hashPassword(input.password)

      await ctx.databaseUnprotected.user.update({
        where: { id: user.id },
        data: {
          password: passwordHashed,
        },
      })

      return { success: true }
    }),

  inviteToOrganization: Trpc.procedure
    .input(
      z.object({
        email: z.string().email(),
        organizationId: z.string(),
        roleName: z.string().optional(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const { organizationId, roleName = 'member' } = input

      const email = input.email.trim().toLowerCase()

      const organization = await ctx.database.organization.findUniqueOrThrow({
        where: { id: organizationId },
      })

      let user = await ctx.database.user.findUnique({
        where: { email },
      })

      if (!user) {
        user = await ctx.databaseUnprotected.user.create({
          data: { email, status: 'INVITED' },
        })
      }

      const payload = { userId: user.id }

      const secret = Configuration.getAuthenticationSecret()

      const token = Jwt.sign(payload, secret)

      user = await ctx.databaseUnprotected.user.update({
        where: { id: user.id },
        data: { tokenInvitation: token },
      })

      let organizationRole = await ctx.database.organizationRole.findFirst({
        where: { organizationId: organization.id, userId: user.id },
      })

      if (organizationRole) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: `${email} is already in your organization`,
        })
      }

      organizationRole = await ctx.database.organizationRole.create({
        data: {
          organizationId: organization.id,
          userId: user.id,
          name: roleName,
        },
      })

      return { user, organizationRole }
    }),
})

const checkPassword = (password: string) => {
  const isValid = password?.length >= 6

  if (isValid) {
    return
  }

  throw new TRPCError({
    code: 'BAD_REQUEST',
    message: 'Password must have at least 6 characters.',
  })
}

const checkTokenInvitation = (token?: string) => {
  if (Utility.isNull(token)) {
    return
  }

  const secret = Configuration.getAuthenticationSecret()

  let decoded: { userId: string }

  try {
    decoded = Jwt.verify(token, secret) as { userId: string }
  } catch (error) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'Token is invalid',
    })
  }

  return decoded
}

const hashPassword = (password: string) => {
  const saltRounds = 10
  const salt = Bcrypt.genSaltSync(saltRounds)
  const passwordHashed = Bcrypt.hashSync(password, salt)

  return passwordHashed
}

================
File: src/server/routers/billing.router.ts
================
import { Configuration } from '@/core/configuration'
import { Trpc } from '@/core/trpc/server'
import { User } from '@prisma/client'
import { TRPCError } from '@trpc/server'
import { z } from 'zod'
import { PaymentService } from '../libraries/payment'

import { Organization } from '@prisma/client'

/**
 * @provider BillingApi
 * @description A api to query the billing API
 * @function {() => Promise<BillingProduct[]>} findManyProducts - Find many products
 * @function {() => Promise<BillingSubscription[]>} findManySubscriptions - Find many subscriptions
 * @function {() => Promise<BillingPayment[]>} findManyPayments - Find many payments
 * @function {(options: {productId: string}) => Promise<string>} createPaymentLink - Create a payment link for a product
 * @usage `const {data: products, isLoading} = api.billing.findManyProducts.useQuery({}); `
 * @isImportOverriden false
 * @isAlwaysIncluded false
 * @import import { Api } from '@/core/trpc'
 */

export const BillingRouter = Trpc.createRouter({
  findManyProducts: Trpc.procedurePublic
    .input(z.object({}))
    .query(async ({}) => {
      checkStripeNotActive()

      return PaymentService.findManyProducts()
    }),
  findManyPayments: Trpc.procedure
    .input(
      z.object({
        organizationId: z.string().optional(),
      }),
    )
    .query(async ({ ctx, input }) => {
      checkStripeNotActive()

      const userId = ctx.session?.user?.id
      const user = await ctx.database.user.findFirstOrThrow({
        where: { id: userId },
      })

      let organization: Organization

      if (input.organizationId) {
        organization = await ctx.database.organization.findUniqueOrThrow({
          where: { id: input.organizationId },
        })
      }

      checkCustomerId(organization ?? user)

      return PaymentService.findManyPayments(user)
    }),
  findManySubscriptions: Trpc.procedure
    .input(
      z.object({
        organizationId: z.string().optional(),
      }),
    )
    .query(async ({ ctx, input }) => {
      checkStripeNotActive()

      const userId = ctx.session?.user?.id
      const user = await ctx.database.user.findFirstOrThrow({
        where: { id: userId },
      })

      let organization: Organization

      if (input.organizationId) {
        organization = await ctx.database.organization.findUniqueOrThrow({
          where: { id: input.organizationId },
        })
      }

      checkCustomerId(organization ?? user)

      return PaymentService.findManySubscriptions(organization ?? user)
    }),

  createPaymentLink: Trpc.procedure
    .input(
      z.object({
        productId: z.string(),

        organizationId: z.string().optional(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      checkStripeNotActive()

      const userId = ctx.session?.user?.id

      let user = await ctx.database.user.findFirstOrThrow({
        where: { id: userId },
      })

      let organization: Organization

      if (input.organizationId) {
        organization = await ctx.database.organization.findUniqueOrThrow({
          where: { id: input.organizationId },
        })
      }

      let stripeCustomerId = PaymentService.getCustomerId(organization ?? user)

      if (!stripeCustomerId) {
        stripeCustomerId = await PaymentService.createCustomer(
          user,

          organization,
        )

        if (organization) {
          organization = await ctx.database.organization.update({
            where: { id: organization.id },
            data: { stripeCustomerId },
          })
        } else {
          user = await ctx.database.user.update({
            where: { id: user.id },
            data: { stripeCustomerId },
          })
        }
      }

      const urlRedirection = Configuration.getBaseUrl()

      const url = await PaymentService.createPaymentLink({
        user,

        organization,

        productId: input.productId,
        metadata: {
          userId: user.id,

          organizationId: organization.id,
        },
        urlRedirection,
      })

      return { url }
    }),
})

const checkStripeNotActive = () => {
  if (!PaymentService.isActive()) {
    throw new TRPCError({
      code: 'BAD_REQUEST',
      message: 'Stripe is not active',
    })
  }
}

const checkCustomerId = (customer: User | Organization) => {
  if (!PaymentService.getCustomerId(customer)) {
    throw new TRPCError({
      code: 'BAD_REQUEST',
      message: 'No customer id',
    })
  }
}

================
File: src/server/routers/configuration.router.ts
================
import { Trpc } from '@/core/trpc/server'

export const ConfigurationRouter = Trpc.createRouter({
  getPublic: Trpc.procedurePublic.query(async () => {
    const variables = process.env ?? {}

    const variablesPublic: Record<string, any> = {}

    for (const [key, value] of Object.entries(variables)) {
      const isPublic = key.startsWith('PUBLIC_')

      if (isPublic) {
        variablesPublic[key] = value
      }
    }

    return variablesPublic
  }),
})

================
File: src/server/routers/rag.router.ts
================
import { Trpc } from '@/core/trpc/server'
import { TRPCError } from '@trpc/server'
import { z } from 'zod'
import { RagService } from '../libraries/rag'

/**
 * @provider RagRouter
 * @description An AI RAG library to load a file and query it.
 * @function {({ url: string, tags?: string[] }) => Promise<{ id: string, key: string }>} loadFile - Send a file url that will be downloaded and stored in the RAG context with optional tags. It returns the id in the database and the key which is a hash of the url.
 * @function {({ prompt: string, history?: string[], tags?: string[] }) => Promise<{ answer: string}>} generateText - Send a prompt and get an AI answer to the prompt. Can also receive a history of messages for continous conversation with the AI. Can also receive an array of tags to narrow down the RAG context (the file key returned from the loadFile function can be given here to target a specific file).
 * @usage `const { mutateAsync: loadFile } = Api.rag.loadFile.useMutation(); const { mutateAsync: generateText } = Api.rag.generateText.useMutation(); const { key } = loadFile({ url }); generateText({ prompt: 'What is the title of the document?', tags: [key] }).then(response => response.answer);`
 * @isImportOverriden false
 * @isAlwaysIncluded false
 * @import import { Api } from '@/core/trpc'
 */
export const RagRouter = Trpc.createRouter({
  loadFile: Trpc.procedure
    .input(z.object({ url: z.string(), tags: z.array(z.string()).optional() }))
    .mutation(async ({ input }) => {
      try {
        const ragVector = await RagService.createAndSaveFile(
          input.url,
          input.tags,
        )

        return { id: ragVector.id, key: ragVector.key }
      } catch (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Could not load file / web page: ${error.message}`,
        })
      }
    }),

  generateText: Trpc.procedure
    .input(
      z.object({
        prompt: z.string(),
        history: z.array(z.string()).optional(),
        tags: z.array(z.string()).optional(),
      }),
    )
    .mutation(async ({ input }) => {
      try {
        const answer = await RagService.query(
          input.prompt,
          input.history,
          input.tags,
        )

        return { answer }
      } catch (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Could not query: ${error.message}`,
        })
      }
    }),
})

================
File: src/server/routers/upload.router.ts
================
import { Trpc } from '@/core/trpc/server'
import { z } from 'zod'
import { UploadService } from '../libraries/upload'

export const UploadRouter = Trpc.createRouter({
  fromPrivateToPublicUrl: Trpc.procedure
    .input(
      z.object({
        url: z.string(),
      }),
    )
    .mutation(async ({ input }) => {
      const response = await UploadService.fromPrivateToPublicUrl({
        url: input.url,
      })

      const url = response[0].url

      return { url }
    }),
})

================
File: src/server/index.tsx
================
import { createRouter } from '@/.marblism/api/routers'
import { Trpc } from '@/core/trpc/server'
import { AiRouter } from './routers/ai.router'
import { AuthenticationRouter } from './routers/authentication.router'
import { ConfigurationRouter } from './routers/configuration.router'
import { UploadRouter } from './routers/upload.router'

import { BillingRouter } from './routers/billing.router'

import { RagRouter } from './routers/rag.router'

const appRouter = Trpc.mergeRouters(
  createRouter(Trpc.createRouter, Trpc.procedurePublic), // The generated tRPC router for all your models

  // the custom router, add your own routers here
  Trpc.createRouter({
    ai: AiRouter,
    authentication: AuthenticationRouter,

    billing: BillingRouter,

    configuration: ConfigurationRouter,
    upload: UploadRouter,

    rag: RagRouter,
  }),
)

export type AppRouter = typeof appRouter

export const Server = {
  appRouter,
}

================
File: .env.template
================
NEXTAUTH_SECRET=your-secret
NEXTAUTH_URL=http://localhost:8099
SERVER_DATABASE_URL=postgres://root:root@localhost:5442/api
SERVER_OPENAI_API_KEY=
SERVER_PAYMENT_STRIPE_SECRET_KEY=
SERVER_PAYMENT_STRIPE_WEBHOOK_SECRET=
SERVER_UPLOAD_AWS_ACCESS_KEY=
SERVER_UPLOAD_AWS_SECRET_KEY=
SERVER_UPLOAD_AWS_BUCKET_PUBLIC_NAME=
SERVER_UPLOAD_AWS_BUCKET_PRIVATE_NAME=
SERVER_UPLOAD_AWS_REGION=

================
File: .eslintrc.json
================
{
  "extends": "next/core-web-vitals",
  "rules": {
    "react-hooks/exhaustive-deps": "off",
    "react/jsx-key": "warn"
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
/.pnpm

# testing
/coverage

# database
/prisma/db.sqlite
/prisma/db.sqlite-journal
db.sqlite

# next.js
/.next/
/out/
next-env.d.ts

# production
/build

#mail
/data

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
# do not commit any .env files to git, except for the .env.example file.
.env
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo

# upload folder
/public/upload

/tmp

================
File: .marblism.json
================
{
  "type": "nextjs",
  "commands": {
    "build": "pnpm run build",
    "start": "pnpm run database:sync && pnpm run start"
  },
  "commandsWorkspace": {
    "init": "pnpm install && pnpm run global:sync ; pnpm run database:seed",
    "dev": "pnpm run dev"
  }
}

================
File: .prettierrc
================
{
  "semi": false,
  "singleQuote": true,
  "arrowParens": "avoid",
  "trailingComma": "all"
}

================
File: docker-compose.yml
================
version: '3.8'
services:
  database:
    container_name: postgresql
    image: postgres
    restart: always
    environment:
      POSTGRES_USER: root
      POSTGRES_PASSWORD: root
      POSTGRES_DB: api
    ports:
      - '5442:5432'
  pgadmin:
    container_name: pgadmin4
    image: dpage/pgadmin4
    restart: always
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@admin.com
      PGADMIN_DEFAULT_PASSWORD: root
    ports:
      - '5052:80'
  mail:
    container_name: mail
    image: axllent/mailpit
    restart: always
    volumes:
      - ./data:/data
    ports:
      - 8022:8025
      - 1022:1025
    environment:
      MP_MAX_MESSAGES: 5000
      MP_DATA_FILE: /data/mailpit.db
      MP_SMTP_AUTH_ACCEPT_ANY: 1
      MP_SMTP_AUTH_ALLOW_INSECURE: 1

================
File: next.config.js
================
/**
 * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially useful
 * for Docker builds.
 */

/** @type {import("next").NextConfig} */
const config = {
  reactStrictMode: false,
  
  experimental: {
    serverComponentsExternalPackages: ['pdf-parse'],
  },
  webpack(config) {
    config.experiments = { ...config.experiments, topLevelAwait: true }
    config.externals = [...config.externals, 'hnswlib-node'] // required for RAG module
    return config
  },
  
}

export default config

================
File: package.json
================
{
  "name": "@marblism/nextjs",
  "version": "1.0.5",
  "private": true,
  "type": "module",
  "scripts": {
    "init": "pnpm install && pnpm run docker:init ; pnpm run env:init ; pnpm run global:sync ; pnpm run database:seed",
    "dev": "pnpm run global:sync && next dev -p 8099",
    "build": "pnpm run crud:sync && next build",
    "start": "next start -p 8099",
    "lint": "next lint",
    "check": "tsc",
    "global:sync": "pnpm run crud:sync && pnpm run database:sync:dev",
    "crud:sync": "pnpm zenstack generate",
    "database:sync": "prisma db push",
    "database:sync:dev": "prisma db push --accept-data-loss",
    "database:seed": "tsx ./prisma/seed/mockUser.ts && tsx ./prisma/seed/mockData.ts ",
    "database:migration:generate": "prisma migrate dev --name auto --create-only",
    "database:migration:run": "prisma migrate deploy",
    "database:studio": "prisma studio",
    "docker:init": "docker compose -p marblism-app up -d",
    "env:init": "node scripts/env.js",
    "format": "pnpm run format:code && pnpm run format:models",
    "format:code": "prettier --write \"src/!(*.marblism)/**/*.{ts,tsx}\"",
    "format:models": "node scripts/format.models.js"
  },
  "dependencies": {
    "@ant-design/icons": "^5.3.7",
    "@auth/prisma-adapter": "1.6.0",
    "@aws-sdk/client-s3": "^3.502.0",
    "@aws-sdk/s3-request-presigner": "^3.572.0",
    "@langchain/community": "^0.2.18",
    "@langchain/core": "^0.2.15",
    "@langchain/openai": "^0.2.1",
    "@mapbox/mapbox-sdk": "^0.16.0",
    "@prisma/client": "5.15.1",
    "@tailwindcss/typography": "^0.5.13",
    "@tanstack/react-query": "^4.36.1",
    "@tanstack/react-query-devtools": "^4.36.1",
    "@trpc/client": "^10.37.1",
    "@trpc/next": "^10.37.1",
    "@trpc/react-query": "^10.37.1",
    "@trpc/server": "^10.37.1",
    "ai": "^3.2.22",
    "antd": "^5.18.2",
    "autoprefixer": "^10.4.19",
    "axios": "^1.7.2",
    "bcryptjs": "^2.4.3",
    "cheerio": "1.0.0-rc.12",
    "clsx": "^2.1.1",
    "date-fns": "^3.6.0",
    "dayjs": "^1.11.11",
    "geist": "^1.3.0",
    "hnswlib-node": "^3.0.0",
    "jsonwebtoken": "^9.0.2",
    "langchain": "^0.2.9",
    "mammoth": "^1.8.0",
    "mapbox-gl": "^3.5.1",
    "multer": "1.4.5-lts.1",
    "next": "^14.2.1",
    "next-auth": "^4.24.7",
    "node-mailjet": "^6.0.5",
    "nodemailer": "^6.9.14",
    "notistack": "^3.0.1",
    "openai": "^4.58.1",
    "papaparse": "^5.4.1",
    "pdf-parse": "^1.1.1",
    "postcss": "^8.4.39",
    "posthog-js": "^1.154.2",
    "prisma": "5.15.1",
    "react": "^18.3.0",
    "react-dom": "^18.3.0",
    "recharts": "^2.12.7",
    "sass": "^1.77.8",
    "server-only": "^0.0.1",
    "stripe": "^15.12.0",
    "superjson": "^2.2.1",
    "tailwind-merge": "^2.4.0",
    "tailwindcss": "^3.4.6",
    "ts-node": "^10.9.2",
    "tsx": "^4.15.6",
    "uuid": "^10.0.0",
    "zod": "^3.21.1",
    "zod-form-data": "^2.0.2"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/eslint": "^8.56.2",
    "@types/mapbox__mapbox-sdk": "^0.14.0",
    "@types/node": "^20.11.20",
    "@types/papaparse": "^5.3.14",
    "@types/pdf-parse": "^1.1.4",
    "@types/react": "^18.2.57",
    "@types/react-dom": "^18.2.19",
    "@zenstackhq/runtime": "2.4.0",
    "@zenstackhq/server": "2.4.0",
    "@zenstackhq/tanstack-query": "2.4.0",
    "@zenstackhq/trpc": "2.4.0",
    "concurrently": "^8.2.2",
    "eslint": "^8.57.0",
    "eslint-config-next": "^14.1.3",
    "nodemon": "^3.1.3",
    "prettier": "^3.2.5",
    "typescript": "^5.4.2",
    "zenstack": "2.4.0"
  },
  "ct3aMetadata": {
    "initVersion": "7.34.0"
  },
  "zenstack": {
    "schema": "./models/schema.zmodel"
  }
}

================
File: postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: README.md
================
<div style="background: black;">
<p align="center" style="margin: 0;">
  <a href="https://dev.marblism.com" target="blank">
    <img src="https://marblism-dashboard-api--production-public.s3.us-west-1.amazonaws.com/marblism-logo.png" height="150" alt="Marblism Logo" />
  </a>
</p>
<h1 align="center" style="margin: 0;">mel_bot the HR</h1>
</div>
<div style="height: 50px; background: linear-gradient(#000000, transparent);"></div>

## Documentation

Built on Marblism. Learn more in the [official documentation](https://dev.marblism.com).

## Installation

<div style="color: red;">

>  **Important**<br/>Make sure the following tools are installed on your computer

<p align="center">

<a target="_blank" href="https://www.docker.com/get-started/">![Docker Desktop Version](https://img.shields.io/badge/Docker%20Desktop-4.19.0-black?logo=docker)</a>
<a target="_blank" href="https://nodejs.org/en">![Node.js version](https://img.shields.io/badge/Node.js-20.11.0-black?logo=nodedotjs)</a>
<a target="_blank" href="https://www.npmjs.com/">![npm Version](https://img.shields.io/badge/npm-10.2.4-black?logo=npm)</a>

</p>
</div>

<br />

```bash
$ pnpm run init
```

## Development

```bash
$ pnpm run dev
```

[View your application in your browser](http://localhost:8099)

## Production

```bash
$ pnpm run build
$ pnpm run start
```

================
File: tailwind.config.ts
================
/** @type {import('tailwindcss').Config} */
const defaultTheme = require('tailwindcss/defaultTheme')
module.exports = {
  darkMode: 'selector',
  content: ['./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}'],
  theme: {
    extend: {
      fontFamily: {
        sans: ['Inter Variable', 'Inter', ...defaultTheme.fontFamily.sans],
      },
    },
  },
  plugins: [require('@tailwindcss/typography')],
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    /* Base Options: */
    "esModuleInterop": true,
    "target": "ES2016",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,
    "noUncheckedIndexedAccess": true,
    "checkJs": true,
    /* Bundled projects */
    "lib": ["dom", "dom.iterable", "ES2022"],
    "noEmit": true,
    "module": "commonjs",
    "jsx": "preserve",
    "plugins": [
      {
        "name": "next"
      }
    ],
    "incremental": true,
    /* Path Aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "moduleResolution": "node",
    "skipLibCheck": true,
    "strict": false,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "types": ["@types/mapbox__mapbox-sdk"]
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    "**/*.cjs",
    "**/*.js",
    ".next/types/**/*.ts"
  ],
  "exclude": ["node_modules"]
}
